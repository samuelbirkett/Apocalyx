<html>
<head>
<title>APOCALYX Engine - Programmer's Manual - FASM Interface</title>
</head>

<body bgcolor=#CCCCCC>
<font face="verdana,arial" size=-1>

<center>
<h1>APOCALYX Engine</h1>
<h2>Programmer's Manual</h2>
<h3>FASM Interface</h3>
<h5>Copyright &copy 2002-2007 <A HREF="mailto:tetractys@users.sourceforge.net">Leonardo Boselli</A></h5>
</center>
<p><hr>
<p>This paper is provided as is without warranties of any kind.
<ul>
<p><li><b>FASM</b> interface
<p><ul>
<li><b><a href="#fasm_section">Part VI</a></b> is a verbatim copy taken from "<i>flat assembler - Programmer's Manual</i>", copyright  &copy; 1999-2005 Tomasz Grysztar, that is included in the official documentation of the assembler (version 1.64). To get more information visit the site <a href="http://flatassembler.net/">http://flatassembler.net/</a>.
<li><b>Part IX</b> that should describe the core API of FASM does not exist because FASM can access all the functions available to the C interface (use C function call convention), so refer to <a href="APOCALYX-manual-C.htm#the_TinyC_API">Part V</a> for futher details.
</ul>
</ul>

<center><p><hr><a name=index><h2>Index</h2></a><hr></center>

<ul>

<p><li><a href=#fasm_section>Part VI - The Flat Assembler</a><br>
<BR><SPAN class=mediumtext><a href=#fasm_section_chapter1>Chapter 1 - 
Introduction</a></SPAN><BR><A class=mediumtext 
style="PADDING-LEFT: 20pt" 
href="#1.1">1.1 
Compiler overview</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.1.1">1.1.1 
System requirements</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.1.2">1.1.2 
Executing compiler from command line</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.1.3">1.1.3 
Compiler messages</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.1.4">1.1.4 
Output formats</A><BR><A class=mediumtext 
style="PADDING-LEFT: 20pt" 
href="#1.2">1.2 
Assembly syntax</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.1">1.2.1 
Instruction syntax</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.2">1.2.2 
Data definitions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.3">1.2.3 
Constants and labels</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.4">1.2.4 
Numerical expressions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.5">1.2.5 
Jumps and calls</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#1.2.6">1.2.6 
Size settings</A><BR><SPAN class=mediumtext><a href=#fasm_section_chapter2>Chapter 2 - 
Instruction Set</a></SPAN><BR><A class=mediumtext 
style="PADDING-LEFT: 20pt" 
href="#2.1">2.1 
The x86 architecture instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.1">2.1.1 
Data movement instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.2">2.1.2 
Type conversion instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.3">2.1.3 
Binary arithmetic instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.4">2.1.4 
Decimal arithmetic instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.5">2.1.5 
Logical instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.6">2.1.6 
Control transfer instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.7">2.1.7 
I/O instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.8">2.1.8 
Strings operations</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.9">2.1.9 
Flag control instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.10">2.1.10 
Conditional operations</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.11">2.1.11 
Miscellaneous instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.12">2.1.12 
System instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.13">2.1.13 
FPU instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.14">2.1.14 
MMX instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.15">2.1.15 
SSE instructions</A><BR><A class=sralltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.16">2.1.16 
SSE2 instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.17">2.1.17 
SSE3 instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.18">2.1.18 
AMD 3DNow! instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.1.19">2.1.19 
The x86-64 long mode instructions</A><BR><A 
class=mediumtext style="PADDING-LEFT: 20pt" 
href="#2.2">2.2 
Control directives</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.2.1">2.2.1 
Conditional assembly</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.2.2">2.2.2 
Repeating blocks of instructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.2.3">2.2.3 
Addressing spaces</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.2.4">2.2.4 
Other directives</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.2.5">2.2.5 
Multiple passes</A><BR><A class=mediumtext 
style="PADDING-LEFT: 20pt" 
href="#2.3">2.3 
Preprocessor directives</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.1">2.3.1 
Including source files</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.2">2.3.2 
Symbolic constants</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.3">2.3.3 
Macroinstructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.4">2.3.4 
Structures</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.5">2.3.5 
Repeating macroinstructions</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.6">2.3.6 
Conditional preprocessing</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.3.7">2.3.7 
Order of processing</A><BR><A class=mediumtext 
style="PADDING-LEFT: 20pt" 
href="#2.4">2.4 
Formatter directives</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.4.1">2.4.1 
MZ executable</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.4.2">2.4.2 
Portable Executable</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.4.3">2.4.3 
Common Object File Format</A><BR><A class=smalltext 
style="PADDING-LEFT: 40pt" 
href="#2.4.4">2.4.4 
Executable and Linkable Format</A><BR></B></P>

</ul>

<hr>

<a name=fasm_section><h3>Part VI - The Flat Assembler</h3></a>

<font size="-2">Verbatim copy from "<i>the flat assembler - Programmer's Manual</i>" (1.64), Copyright  &copy; 1999-2005 Tomasz Grysztar.</font>

<hr>

<p>
<P><B><SPAN class=mediumtext><a name=fasm_section_chapter1>Chapter 1</a></SPAN><BR><SPAN 
class=largetext>Introduction</SPAN><BR></B></P>
<P class=smalltext>This chapter contains all the most 
important information you need to begin using the flat 
assembler. If you are experienced assembly language 
programmer, you should read at least this chapter before using 
this compiler. </P>
<P><B><A class=mediumtext name=1.1>1.1 Compiler overview</A> 
</B></P>
<P class=smalltext>Flat assembler is a fast assembly language 
compiler for the x86 architecture processors, which does 
multiple passes to optimize the size of generated machine 
code. It is self-compilable and versions for different 
operating systems are provided. All the versions are designed 
to be used from the system command line and they should not 
differ in behavior. </P>
<P><B><A class=smalltext name=1.1.1>1.1.1 System 
requirements</A> </B></P>
<P class=smalltext>All versions require the x86 architecture 
32-bit processor (at least 80386), although they can produce 
programs for the x86 architecture 16-bit processors, too. DOS 
version requires an OS compatible with MS DOS 2.0 and either 
true real mode environment or DPMI. Windows version requires a 
Win32 console compatible with 3.1 version. </P>
<P><B><A class=smalltext name=1.1.2>1.1.2 Executing compiler 
from command line</A> </B></P>
<P class=smalltext>To execute flat assembler from the command 
line you need to provide two parameters - first should be name 
of source file, second should be name of destination file. If 
no second parameter is given, the name for output file will be 
guessed automatically. After displaying short information 
about the program name and version, compiler will read the 
data from source file and compile it. When the compilation is 
successful, compiler will write the generated code to the 
destination file and display the summary of compilation 
process; otherwise it will display the information about error 
that occurred. </P>
<P class=smalltext>In the command line you can also include 
<SPAN class=smallcode>-m</SPAN> option followed by a number, 
which specifies how many kilobytes of memory flat assembler 
should maximally use. In case of DOS version this options 
limits only the usage of extended memory. The <SPAN 
class=smallcode>-p</SPAN> option followed by a number can be 
used to specify the limit for number of passes the assembler 
performs. If code cannot be generated within specified amount 
of passes, the assembly will be terminated with an error 
message. The maximum value of this setting is 65536, while the 
default limit, used when ro such option is included in command 
line, is 100. </P>
<P class=smalltext>The source file should be a text file, and 
can be created in any text editor. Line breaks are accepted in 
both DOS and Unix standards, tabulators are treated as spaces. 
</P>
<P class=smalltext>There are no command line options that 
would affect the output of compiler, flat assembler requires 
only the source code to include the information it really 
needs. For example, to specify output format you specify it by 
using the <SPAN class=smallcode>format</SPAN> directive at the 
beginning of source. </P>
<P><B><A class=smalltext name=1.1.3>1.1.3 Compiler 
messages</A> </B></P>
<P class=smalltext>As it is stated above, after the successful 
compilation, the compiler displays the compilation summary. It 
includes the information of how many passes was done, how much 
time it took, and how many bytes were written into the 
destination file. The following is an example of the 
compilation summary: </P><PRE class=smallcode>flat assembler	version 1.64
38 passes, 5.3 seconds, 77824 bytes.
</PRE>
<P class=smalltext>In case of error during the compilation 
process, the program will display an error message. For 
example, when compiler can't find the input file, it will 
display the following message: </P><PRE class=smallcode>flat assembler	version 1.64
error: source file not found.
</PRE>
<P class=smalltext>If the error is connected with a specific 
part of source code, the source line that caused the error 
will be also displayed. Also placement of this line in the 
source is given to help you finding this error, for example: 
</P><PRE class=smallcode>flat assembler	version 1.64
example.asm [3]:
	mob	ax,1
error: illegal instruction.
</PRE>
<P class=smalltext>It means that in the third line of the 
<SPAN class=smallcode>example.asm</SPAN> file compiler has 
encountered an unrecognized instruction. When the line that 
caused error contains a macroinstruction, also the line in 
macroinstruction definition that generated the erroneous 
instruction is displayed: </P><PRE class=smallcode>flat assembler	version 1.64
example.asm [6]:
	stoschar 7
example.asm [3] stoschar [1]:
	mob	al,char
error: illegal instruction.
</PRE>
<P class=smalltext>It means that the macroinstruction in the 
sixth line of the <SPAN class=smallcode>example.asm</SPAN> 
file generated an unrecognized instruction with the first line 
of its definition. </P>
<P><B><A class=smalltext name=1.1.4>1.1.4 Output formats</A> 
</B></P>
<P class=smalltext>By default, when there is no <SPAN 
class=smallcode>format</SPAN> directive in source file, flat 
assembler simply puts generated instruction codes into output, 
creating this way flat binary file. By default it generates 
16-bit code, but you can always turn it into the 16-bit or 
32-bit mode by using <SPAN class=smallcode>use16</SPAN> or 
<SPAN class=smallcode>use32</SPAN> directive. Some of the 
output formats switch into 32-bit mode, when selected - more 
information about formats which you can choose can be found in 
<A 
href="#2.4">2.4</A>. 
</P>
<P class=smalltext>All output code is always in the order in 
which it was entered into the source file. </P>
<P><B><A class=mediumtext name=1.2>1.2 Assembly syntax</A> 
</B></P>
<P class=smalltext>The information provided below is intended 
mainly for the assembler programmers that have been using some 
other assembly compilers before. If you are beginner, you 
should look for the assembly programming tutorials. </P>
<P class=smalltext>Flat assembler by default uses the Intel 
syntax for the assembly instructions, although you can 
customize it using the preprocessor capabilities 
(macroinstructions and symbolic constants). It also has its 
own set of the directives - the instructions for compiler. 
</P>
<P class=smalltext>All symbols defined inside the sources are 
case-sensitive. </P>
<P><B><A class=smalltext name=1.2.1>1.2.1 Instruction 
syntax</A> </B></P>
<P class=smalltext>Instructions in assembly language are 
separated by line breaks, and one instruction is expected to 
fill the one line of text. If a line contains a semicolon, 
except for the semicolons inside the quoted strings, the rest 
of this line is the comment and compiler ignores it. If a line 
ends with <SPAN class=smallcode>\</SPAN> character (eventually 
the semicolon and comment may follow it), the next line is 
attached at this point. </P>
<P class=smalltext>Each line in source is the sequence of 
items, which may be one of the three types. One type are the 
symbol characters, which are the special characters that are 
individual items even when are not spaced from the other ones. 
Any of the <SPAN 
class=smallcode>+-/*=&lt;&gt;()[]{}:,|&amp;~#`</SPAN> is the 
symbol character. The sequence of other characters, separated 
from other items with either blank spaces or symbol 
characters, is a symbol. If the first character of symbol is 
either a single or double quote, it integrates the any 
sequence of characters following it, even the special ones, 
into a quoted string, which should end with the same 
character, with which it began (the single or double quote) - 
however if there are two such characters in a row (without any 
other character between them), they are integrated into quoted 
string as just one of them and the quoted string continues 
then. The symbols other than symbol characters and quoted 
strings can be used as names, so are also called the name 
symbols. </P>
<P class=smalltext>Every instruction consists of the mnemonic 
and the various number of operands, separated with commas. The 
operand can be register, immediate value or a data addressed 
in memory, it can also be preceded by size operator to define 
or override its size (table <A 
href="#1.1">1.1</A>). 
Names of available registers you can find in table <A 
href="#1.2">1.2</A>, 
their sizes cannot be overridden. Immediate value can be 
specified by any numerical expression. </P>
<P class=smalltext>When operand isra data in memory, the 
address of that data (also any numerical expression, but it 
may contain registers) should be enclosed in square brackets 
or preceded by <SPAN class=smallcode>ptr</SPAN> operator. For 
example instruction <SPAN class=smallcode>mov eax,3</SPAN> 
will put the immediate value 3 into the EAX register, 
instruction <SPAN class=smallcode>mov eax,[7]</SPAN> will put 
the 32-bit value from the address 7 into EAX and the 
instruction <SPAN class=smallcode>mov byte [7],3</SPAN> will 
put the immediate value 3 into the byte at address 7, it can 
also be written as <SPAN class=smallcode>mov byte ptr 
7,3</SPAN>. To specify which segment register should be used 
for addressing, segment register name followed by a colon 
should be put just before the address value (inside the square 
brackets or after the <SPAN class=smallcode>ptr</SPAN> 
operator). </P>
<P class=smalltext><B><a name=1.1>Table 1.1 Size 
operators</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=150 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Operator</TH>
<TH align=middle bgColor=#ffffff>Bits</TH>
<TH align=middle bgColor=#ffffff>Bytes</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>byte</SPAN></TD>
<TD align=middle bgColor=#ffffff>8</TD>
<TD align=middle bgColor=#ffffff>1</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>word</SPAN></TD>
<TD align=middle bgColor=#ffffff>16</TD>
<TD align=middle bgColor=#ffffff>2</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>dword</SPAN></TD>
<TD align=middle bgColor=#ffffff>32</TD>
<TD align=middle bgColor=#ffffff>4</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>fword</SPAN></TD>
<TD align=middle bgColor=#ffffff>48</TD>
<TD align=middle bgColor=#ffffff>6</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>pword</SPAN></TD>
<TD align=middle bgColor=#ffffff>48</TD>
<TD align=middle bgColor=#ffffff>6</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>qword</SPAN></TD>
<TD align=middle bgColor=#ffffff>64</TD>
<TD align=middle bgColor=#ffffff>8</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>tbyte</SPAN></TD>
<TD align=middle bgColor=#ffffff>80</TD>
<TD align=middle bgColor=#ffffff>10</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>tword</SPAN></TD>
<TD align=middle bgColor=#ffffff>80</TD>
<TD align=middle bgColor=#ffffff>10</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>dqword</SPAN></TD>
<TD align=middle bgColor=#ffffff>128</TD>
<TD align=middle bgColor=#ffffff>16</TD></TR></TBODY></TABLE>
<P class=smalltext><B><a name=1.2>Table 1.2 Registers</A></B> 
</P>
<TABLE cellSpacing=1 cellPadding=0 width=430 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle width=70 bgColor=#ffffff>Type</TH>
<TH align=middle width=40 bgColor=#ffffff>Bits</TH>
<TH align=middle bgColor=#ffffff></TH></TR>
<TR>
<TD vAlign=center align=middle bgColor=#ffffff 
rowSpan=3>General</TD>
<TD align=middle bgColor=#ffffff>8</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>al</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cl</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dl</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>bl</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ah</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ch</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dh</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>bh</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>16</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ax</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>bx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>sp</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>bp</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>si</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>di</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>32</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>eax</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ecx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcodr>edx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ebx</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>esp</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ebp</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>esi</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>edi</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>Segment</TD>
<TD align=middle bgColor=#ffffff>16</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>es</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cs</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ss</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>ds</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>fs</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>gs</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>Control</TD>
<TD align=middle bgColor=#ffffff>32</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cr0</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cr2</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cr3</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>cr4</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>Debug</TD>
<TD align=middle bgColor=#ffffff>32</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dr0</SPAN></TD>
<TD align=middlerwidth="12.5%"><SPAN 
class=smallcode>dr1</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dr2</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dr3</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode></SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dr6</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>dr7</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>FPU</TD>
<TD align=middle bgColor=#ffffff>80</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st0</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st1</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st2</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st3</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st4</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st5</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st6</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>st7</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>MMX</TD>
<TD align=middle bgColor=#ffffff>64</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm0</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm1</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm2</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm3</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm4</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm5</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm6</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>mm7</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>SSE</TD>
<TD align=middle bgColor=#ffffff>128</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm0</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm1</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm2</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm3</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm4</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm5</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm6</SPAN></TD>
<TD align=middle width="12.5%"><SPAN 
class=smallcode>xmm7</SPAN></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><B><A class=smalltext name=1.2.2>1.2.2 Data definitions</A> 
</B></P>
<P class=smalltext>To define data or reserve a space for it, 
use one of the directives listed in table <A 
href="#1.3">1.3</A>. 
The data definition directive should be followed by one or 
more of numerical expressions, separated with commas. These 
expressions define the values for data cells of size depending 
on which directive is used. For example <SPAN 
class=smallcode>db 1,2,3</SPAN> will define the three bytes of 
values 1, 2 and 3 respectively. </P>
<P class=smalltext>The <SPAN class=smallcode>db</SPAN> and 
<SPAN class=smallcode>du</SPAN> directives also accept the 
quoted string values of any length, which will be converted 
into chain of bytes when <SPAN class=smallcode>db</SPAN> is 
used and into chain of words with zeroed high byte when <SPAN 
class=smallcode>du</SPAN> is used. For example <SPAN 
class=smallcode>db 'abc'</SPAN> will define the three bytes of 
values 61, 62 and 63. </P>
<P class=smalltext>The <SPAN class=smallcode>dp</SPAN> 
directive and its synonym <SPAN class=smallcode>df</SPAN> 
accept the values consisting of two numerical expressions 
separated with colon, the first value will become the high 
word and the second value will become the low double word of 
the far pointer value. Also <SPAN class=smallcode>dd</SPAN> 
accepts such pointers consisting of two word values separated 
with colon, and <SPAN class=smallcode>dt</SPAN> accepts the 
word and quad word value separated with colon, the quad word 
is stored first. The <SPAN class=smallcode>dt</SPAN> directive 
with single expression as parameter accepts only floating 
point values and creates data in FPU double extended precision 
format. </P>
<P class=smalltext>Any of the above directive allows the usage 
of special <SPAN class=smallcode>dup</SPAN> operator to make 
multiple copies of given values. The count of duplicates 
should precede this operator and the value to duplicate should 
follow - it can even be the chain of values separated with 
commas, but such set of values needs to be enclosed with 
parenthesis, like <SPAN 
class=smallcode>db&nbsp;5&nbsp;dup&nbspr(1,2)</SPAN>, which 
defines five copies of the given two byte sequence. </P>
<P class=smalltext>The <SPAN class=smallcode>file</SPAN> is a 
special directive and its syntax is different. This directive 
includes a chain of bytes from file and it should be followed 
by the quoted file name, then optionally numerical expression 
specifying offset in file preceded by the colon, then - also 
optionally - comma and numerical expression specifying count 
of bytes to include (if no count is specified, all data up to 
the end of file is included). For example <SPAN 
class=smallcode>file&nbsp;'data.bin'</SPAN> will include the 
whole file as binary data and <SPAN 
class=smallcode>file&nbsp;'data.bin':10h,4</SPAN> will include 
only four bytes starting at offset 10h. </P>
<P class=smalltext>The data reservation directive should be 
followed by only one numerical expression, and this value 
defines how many cells of the specified size should be 
reserved. All data definition directives also accept the <SPAN 
class=smallcode>?</SPAN> value, which means that this cell 
should not be initialized to any value and the effect is the 
same as by using the data reservation directive. The 
uninitialized data may not be included in the output file, so 
its values should be always considered unknown. </P>
<P class=smalltext><B><a name=1.3>Table 1.3 Data 
directives</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=150 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Size (bytes)</TH>
<TH align=middle bgColor=#ffffff>Define data</TH>
<TH align=middle bgColor=#ffffff>Reserve data</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff>1</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>db</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>file</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rb</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>2</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>dw</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>du</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rw</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>4</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>dd</SPAN></TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rd</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>6</TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>dp</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>df</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>rp</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rf</SPAN></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>8</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>dq</SPAN></TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rq</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>10</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>dt</SPAN></TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rt</SPAN></TD></TR></TBODY></TABLE>
<P><B><A class=smalltext name=1.2.3>1.2.3 Constants and 
labels</A> </B></P>
<P class=smalltext>In the numerical expressions you can also 
use constants or labels instead of numbers. To define the 
constant or label you should use the specific directives. Each 
label can be defined only once and it is accessible from the 
any place of source (even before it was defined). Constant can 
be redefined many times, but in this case it is accessible 
only after it was defined, and is always equal to the value 
from last definition before the place where it's used. When a 
constant is defined only once in source, it is - like the 
label - accessible from anywhere. </P>
<P class=smalltext>The definition of constant consists of name 
of the constant followed by the <SPAN class=smallcode>=</SPAN> 
character and numerical expression, which after calculation 
will become the value of constant. This value is always 
calculated at the time the constant is defined. For example 
you can define <SPAN class=smallcode>count</SPAN> constant by 
using the directive <SPAN class=smallcode>count = 17</SPAN> 
and then use it in the assembly instructions, like <SPAN 
class=smallcode>mov cx,count</SPAN> - which will become <SPAN 
class=smallcode>mov cx,17</SPAN> during the compilation 
process. </P>
<P class=smalltext>There are different ways to define labels. 
The simplest is to follow the name of label by the colon, this 
directive can even be followed by the other instruction in the 
same line. It defines the label whose value is equal to offset 
of the point where it's defined. This method is usually used 
to label the places in code. The other way is to follow the 
name of label (without a colon) by some data directive. It 
defines the label with value equal to offset of the beginning 
of defined data, and remembered as a label for data with cell 
size ar specified for that data directive in table <A 
href="#1.3">1.3</A>. 
</P>
<P class=smalltext>The label can be treated as constant of 
value equal to offset of labeled code or data. For example 
when you define data using the labeled directive <SPAN 
class=smallcode>char db 224</SPAN>, to put the offset of this 
data into BX register you should use <SPAN class=smallcode>mov 
bx,char</SPAN> instruction, and to put the value of byte 
addressed by <SPAN class=smallcode>char</SPAN> label to DL 
register, you should use <SPAN class=smallcode>mov 
dl,[char]</SPAN> (or <SPAN class=smallcode>mov dl,ptr 
char</SPAN>). But when you try to assemble <SPAN 
class=smallcode>mov ax,[char]</SPAN>, it will cause an error, 
because fasm compares the sizes of operands, which should be 
equal. You can force assembling that instruction by using size 
override: <SPAN class=smallcode>mov ax,word [char]</SPAN>, but 
remember that this instruction will read the two bytes 
beginning at <SPAN class=smallcode>char</SPAN> address, while 
it was defined as a one byte. </P>
<P class=smalltext>The last and the most flexible way to 
define labels is to use <SPAN class=smallcode>label</SPAN> 
directive. This directive should be followed by the name of 
label, then optionally size operator (it can be preceded by a 
colon) and then - also optionally <SPAN 
class=smallcode>at</SPAN> operator and the numerical 
expression defining the address at which this label should be 
defined. For example <SPAN class=smallcode>label wchar word at 
char</SPAN> will define a new label for the 16-bit data at the 
address of <SPAN class=smallcode>char</SPAN>. Now the 
instruction <SPAN class=smallcode>mov ax,[wchar]</SPAN> will 
be after compilation the same as <SPAN class=smallcode>mov 
ax,word [char]</SPAN>. If no address is specified, <SPAN 
class=smallcode>label</SPAN> directive defines the label at 
current offset. Thus <SPAN class=smallcode>mov 
[wchar],57568</SPAN> will copy two bytes while <SPAN 
class=smallcode>mov [char],224</SPAN> will copy one byte to 
the same address. </P>
<P class=smalltext>The label whose name begins with dot is 
treated as local label, and its name is attached to the name 
of last global label (with name beginning with anything but 
dot) to make the full name of this label. So you can use the 
short name (beginning with dot) of this label anywhere before 
the next global label is defined, and in the other places you 
have to use the full name. Label beginning with two dots are 
the exception - they are like global, but they don't become 
the new prefix for local labels. </P>
<P class=smalltext>The <SPAN class=smallcode>@@</SPAN> name 
means anonymous label, you can have defined many of them in 
the source. Symbol <SPAN class=smallcode>@b</SPAN> (or 
equivalent <SPAN class=smallcode>@r</SPAN>) references the 
nearest preceding anonymous label, symbol <SPAN 
class=smallcode>@f</SPAN> references the nearest following 
anonymous label. These special symbol are case-insensitive. 
</P>
 <P><B><A class=smalltext name=1.2.4>1.2.4 Numerical 
expressions</A> </B></P>
<P class=smalltext>In the above examples all the numerical 
expressions were the simple numbers, constants or labels. But 
they can be more complex, by using the arithmetical or logical 
operators for calculations at compile time. All these 
operators with their priority values are listed in table <A 
href="#1.4">1.4</A>. 
The operations with higher priority value will be calculated 
first, you can of course change this behavior by putting some 
parts of expression into parenthesis. The <SPAN 
class=smallcode>+</SPAN>, <SPAN class=smallcode>-</SPAN>, 
<SPAN class=smallcode>*</SPAN> and <SPAN 
class=smallcode>/</SPAN> are standard arithmetical operations, 
<SPAN class=smallcode>mod</SPAN> calculates the remainder from 
division. The <SPAN class=smallcode>and</SPAN>, <SPAN 
class=smallcode>or</SPAN>, <SPAN class=smallcode>xor</SPAN>, 
<SPAN class=smallcode>shl</SPAN>, <SPAN 
class=smallcode>shr</SPAN> and <SPAN 
class=smallcode>not</SPAN> perform the same logical operations 
as assembly instructions of those names. The <SPAN 
class=smallcode>rva</SPAN> is specific to PE output format and 
performs the conversion of an address into the RVA. </P>
<P class=smalltext>The numbers in the expression are by 
default treated as a decimal, binary numbers should have the 
<SPAN class=smallcode>b</SPAN> letter attached at the end, 
octal number should end with <SPAN class=smallcode>o</SPAN> 
letter, hexadecimal numbers should begin with <SPAN 
class=smallcode>0x</SPAN> characters (like in C language) or 
with the <SPAN class=smallcode>$</SPAN> character (like in 
Pascal language) or they should end with <SPAN 
class=smallcode>h</SPAN> letter. Also quoted string, when 
encountered in expression, will be converted into number - the 
first character will become the least significant byte of 
number. </P>
<P class=smalltext>The numerical expression used as an address 
value can also contain any of general registers used for 
addressing, they can be added and multiplied by appropriate 
values, as it is allowed for the x86 architecture 
instructions. </P>
<P class=smalltext>There are also some special symbols that 
can be used inside the numerical expression. First is <SPAN 
class=smallcode>$</SPAN>, which is always equal to the value 
of current offset, while <SPAN class=smallcode>$$</SPAN> is 
equal to base address of current addressing space. The other 
one is <SPAN class=smallcode>%</SPAN>, which is the number of 
current repeat in parts of code that are repeated using some 
special directives (see <A 
href="#2.2">2.2</A>). 
There's also <SPAN class=smallcode>%t</SPAN> symbol, which is 
always equal to the current time stamp. </P>
<P class=smalltext>Any numerical expression can also consist 
of single floating point value (flat assembler does not allow 
any floating point operations at compilation time) in the 
scientific notation, they can rnd with the <SPAN 
class=smallcode>f</SPAN> letter to be recognized, otherwise 
they should contain at least one of the <SPAN 
class=smallcode>.</SPAN> or <SPAN class=smallcode>E</SPAN> 
characters. So <SPAN class=smallcode>1.0</SPAN>, <SPAN 
class=smallcode>1E0</SPAN> and <SPAN class=smallcode>1f</SPAN> 
define the same floating point value, while simple <SPAN 
class=smallcode>1</SPAN> defines an integer value. </P>
<P class=smalltext><B><a name=1.4>Table 1.4 Arithmetical and 
logical operators by priority</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=200 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Priority</TH>
<TH align=middle bgColor=#ffffff>Operators</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff>0</TD>
<TD align=middle bgColor=#ffffff><SPAN class=smallcode>+ 
-</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>1</TD>
<TD align=middle bgColor=#ffffff><SPAN class=smallcode>* 
/</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>2</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>mod</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>3</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>and or xor</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>4</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>shl shr</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>5</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>not</SPAN></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>6</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>rva</SPAN></TD></TR></TBODY></TABLE>
<P><B><A class=smalltext name=1.2.5>1.2.5 Jumps and calls</A> 
</B></P>
<P class=smalltext>The operand of any jump or call instruction 
can be preceded not only by the size operator, but also by one 
of the operators specifying type of the jump: <SPAN 
class=smallcode>near</SPAN> of <SPAN 
class=smallcode>far</SPAN>. For example, when assembler is in 
16-bit mode, instruction <SPAN class=smallcode>jmp dword 
[0]</SPAN> will become the far jump and when assembler is in 
32-bit mode, it will become the near jump. To force this 
instruction to be treated differently, use the <SPAN 
class=smallcode>jmp near dword [0]</SPAN> or <SPAN 
class=smallcode>jmp far dword [0]</SPAN> form. </P>
<P class=smalltext>When operand of near jump is the immediate 
value, assembler will generate the shortest variant of this 
jump instruction if possible (but won't create 32-bit 
instruction in 16-bit mode nor 16-bit instruction in 32-bit 
mode, unless there is a size operator stating it). By 
specifying the size operator you can force it to always 
generate long variant (for example <SPAN class=smallcode>jmp 
word 0</SPAN> in 16-bit mode and <SPAN class=smallcode>jrp 
dword 0</SPAN> in 32-bit mode) or to always generate short 
variant and terminate with an error when it's impossible (for 
example <SPAN class=smallcode>jmp byte 0</SPAN>). </P>
<P><B><A class=smalltext name=1.2.6>1.2.6 Size settings</A> 
</B></P>
<P class=smalltext>When instruction uses some memory 
addressing, by default the shorter 8-bit form is generated if 
only address value fits in range, but it can be overridden 
using the <SPAN class=smallcode>word</SPAN> or <SPAN 
class=smallcode>dword</SPAN> operator before the address 
inside the square brackets (or after the <SPAN 
class=smallcode>ptr</SPAN> operator). Such size operator 
placement can also be used to force address size other than 
default for the given mode. </P>
<P class=smalltext>Instructions <SPAN 
class=smallcode>adc</SPAN>, <SPAN class=smallcode>add</SPAN>, 
<SPAN class=smallcode>and</SPAN>, <SPAN 
class=smallcode>cmp</SPAN>, <SPAN class=smallcode>or</SPAN>, 
<SPAN class=smallcode>sbb</SPAN>, <SPAN 
class=smallcode>sub</SPAN> and <SPAN 
class=smallcode>xor</SPAN> with first operand being 16-bit or 
32-bit are by default generated in shortened 8-bit form when 
the second operand is immediate value fitting in the range for 
signed 8-bit values. It also can be overridden by putting the 
<SPAN class=smallcode>word</SPAN> or <SPAN 
class=smallcode>dword</SPAN> operator before the immediate 
value. The similar rules applies to the <SPAN 
class=smallcode>imul</SPAN> instruction with the last operand 
being immediate value. </P>
<P class=smalltext>Immediate value as an operand for <SPAN 
class=smallcode>push</SPAN> instruction without a size 
operator is by default treated as a word value if assembler is 
in 16-bit mode and as a double word value if assembler is in 
32-bit mode, shorter 8-bit form of this instruction is used if 
possible, <SPAN class=smallcode>word</SPAN> or <SPAN 
class=smallcode>dword</SPAN> size operator forces the <SPAN 
class=smallcode>push</SPAN> instruction to be generated in 
longer form for specified size. <SPAN 
class=smallcode>pushw</SPAN> and <SPAN 
class=smallcode>pushd</SPAN> mnemonics force assembler to 
generate 16-bit or 32-bit code without forcing it to use the 
longer form of instruction. </P>
<P><B><SPAN class=mediumtext><a name=fasm_section_chapter2>Chapter 2</a></SPAN><BR><SPAN 
class=largetext>Instruction set</SPAN><BR></B></P>
<P><B><A class=mediumtext name=2.1>2.1 The x86 architecture 
instructions</A> </B></P>
<P class=smalltext>In this section you can find both the 
information about the syntax and purpose the assembly language 
instructions. If you need more technical information, look for 
the Intel Architecture Software Developer's Manual. </P>
<P class=smalltext>Assembly instructions consist of the 
mnemonic (instruction's name) and from zero to three operands. 
If there are two or more operands, usually first is the 
destination operand and second is the source operand. Each 
operand can be register, memory or immediate value (see <A 
href="#1.2">1.r</A> 
for details about syntax of operands). After the description 
of each instruction there are examples of different 
combinations of operands, if the instruction has any. </P>
<P class=smalltext>Some instructions act as prefixes and can 
be followed by other instruction in the same line, and there 
can be more than one prefix in a line. Each name of the 
segment register is also a mnemonic of instruction prefix, 
altough it is recommended to use segment overrides inside the 
square brackets instead of these prefixes. </P>
<P><B><A class=smalltext name=2.1.1>2.1.1 Data movement 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>mov</SPAN> transfers 
a byte, word or double word from the source operand to the 
destination operand. It can transfer data between general 
registers, from the general register to memory, or from memory 
to general register, but it cannot move from memory to memory. 
It can also transfer an immediate value to general register or 
memory, segment register to general register or memory, 
general register or memory to segment register, control or 
debug register to general register and general register to 
control or debug register. The <SPAN 
class=smallcode>mov</SPAN> can be assembled only if the size 
of source operand and size of destination operand are the 
same. Below are the examples for each of the allowed 
combinations: </P><PRE class=smallcode>mov bx,ax	; general register to general register
mov [char],al ; general register to memory
mov bl,[char] ; memory to general register
mov dl,32	; immediate value to general register
mov [char],32 ; immediate value to memory
mov ax,ds	; segment register to general register
mov [bx],ds ; segment register to memory
mov ds,ax	; general register to segment register
mov ds,[bx] ; memory to segment register
mov eax,cr0 ; control register to general register
mov cr3,ebx ; general register to control register
</PRE>
<P class=smalltext><SPAN class=smallcode>xchg</SPAN> swaps the 
contents of two operands. It can swap two byte operands, two 
word operands or two double word operands. Order of operands 
is not important. The operands may be two general registers, 
or general register with memory. For example: </P><PRE class=smallcode>xchg ax,bx	; swap two general registers
xchg al,[char]; swap register with memory
</PRE>
<P class=smalltext><SPAN class=smallcode>push</SPAN> 
decrements the stack frame pointer (ESP register), then 
transfers the operand to the top of stack indicated by ESP. 
The operand can be memory, general register, segment register 
or immediate value of word or double word size. If operand is 
an immediate value and no size is specified, it is by default 
treated as a word value if assembler is in 16-bit mode and as 
a double word value if assembler is in 32-bit mode. <SPAN 
class=smallcode>pushw</SPAN> and <SPAN 
class=smallcode>pushd</SPAN> mnemonics are variants of this 
instruction that store the values of word or double word size 
respectively. If more operands follow in the same line 
(separated only with spaces, not commas), compiler will 
assemble chain of the <SPAN class=smallcode>purh</SPAN> 
instructions with these operands. The examples are with single 
operands: </P><PRE class=smallcode>push ax	; store general register
push es	; store segment register
pushw [bx]	; store memory
push 1000h	; store immediate value
</PRE>
<P class=smalltext><SPAN class=smallcode>pusha</SPAN> saves 
the contents of the eight general register on the stack. This 
instruction has no operands. There are two version of this 
instruction, one 16-bit and one 32-bit, assembler 
automatically generates the appropriate version for current 
mode, but it can be overridden by using <SPAN 
class=smallcode>pushaw</SPAN> or <SPAN 
class=smallcode>pushad</SPAN> mnemonic to always get the 
16-bit or 32-bit version. The 16-bit version of this 
instruction pushes general registers on the stack in the 
following order: AX, CX, DX, BX, the initial value of SP 
before AX was pushed, BP, SI and DI. The 32-bit version pushes 
equivalent 32-bit general registers in the same order. </P>
<P class=smalltext><SPAN class=smallcode>pop</SPAN> transfers 
the word or double word at the current top of stack to the 
destination operand, and then increments ESP to point to the 
new top of stack. The operand can be memory, general register 
or segment register. <SPAN class=smallcode>popw</SPAN> and 
<SPAN class=smallcode>popd</SPAN> mnemonics are variants of 
this instruction for restoring the values of word or double 
word size respectively. If more operands separated with spaces 
follow in the same line, compiler will assemble chain of the 
<SPAN class=smallcode>pop</SPAN> instructions with these 
operands. </P><PRE class=smallcode>pop bx	; restore general register
pop ds	; restore segment register
popw [si]	; restore memory
</PRE>
<P class=smalltext><SPAN class=smallcode>popa</SPAN> restores 
the registers saved on the stack by <SPAN 
class=smallcode>pusha</SPAN> instruction, except for the saved 
value of SP (or ESP), which is ignored. This instruction has 
no operands. To force assembling 16-bit or 32-bit version of 
this instruction use <SPAN class=smallcode>popaw</SPAN> or 
<SPAN class=smallcode>popad</SPAN> mnemonic. </P>
<P><B><A class=smalltext name=2.1.2>2.1.2 Type conversion 
instructions</A> </B></P>
<P class=smalltext>The type conversion instructions convert 
bytes into words, words into double words, and double words 
into quad words. These conversions can be done using the sign 
extension or zero extension. The sign extension fills the 
extra bits of the larger item with the value of the sign bit 
of the smaller item, the zero extension simply fills them with 
zeros. </P>
<P class=smalltext><SPAN class=smallcode>cwd</SPAN> and <SPAN 
class=smallcode>cdq</SPAN> double the size of value AX or EAX 
register respectively and store the extra bits into the DX or 
EDX register. The conversion is done using the sign extension. 
These instructions have no operands. </P>
<P class=smalltext><SPAN class=smallcode>cbw</SPAN> extends 
the sign of the byte in AL throughout AX, and <SPAN 
class=smallcode>cwde</SPAN> extends the sign of the word in AX 
r throughout EAX. These instructions also have no operands. </P>
<P class=smalltext><SPAN class=smallcode>movsx</SPAN> converts 
a byte to word or double word and a word to double word using 
the sign extension. <SPAN class=smallcode>movzx</SPAN> does 
the same, but it uses the zero extension. The source operand 
can be general register or memory, while the destination 
operand must be a general register. For example: </P><PRE class=smallcode>movsx ax,al 	; byte register to word register
movsx edx,dl	; byte register to double word register
movsx eax,ax	; word register to double word register
movsx ax,byte [bx]	; byte memory to word register
movsx edx,byte [bx] ; byte memory to double word register
movsx eax,word [bx] ; word memory to double word register
</PRE>
<P><B><A class=smalltext name=2.1.3>2.1.3 Binary arithmetic 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>add</SPAN> replaces 
the destination operand with the sum of the source and 
destination operands and sets CF if overflow has occurred. The 
operands may be bytes, words or double words. The destination 
operand can be general register or memory, the source operand 
can be general register or immediate value, it can also be 
memory if the destination operand is register. </P><PRE class=smallcode>add ax,bx	; add register to register
add ax,[si] ; add memory to register
add [di],al ; add register to memory
add al,48	; add immediate value to register
add [char],48 ; add immediate value to memory
</PRE>
<P class=smalltext><SPAN class=smallcode>adc</SPAN> sums the 
operands, adds one if CF is set, and replaces the destination 
operand with the result. Rules for the operands are the same 
as for the <SPAN class=smallcode>add</SPAN> instruction. An 
<SPAN class=smallcode>add</SPAN> followed by multiple <SPAN 
class=smallcode>adc</SPAN> instructions can be used to add 
numbers longer than 32 bits. </P>
<P class=smalltext><SPAN class=smallcode>inc</SPAN> adds one 
to the operand, it does not affect CF. The operand can be 
general register or memory, and the size of the operand can be 
byte, word or double word. </P><PRE class=smallcode>inc ax	; increment register by one
inc byte [bx] ; increment memory by one
</PRE>
<P class=smalltext><SPAN class=smallcode>sub</SPAN> subtracts 
the source operand from the destination operand and replaces 
the destination operand with the result. If a borrow is 
required, the CF is set. Rules for the operands are the same 
as for the <SPAN class=smallcode>add</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>sbb</SPAN> subtracts 
the source operand from the destination operand, subtracts one 
if CF is set, and stores the result to the destination 
operand. Rules for the operands are the same as for the <SPAN 
class=smallcode>add</SPAN> instruction. A <SPAN 
class=smallcode>sub</SPAN> followed by multiple <SPAN 
class=smallcode>sbb</SPAN> instructions may be used to 
subtract numbers longer than 32 bits. </P>
<P class=smalltext><SPAN class=smallcode>dec</SPAN> subtracts 
one from the operand, it does not affect CF. Rules for the 
operand are the same as for the <SPAN 
class=smallcode>inc</SPAN> instrrction. </P>
<P class=smalltext><SPAN class=smallcode>cmp</SPAN> subtracts 
the source operand from the destination operand. It updates 
the flags as the <SPAN class=smallcode>sub</SPAN> instruction, 
but does not alter the source and destination operands. Rules 
for the operands are the same as for the <SPAN 
class=smallcode>sub</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>neg</SPAN> subtracts 
a signed integer operand from zero. The effect of this 
instructon is to reverse the sign of the operand from positive 
to negative or from negative to positive. Rules for the 
operand are the same as for the <SPAN 
class=smallcode>inc</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>xadd</SPAN> exchanges 
the destination operand with the source operand, then loads 
the sum of the two values into the destination operand. Rules 
for the operands are the same as for the <SPAN 
class=smallcode>add</SPAN> instruction. </P>
<P class=smalltext>All the above binary arithmetic 
instructions update SF, ZF, PF and OF flags. SF is always set 
to the same value as the result's sign bit, ZF is set when all 
the bits of result are zero, PF is set when low order eight 
bits of result contain an even number of set bits, OF is set 
if result is too large for a positive number or too small for 
a negative number (excluding sign bit) to fit in destination 
operand. </P>
<P class=smalltext><SPAN class=smallcode>mul</SPAN> performs 
an unsigned multiplication of the operand and the accumulator. 
If the operand is a byte, the processor multiplies it by the 
contents of AL and returns the 16-bit result to AH and AL. If 
the operand is a word, the processor multiplies it by the 
contents of AX and returns the 32-bit result to DX and AX. If 
the operand is a double word, the processor multiplies it by 
the contents of EAX and returns the 64-bit result in EDX and 
EAX. <SPAN class=smallcode>mul</SPAN> sets CF and OF when the 
upper half of the result is nonzero, otherwise they are 
cleared. Rules for the operand are the same as for the <SPAN 
class=smallcode>inc</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>imul</SPAN> performs 
a signed multiplication operation. This instruction has three 
variations. First has one operand and behaves in the same way 
as the <SPAN class=smallcode>mul</SPAN> instruction. Second 
has two operands, in this case destination operand is 
multiplied by the source operand and the result replaces the 
destination operand. Destination operand must be a general 
register, it can be word or double word, source operand can be 
general register, memory or immediate value. Third form has 
three operands, the destination operand must be a general 
register, word or double word in size, source operand can be 
general register or memory, and third operand must be an 
immediate value. The source operand is multiplied by the 
immediate value and the result is stored in the destination 
register. All the three forms calculate the product to twice 
the size of operands and set CF and OF when the rpper half of 
the result is nonzero, but second and third form truncate the 
product to the size of operands. So second and third forms can 
be also used for unsigned operands because, whether the 
operands are signed or unsigned, the lower half of the product 
is the same. Below are the examples for all three forms: </P><PRE class=smallcode>imul bl	; accumulator by register
imul word [si]; accumulator by memory
imul bx,cx	; register by register
imul bx,[si]; register by memory
imul bx,10	; register by immediate value
imul ax,bx,10 ; register by immediate value to register
imul ax,[si],10 ; memory by immediate value to register
</PRE>
<P class=smalltext><SPAN class=smallcode>div</SPAN> performs 
an unsigned division of the accumulator by the operand. The 
dividend (the accumulator) is twice the size of the divisor 
(the operand), the quotient and remainder have the same size 
as the divisor. If divisor is byte, the dividend is taken from 
AX register, the quotient is stored in AL and the remainder is 
stored in AH. If divisor is word, the upper half of dividend 
is taken from DX, the lower half of dividend is taken from AX, 
the quotient is stored in AX and the remainder is stored in 
DX. If divisor is double word, the upper half of dividend is 
taken from EDX, the lower half of dividend is taken from EAX, 
the quotient is stored in EAX and the remainder is stored in 
EDX. Rules for the operand are the same as for the <SPAN 
class=smallcode>mul</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>idiv</SPAN> performs 
a signed division of the accumulator by the operand. It uses 
the same registers as the <SPAN class=smallcode>div</SPAN> 
instruction, and the rules for the operand are the same. </P>
<P><B><A class=smalltext name=2.1.4>2.1.4 Decimal arithmetic 
instructions</A> </B></P>
<P class=smalltext>Decimal arithmetic is performed by 
combining the binary arithmetic instructions (already 
described in the prior section) with the decimal arithmetic 
instructions. The decimal arithmetic instructions are used to 
adjust the results of a previous binary arithmetic operation 
to produce a valid packed or unpacked decimal result, or to 
adjust the inputs to a subsequent binary arithmetic operation 
so the operation will produce a valid packed or unpacked 
decimal result. </P>
<P class=smalltext><SPAN class=smallcode>daa</SPAN> adjusts 
the result of adding two valid packed decimal operands in AL. 
<SPAN class=smallcode>daa</SPAN> must always follow the 
addition of two pairs of packed decimal numbers (one digit in 
each half-byte) to obtain a pair of valid packed decimal 
digits as results. The carry flag is set if carry was needed. 
This instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>das</SPAN> adjusts 
the result of subtracting two valid packed decimal operands in 
AL. <SPAN class=smallcode>das</SPAN> must always follow the 
subtraction of one pair of packed decimal numbers (one digit 
in each half-byte) from another to obtain a pair of valid 
packed decimal digits as results. The carry flag is set if a 
borrow was needed. This irstruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>aaa</SPAN> changes 
the contents of register AL to a valid unpacked decimal 
number, and zeroes the top four bits. <SPAN 
class=smallcode>aaa</SPAN> must always follow the addition of 
two unpacked decimal operands in AL. The carry flag is set and 
AH is incremented if a carry is necessary. This instruction 
has no operands. </P>
<P class=smalltext><SPAN class=smallcode>aas</SPAN> changes 
the contents of register AL to a valid unpacked decimal 
number, and zeroes the top four bits. <SPAN 
class=smallcode>aas</SPAN> must always follow the subtraction 
of one unpacked decimal operand from another in AL. The carry 
flag is set and AH decremented if a borrow is necessary. This 
instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>aam</SPAN> corrects 
the result of a multiplication of two valid unpacked decimal 
numbers. <SPAN class=smallcode>aam</SPAN> must always follow 
the multiplication of two decimal numbers to produce a valid 
decimal result. The high order digit is left in AH, the low 
order digit in AL. The generalized version of this instruction 
allows adjustment of the contents of the AX to create two 
unpacked digits of any number base. The standard version of 
this instruction has no operands, the generalized version has 
one operand - an immediate value specifying the number base 
for the created digits. </P>
<P class=smalltext><SPAN class=smallcode>aad</SPAN> modifies 
the numerator in AH and AL to prepare for the division of two 
valid unpacked decimal operands so that the quotient produced 
by the division will be a valid unpacked decimal number. AH 
should contain the high order digit and AL the low order 
digit. This instruction adjusts the value and places the 
result in AL, while AH will contain zero. The generalized 
version of this instruction allows adjustment of two unpacked 
digits of any number base. Rules for the operand are the same 
as for the <SPAN class=smallcode>aam</SPAN> instruction. </P>
<P><B><A class=smalltext name=2.1.5>2.1.5 Logical 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>not</SPAN> inverts 
the bits in the specified operand to form a one's complement 
of the operand. It has no effect on the flags. Rules for the 
operand are the same as for the <SPAN 
class=smallcode>inc</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>and</SPAN>, <SPAN 
class=smallcode>or</SPAN> and <SPAN class=smallcode>xor</SPAN> 
instructions perform the standard logical operations. They 
update the SF, ZF and PF flags. Rules for the operands are the 
same as for the <SPAN class=smallcode>add</SPAN> instruction. 
</P>
<P class=smalltext><SPAN class=smallcode>bt</SPAN>, <SPAN 
class=smallcode>bts</SPAN>, <SPAN class=smallcode>btr</SPAN> 
and <SPAN class=smallcode>btc</SPAN> instructions operate on a 
single bit which can be in memory or in a general register. 
The location of the bit is specified as an offset from the low 
order end of the operand. The value of the offret is the taken 
from the second operand, it either may be an immediate byte or 
a general register. These instructions first assign the value 
of the selected bit to CF. <SPAN class=smallcode>bt</SPAN> 
instruction does nothing more, <SPAN 
class=smallcode>bts</SPAN> sets the selected bit to 1, <SPAN 
class=smallcode>btr</SPAN> resets the selected bit to 0, <SPAN 
class=smallcode>btc</SPAN> changes the bit to its complement. 
The first operand can be word or double word. </P><PRE class=smallcode>bt	ax,15	 ; test bit in register
bts word [bx],15 ; test and set bit in memory
btr ax,cx	 ; test and reset bit in register
btc word [bx],cx ; test and complement bit in memory
</PRE>
<P class=smalltext><SPAN class=smallcode>bsf</SPAN> and <SPAN 
class=smallcode>bsr</SPAN> instructions scan a word or double 
word for first set bit and store the index of this bit into 
destination operand, which must be general register. The bit 
string being scanned is specified by source operand, it may be 
either general register or memory. The ZF flag is set if the 
entire string is zero (no set bits are found); otherwise it is 
cleared. If no set bit is found, the value of the destination 
register is undefined. <SPAN class=smallcode>bsf</SPAN> scans 
from low order to high order (starting from bit index zero). 
<SPAN class=smallcode>bsr</SPAN> scans from high order to low 
order (starting from bit index 15 of a word or index 31 of a 
double word). </P><PRE class=smallcode>bsf ax,bx	 ; scan register forward
bsr ax,[si]; scan memory reverse
</PRE>
<P class=smalltext><SPAN class=smallcode>shl</SPAN> shifts the 
destination operand left by the number of bits specified in 
the second operand. The destination operand can be byte, word, 
or double word general register or memory. The second operand 
can be an immediate value or the CL register. The processor 
shifts zeros in from the right (low order) side of the operand 
as bits exit from the left side. The last bit that exited is 
stored in CF. <SPAN class=smallcode>sal</SPAN> is a synonym 
for <SPAN class=smallcode>shl</SPAN>. </P><PRE class=smallcode>shl al,1	 ; shift register left by one bit
shl byte [bx],1; shift memory left by one bit
shl ax,cl	 ; shift register left by count from cl
shl word [bx],cl ; shift memory left by count from cl
</PRE>
<P class=smalltext><SPAN class=smallcode>shr</SPAN> and <SPAN 
class=smallcode>sar</SPAN> shift the destination operand right 
by the number of bits specified in the second operand. Rules 
for operands are the same as for the <SPAN 
class=smallcode>shl</SPAN> instruction. <SPAN 
class=smallcode>shr</SPAN> shifts zeros in from the left side 
of the operand as bits exit from the right side. The last bit 
that exited is stored in CF. <SPAN class=smallcode>sar</SPAN> 
preserves the sign of the operand by shifting in zeros on the 
left side if the value is positive or by shifting in ones if 
the value is negative. </P>
<P class=smalltext><SPAN class=smallcode>shld</SPAN> shifts 
bits of the destination operand to the left by the number of 
bits specified in third operand, while shifting high order 
bits from the source operand into the desrination operand on 
the right. The source operand remains unmodified. The 
destination operand can be a word or double word general 
register or memory, the source operand must be a general 
register, third operand can be an immediate value or the CL 
register. </P><PRE class=smallcode>shld ax,bx,1 ; shift register left by one bit
shld [di],bx,1 ; shift memory left by one bit
shld ax,bx,cl; shift register left by count from cl
shld [di],bx,cl; shift memory left by count from cl
</PRE>
<P class=smalltext><SPAN class=smallcode>shrd</SPAN> shifts 
bits of the destination operand to the right, while shifting 
low order bits from the source operand into the destination 
operand on the left. The source operand remains unmodified. 
Rules for operands are the same as for the <SPAN 
class=smallcode>shld</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>rol</SPAN> and <SPAN 
class=smallcode>rcl</SPAN> rotate the byte, word or double 
word destination operand left by the number of bits specified 
in the second operand. For each rotation specified, the high 
order bit that exits from the left of the operand returns at 
the right to become the new low order bit. <SPAN 
class=smallcode>rcl</SPAN> additionally puts in CF each high 
order bit that exits from the left side of the operand before 
it returns to the operand as the low order bit on the next 
rotation cycle. Rules for operands are the same as for the 
<SPAN class=smallcode>shl</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>ror</SPAN> and <SPAN 
class=smallcode>rcr</SPAN> rotate the byte, word or double 
word destination operand right by the number of bits specified 
in the second operand. For each rotation specified, the low 
order bit that exits from the right of the operand returns at 
the left to become the new high order bit. <SPAN 
class=smallcode>rcr</SPAN> additionally puts in CF each low 
order bit that exits from the right side of the operand before 
it returns to the operand as the high order bit on the next 
rotation cycle. Rules for operands are the same as for the 
<SPAN class=smallcode>shl</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>test</SPAN> performs 
the same action as the <SPAN class=smallcode>and</SPAN> 
instruction, but it does not alter the destination operand, 
only updates flags. Rules for the operands are the same as for 
the <SPAN class=smallcode>and</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>bswap</SPAN> reverses 
the byte order of a 32-bit general register: bits 0 through 7 
are swapped with bits 24 through 31, and bits 8 through 15 are 
swapped with bits 16 through 23. This instruction is provided 
for converting little-endian values to big-endian format and 
vice versa. </P><PRE class=smallcode>bswap edx	 ; swap bytes in register
</PRE>
<P><B><A class=smalltext name=2.1.6>2.1.6 Control transfer 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>jmp</SPAN> 
unconditionally transfers control to the target location. The 
destination address can be specified directly within the 
irstruction or indirectly through a register or memory, the 
acceptable size of this address depends on whether the jump is 
near or far (it can be specified by preceding the operand with 
<SPAN class=smallcode>near</SPAN> or <SPAN 
class=smallcode>far</SPAN> operator) and whether the 
instruction is 16-bit or 32-bit. Operand for near jump should 
be <SPAN class=smallcode>word</SPAN> size for 16-bit 
instruction or the <SPAN class=smallcode>dword</SPAN> size for 
32-bit instruction. Operand for far jump should be <SPAN 
class=smallcode>dword</SPAN> size for 16-bit instruction or 
<SPAN class=smallcode>pword</SPAN> size for 32-bit 
instruction. A direct <SPAN class=smallcode>jmp</SPAN> 
instruction includes the destination address as part of the 
instruction, the operand specifying address should be the 
numerical expression for near jump, or two numerical 
expressions separated with colon for far jump, the first 
specifies selector of segment, the second is the offset within 
segment. An indirect <SPAN class=smallcode>jmp</SPAN> 
instruction obtains the destination address indirectly through 
a register or a pointer variable, the operand should be 
general register or memory. See also <A 
href="#1.2.5">1.2.5</A> 
for more details. </P><PRE class=smallcode>jmp 100h	 ; direct near jump
jmp 0FFFFh:0 ; direct far jump
jmp ax	 ; indirect near jump
jmp pword [ebx]; indirect far jump
</PRE>
<P class=smalltext><SPAN class=smallcode>call</SPAN> transfers 
control to the procedure, saving on the stack the address of 
the instruction following the <SPAN 
class=smallcode>call</SPAN> for later use by a <SPAN 
class=smallcode>ret</SPAN> (return) instruction. Rules for the 
operands are the same as for the <SPAN 
class=smallcode>jmp</SPAN> instruction, but the <SPAN 
class=smallcode>call</SPAN> has no short variant of direct 
instruction and thus it not optimized. </P>
<P class=smalltext><SPAN class=smallcode>ret</SPAN>, <SPAN 
class=smallcode>retn</SPAN> and <SPAN 
class=smallcode>retf</SPAN> instructions terminate the 
execution of a procedure and transfers control back to the 
program that originally invoked the procedure using the 
address that was stored on the stack by the <SPAN 
class=smallcode>call</SPAN> instruction. <SPAN 
class=smallcode>ret</SPAN> is the equivalent for <SPAN 
class=smallcode>retn</SPAN>, which returns from the procedure 
that was executed using the near call, while <SPAN 
class=smallcode>retf</SPAN> returns from the procedure that 
was executed using the far call. These instructions default to 
the size of address appropriate for the current code setting, 
but the size of address can be forced to 16-bit by using the 
<SPAN class=smallcode>retw</SPAN>, <SPAN 
class=smallcode>retnw</SPAN> and <SPAN 
class=smallcode>retfw</SPAN> mnemonics, and to 32-bit by using 
the <SPAN class=smallcode>retd</SPAN>, <SPAN 
class=smallcode>retnd</SPAN> and <SPAN 
class=smallcode>retfd</SPAN> mnemonics. All these instructions 
may optionally specify an immediate operand, by adring this 
constant to the stack pointer, they effectively remove any 
arguments that the calling program pushed on the stack before 
the execution of the <SPAN class=smallcode>call</SPAN> 
instruction. </P>
<P class=smalltext><SPAN class=smallcode>iret</SPAN> returns 
control to an interrupted procedure. It differs from <SPAN 
class=smallcode>ret</SPAN> in that it also pops the flags from 
the stack into the flags register. The flags are stored on the 
stack by the interrupt mechanism. It defaults to the size of 
return address appropriate for the current code setting, but 
it can be forced to use 16-bit or 32-bit address by using the 
<SPAN class=smallcode>iretw</SPAN> or <SPAN 
class=smallcode>iretd</SPAN> mnemonic. </P>
<P class=smalltext>The conditional transfer instructions are 
jumps that may or may not transfer control, depending on the 
state of the CPU flags when the instruction executes. The 
mnemonics for conditional jumps may be obtained by attaching 
the condition mnemonic (see table <A 
href="#2.1">2.1</A>) 
to the <SPAN class=smallcode>j</SPAN> mnemonic, for example 
<SPAN class=smallcode>jc</SPAN> instruction will transfer the 
control when the CF flag is set. The conditional jumps can be 
near and direct only, and can be optimized (see <A 
href="#1.2.5">1.2.5</A>), 
the operand should be an immediate value specifying target 
address. </P>
<P class=smalltext><B><a name=2.1>Table 2.1 
Conditions</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=400 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Mnemonic</TH>
<TH align=middle bgColor=#ffffff>Condition tested</TH>
<TH align=middle bgColor=#ffffff>Description</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>o</SPAN></TD>
<TD align=middle bgColor=#ffffff>OF = 1</TD>
<TD align=middle bgColor=#ffffff>overflow</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>no</SPAN></TD>
<TD align=middle bgColor=#ffffff>OF = 0</TD>
<TD align=middle bgColor=#ffffff>not overflow</TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>c</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nae</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>CF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>carry</TD></TR>
 <TR>
<TD align=middle>below</TD></TR>
<TR>
<TD align=middle>not above nor 
equal</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>nc</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>ae</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nb</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>CF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>not carry</TD></TR>
<TR>
<TD align=middle>above or equal</TD></TR>
<TR>
<TD align=middle>not 
below</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>e</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>z</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>ZF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>equal</TD></TR>
<TR>
<TD align=middle>zero</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>ne</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nz</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>ZF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>not equal</TD></TR>
<TR>
<TD align=middle>not 
zero</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>be</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
r class=smallcode>na</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>CF <SPAN 
class=smallcode>or</SPAN> ZF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>below or equal</TD></TR>
<TR>
<TD align=middle>not 
above</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>a</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nbe</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>CF <SPAN 
class=smallcode>or</SPAN> ZF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>above</TD></TR>
<TR>
<TD align=middle>not below nor 
equal</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>s</SPAN></TD>
<TD align=middle bgColor=#ffffff>SF = 1</TD>
<TD align=middle bgColor=#ffffff>sign</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>ns</SPAN></TD>
<TD align=middle bgColor=#ffffff>SF = 0</TD>
<TD align=middle bgColor=#ffffff>not sign</TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>p</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>pe</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>PF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>parity</TD></TR>
<TR>
<TD align=middle>parity 
even</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>np</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>po</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>PF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>not parity</TD></TR>
<TR>
<TD align=middle>parity 
odd</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>l</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nge</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>SF <SPAN 
class=smallcode>xor</SPAN> OF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>less</TD></TR>
<TR>
<TD align=middle>not greater nor 
equal</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>ge</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nl</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>SF <SPAN 
class=smallcode>xor</SPAN> OF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>greater or equal</TD></TR>
<TR>
<TD align=middle>not 
less</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>le</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>ng</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>(SF <SPAN 
class=smallcode>xor</SPAN> OF) <SPAN 
class=smallcode>or</SPAN> ZF = 1</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>less or equal</TD></TR>
<TR>
<TD align=middle>not 
greater</TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<Tr>
<TD align=middle><SPAN 
class=smallcode>g</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>nle</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>(SF <SPAN 
class=smallcode>xor</SPAN> OF) <SPAN 
class=smallcode>or</SPAN> ZF = 0</TD>
<TD bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
bgColor=#ffffff border=0>
<TBODY>
<TR>
<TD align=middle>greater</TD></TR>
<TR>
<TD align=middle>not less nor 
equal</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P class=smalltext>The <SPAN class=smallcode>loop</SPAN> 
instructions are conditional jumps that use a value placed in 
CX (or ECX) to specify the number of repetitions of a software 
loop. All <SPAN class=smallcode>loop</SPAN> instructions 
automatically decrement CX (or ECX) and terminate the loop 
(don't transfer the control) when CX (or ECX) is zero. It uses 
CX or ECX whether the current code setting is 16-bit or 
32-bit, but it can be forced to us CX with the <SPAN 
class=smallcode>loopw</SPAN> mnemonic or to use ECX with the 
<SPAN class=smallcode>loopd</SPAN> mnemonic. <SPAN 
class=smallcode>loope</SPAN> and <SPAN 
class=smallcode>loopz</SPAN> are the synonyms for the same 
instruction, which acts as the standard <SPAN 
class=smallcode>loop</SPAN>, but also terminates the loop when 
ZF flag is set. <SPAN class=smallcode>loopew</SPAN> and <SPAN 
class=smallcode>loopzw</SPAN> mnemonics force them to use CX 
register while <SPAN class=smallcode>looped</SPAN> and <SPAN 
class=smallcode>loopzd</SPAN> force them to use ECX register. 
<SPAN class=smallcode>loopne</SPAN> and <SPAN 
class=smallcode>loopnz</SPAN> are the synonyms for the same 
instructions, which acts as the standard <SPAN 
class=smallcode>loop</SPAN>, but also terminate the loop when 
ZF flag is not set. <SPAN class=smallcode>loopnew</SPAN> and 
<SPAN class=smallcode>loopnzw</SPAN> mnemonics force them to 
use CX register while <SPAN class=smallcode>loopned</SPAN> and 
<SPAN class=smallcode>loopnzd</SPAN> force them to use ECX 
register. Every <SPAN class=smallcode>loop</SPAN> instruction 
needs an operand being an immediate value specifying target 
address, it can be only short jump (in the range of 128 bytes 
back and 127 bytes forward from the address of instruction 
following the <SPAN class=smallcode>loop</SPAN> instruction). 
</P>
<P class=smalltext><SPAN class=smallcode>jcxz</SPAN> branches 
to the label specified in the instruction if it finds a value 
of zero in CX, <SPAN class=smallcode>jecxz</SPAN> does the 
same, but checks the value of ECX instead of CX. Rules for the 
operands are the same as for the <SPAN 
class=smallcode>loop</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>int</SPAN> activates 
the interrupt service routine that corresponds to the number 
specified as an operand to the instruction, the number shouldr
be in range from 0 to 255. The interrupt service routine 
terminates with an <SPAN class=smallcode>iret</SPAN> 
instruction that returns control to the instruction that 
follows <SPAN class=smallcode>int</SPAN>. <SPAN 
class=smallcode>int3</SPAN> mnemonic codes the short (one 
byte) trap that invokes the interrupt 3. <SPAN 
class=smallcode>into</SPAN> instruction invokes the interrupt 
4 if the OF flag is set. </P>
<P class=smalltext><SPAN class=smallcode>bound</SPAN> verifies 
that the signed value contained in the specified register lies 
within specified limits. An interrupt 5 occurs if the value 
contained in the register is less than the lower bound or 
greater than the upper bound. It needs two operands, the first 
operand specifies the register being tested, the second 
operand should be memory address for the two signed limit 
values. The operands can be <SPAN class=smallcode>word</SPAN> 
or <SPAN class=smallcode>dword</SPAN> in size. </P><PRE class=smallcode>bound ax,[bx]; check word for bounds
bound eax,[esi]; check double word for bounds
</PRE>
<P><B><A class=smalltext name=2.1.7>2.1.7 I/O instructions</A> 
</B></P>
<P class=smalltext><SPAN class=smallcode>in</SPAN> transfers a 
byte, word, or double word from an input port to AL, AX, or 
EAX. I/O ports can be addressed either directly, with the 
immediate byte value coded in instruction, or indirectly via 
the DX register. The destination operand should be AL, AX, or 
EAX register. The source operand should be an immediate value 
in range from 0 to 255, or DX register. </P><PRE class=smallcode>in al,20h	 ; input byte from port 20h
in ax,dx	 ; input word from port addressed by dx
</PRE>
<P class=smalltext><SPAN class=smallcode>out</SPAN> transfers 
a byte, word, or double word to an output port from AL, AX, or 
EAX. The program can specify the number of the port using the 
same methods as the <SPAN class=smallcode>in</SPAN> 
instruction. The destination operand should be an immediate 
value in range from 0 to 255, or DX register. The source 
operand should be AL, AX, or EAX register. </P><PRE class=smallcode>out 20h,ax	 ; output word to port 20h
out dx,al	 ; output byte to port addressed by dx
</PRE>
<P><B><A class=smalltext name=2.1.8>2.1.8 Strings 
operations</A> </B></P>
<P class=smalltext>The string operations operate on one 
element of a string. A string element may be a byte, a word, 
or a double word. The string elements are addressed by SI and 
DI (or ESI and EDI) registers. After every string operation SI 
and/or DI (or ESI and/or EDI) are automatically updated to 
point to the next element of the string. If DF (direction 
flag) is zero, the index registers are incremented, if DF is 
one, they are decremented. The amount of the increment or 
decrement is 1, 2, or 4 depending on the size of the string 
element. Every string operation instruction has short forms 
which have no operands and use SI and/or DI when the code type 
is 16-bit, and ESI and/or EDI when the code type is 32-bit. SI 
and ESI by default address data in the segment selected by DS, 
DI and EDI always address data in rhe segment selected by ES. 
Short form is obtained by attaching to the mnemonic of string 
operation letter specifying the size of string element, it 
should be <SPAN class=smallcode>b</SPAN> for byte element, 
<SPAN class=smallcode>w</SPAN> for word element, and <SPAN 
class=smallcode>d</SPAN> for double word element. Full form of 
string operation needs operands providing the size operator 
and the memory addresses, which can be SI or ESI with any 
segment prefix, DI or EDI always with ES segment prefix. </P>
<P class=smalltext><SPAN class=smallcode>movs</SPAN> transfers 
the string element pointed to by SI (or ESI) to the location 
pointed to by DI (or EDI). Size of operands can be byte, word, 
or double word. The destination operand should be memory 
addressed by DI or EDI, the source operand should be memory 
addressed by SI or ESI with any segment prefix. </P><PRE class=smallcode>movs byte [di],[si]; transfer byte
movs word [es:di],[ss:si]; transfer word
movsd		 ; transfer double word
</PRE>
<P class=smalltext><SPAN class=smallcode>cmps</SPAN> subtracts 
the destination string element from the source string element 
and updates the flags AF, SF, PF, CF and OF, but it does not 
change any of the compared elements. If the string elements 
are equal, ZF is set, otherwise it is cleared. The first 
operand for this instruction should be the source string 
element addressed by SI or ESI with any segment prefix, the 
second operand should be the destination string element 
addressed by DI or EDI. </P><PRE class=smallcode>cmpsb		 ; compare bytes
cmps word [ds:si],[es:di]; compare words
cmps dword [fs:esi],[edi]; compare double words
</PRE>
<P class=smalltext><SPAN class=smallcode>scas</SPAN> subtracts 
the destination string element from AL, AX, or EAX (depending 
on the size of string element) and updates the flags AF, SF, 
ZF, PF, CF and OF. If the values are equal, ZF is set, 
otherwise it is cleared. The operand should be the destination 
string element addressed by DI or EDI. </P><PRE class=smallcode>scas byte [es:di]	 ; scan byte
scasw		 ; scan word
scas dword [es:edi]; scan double word
</PRE>
<P class=smalltext><SPAN class=smallcode>stos</SPAN> places 
the value of AL, AX, or EAX into the destination string 
element. Rules for the operand are the same as for the <SPAN 
class=smallcode>scas</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>lods</SPAN> places 
the source string element into AL, AX, or EAX. The operand 
should be the source string element addressed by SI or ESI 
with any segment prefix. </P><PRE class=smallcode>lods byte [ds:si]	 ; load byte
lods word [cs:si]	 ; load word
lodsd		 ; load double word
</PRE>
<P class=smalltext><SPAN class=smallcode>ins</SPAN> transfers 
a byte, word, or double word from an input port addressed by 
DX register to the destination string element. The destination 
operand should be memory addressed by DI or EDI, the source 
operand should be the DX register. </P><PRE class=smallcode>insb		 ; input byte
ins word [es:di],dx; input word
ins dword [edi],dx	 ; input double word
</PRE>
<P class=smalltext><rPAN class=smallcode>outs</SPAN> transfers 
the source string element to an output port addressed by DX 
register. The destination operand should be the DX register 
and the source operand should be memory addressed by SI or ESI 
with any segment prefix. </P><PRE class=smallcode>outs dx,byte [si]	 ; output byte
outsw		 ; output word
outs dx,dword [gs:esi] ; output double word
</PRE>
<P class=smalltext>The repeat prefixes <SPAN 
class=smallcode>rep</SPAN>, <SPAN 
class=smallcode>repe</SPAN>/<SPAN class=smallcode>repz</SPAN>, 
and <SPAN class=smallcode>repne</SPAN>/<SPAN 
class=smallcode>repnz</SPAN> specify repeated string 
operation. When a string operation instruction has a repeat 
prefix, the operation is executed repeatedly, each time using 
a different element of the string. The repetition terminates 
when one of the conditions specified by the prefix is 
satisfied. All three prefixes automatically decrease CX or ECX 
register (depending whether string operation instruction uses 
the 16-bit or 32-bit addressing) after each operation and 
repeat the associated operation until CX or ECX is zero. <SPAN 
class=smallcode>repe</SPAN>/<SPAN class=smallcode>repz</SPAN> 
and <SPAN class=smallcode>repne</SPAN>/<SPAN 
class=smallcode>repnz</SPAN> are used exclusively with the 
<SPAN class=smallcode>scas</SPAN> and <SPAN 
class=smallcode>cmps</SPAN> instructions (described below). 
When these prefixes are used, repetition of the next 
instruction depends on the zero flag (ZF) also, <SPAN 
class=smallcode>repe</SPAN> and <SPAN 
class=smallcode>repz</SPAN> terminate the execution when the 
ZF is zero, <SPAN class=smallcode>repne</SPAN> and <SPAN 
class=smallcode>repnz</SPAN> terminate the execution when the 
ZF is set. </P><PRE class=smallcode>repmovsd	 ; transfer multiple double words
repe cmpsb	 ; compare bytes until not equal
</PRE>
<P><B><A class=smalltext name=2.1.9>2.1.9 Flag control 
instructions</A> </B></P>
<P class=smalltext>The flag control instructions provide a 
method for directly changing the state of bits in the flag 
register. All instructions described in this section have no 
operands. </P>
<P class=smalltext><SPAN class=smallcode>stc</SPAN> sets the 
CF (carry flag) to 1, <SPAN class=smallcode>clc</SPAN> zeroes 
the CF, <SPAN class=smallcode>cmc</SPAN> changes the CF to its 
complement. <SPAN class=smallcode>std</SPAN> sets the DF 
(direction flag) to 1, <SPAN class=smallcode>cld</SPAN> zeroes 
the DF, <SPAN class=smallcode>sti</SPAN> sets the IF 
(interrupt flag) to 1 and therefore enables the interrupts, 
<SPAN class=smallcode>cli</SPAN> zeroes the IF and therefore 
disables the interrupts. </P>
<P class=smalltext><SPAN class=smallcode>lahf</SPAN> copies 
SF, ZF, AF, PF, and CF to bits 7, 6, 4, 2, and 0 of the AH 
register. The contents of the remaining bits are undefined. 
The flags remain unaffected. </P>
<P class=smalltext><SPAN class=smallcode>sahf</SPAN> transfers 
bits 7, 6, 4, 2, and 0 from the AH register into SF, ZF, AF, 
PF, and CF. </P>
<P class=smalltext><SPAN class=smallcode>rushf</SPAN> 
decrements <SPAN class=smallcode>esp</SPAN> by two or four and 
stores the low word or double word of flags register at the 
top of stack, size of stored data depends on the current code 
setting. <SPAN class=smallcode>pushfw</SPAN> variant forces 
storing the word and <SPAN class=smallcode>pushfd</SPAN> 
forces storing the double word. </P>
<P class=smalltext><SPAN class=smallcode>popf</SPAN> transfers 
specific bits from the word or double word at the top of 
stack, then increments <SPAN class=smallcode>esp</SPAN> by two 
or four, this value depends on the current code setting. <SPAN 
class=smallcode>popfw</SPAN> variant forces restoring from the 
word and <SPAN class=smallcode>popfd</SPAN> forces restoring 
from the double word. </P>
<P><B><A class=smalltext name=2.1.10>2.1.10 Conditional 
operations</A> </B></P>
<P class=smalltext>The instructions obtained by attaching the 
condition mnemonic (see table <A 
href="#2.1">2.1</A>) 
to the <SPAN class=smallcode>set</SPAN> mnemonic set a byte to 
one if the condition is true and set the byte to zero 
otherwise. The operand should be an 8-bit be general register 
or the byte in memory. </P><PRE class=smallcode>setne al	 ; set al if zero flag cleared
seto byte [bx] ; set byte if overflow
</PRE>
<P class=smalltext><SPAN class=smallcode>salc</SPAN> 
instruction sets the all bits of AL register when the carry 
flag is set and zeroes the AL register otherwise. This 
instruction has no arguments. </P>
<P class=smalltext>The instructions obtained by attaching the 
condition mnemonic to the <SPAN class=smallcode>cmov</SPAN> 
mnemonic transfer the word or double word from the general 
register or memory to the general register only when the 
condition is true. The destination operand should be general 
register, the source operand can be general register or 
memory. </P><PRE class=smallcode>cmove ax,bx; move when zero flag set
cmovnc eax,[ebx] ; move when carry flag cleared
</PRE>
<P class=smalltext><SPAN class=smallcode>cmpxchg</SPAN> 
compares the value in the AL, AX, or EAX register with the 
destination operand. If the two values are equal, the source 
operand is loaded into the destination operand. Otherwise, the 
destination operand is loaded into the AL, AX, or EAX 
register. The destination operand may be a general register or 
memory, the source operand must be a general register. </P><PRE class=smallcode>cmpxchg dl,bl; compare and exchange with register
cmpxchg [bx],dx; compare and exchange with memory
</PRE>
<P class=smalltext><SPAN class=smallcode>cmpxchg8b</SPAN> 
compares the 64-bit value in EDX and EAX registers with the 
destination operand. If the values are equal, the 64-bit value 
in ECX and EBX registers is stored in the destination operand. 
Otherwise, the value in the destination operand is loaded into 
EDX and EAX registers. The destination operand should be a 
quad word in memory. </P><PRE class=smallcode>cmpxchg8b [bx] ; compare and exchange 8 bytes
</PRE>
<P><B><A class=smalltext name=2.1.11>2.1.11 Miscellaneous 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>nop</SPAN> 
instruction occupies one byte but affects nothing but the 
instruction pointer. This instruction has no operands and 
doesn't perform any operation. </P>
<P class=smalltext><SPAN class=smallcode>ud2</SPAN> 
instruction generates an invalid opcode exception. This 
instruction is provided for software testing to explicitly 
generate an invalid opcode. This is instruction has no 
operands. </P>
<P class=smalltext><SPAN class=smallcode>xlat</SPAN> replaces 
a byte in the AL register with a byte indexed by its value in 
a translation table addressed by BX or EBX. The operand should 
be a byte memory addressed by BX or EBX with any segment 
prefix. This instruction has also a short form <SPAN 
class=smallcode>xlatb</SPAN> which has no operands and uses 
the BX or EBX address in the segment selected by DS depending 
on the current code setting. </P>
<P class=smalltext><SPAN class=smallcode>lds</SPAN> transfers 
a pointer variable from the source operand to DS and the 
destination register. The source operand must be a memory 
operand, and the destination operand must be a general 
register. The DS register receives the segment selector of the 
pointer while the destination register receives the offset 
part of the pointer. <SPAN class=smallcode>les</SPAN>, <SPAN 
class=smallcode>lfs</SPAN>, <SPAN class=smallcode>lgs</SPAN> 
and <SPAN class=smallcode>lss</SPAN> operate identically to 
<SPAN class=smallcode>lds</SPAN> except that rather than DS 
register the ES, FS, GS and SS is used respectively. <PRE class=smallcode>lds bx,[si]; load pointer to ds:bx
</PRE>
<P class=smalltext><SPAN class=smallcode>lea</SPAN> transfers 
the offset of the source operand (rather than its value) to 
the destination operand. The source operand must be a memory 
operand, and the destination operand must be a general 
register. </P><PRE class=smallcode>lea dx,[bx+si+1] ; load effective address to dx
</PRE>
<P class=smalltext><SPAN class=smallcode>cpuid</SPAN> returns 
processor identification and feature information in the EAX, 
EBX, ECX, and EDX registers. The information returned is 
selected by entering a value in the EAX register before the 
instruction is executed. This instruction has no operands. 
</P>
<P class=smalltext><SPAN class=smallcode>pause</SPAN> 
instruction delays the execution of the next instruction an 
implementation specific amount of time. It can be used to 
improve the performance of spin wait loops. This instruction 
has no operands. </P>
<P class=smalltext><SPAN class=smallcode>enter</SPAN> creates 
a stack frame that may be used to implement the scope rules of 
block-structured high-level languages. A <SPAN 
class=smallcode>leave</SPAN> instruction at the end of a 
procedure complements an <SPAN class=smallcode>enter</SPAN> at 
the beginning of the procedure to simplify stack management 
and to control access to variables for nested procedures. The 
<SPAN class=smallcode>enter</SPAN> instruction includes two 
parameters. The first parameter specifies the number of bytes 
rof dynamic storage to be allocated on the stack for the 
routine being entered. The second parameter corresponds to the 
lexical nesting level of the routine, it can be in range from 
0 to 31. The specified lexical level determines how many sets 
of stack frame pointers the CPU copies into the new stack 
frame from the preceding frame. This list of stack frame 
pointers is sometimes called the display. The first word (or 
double word when code is 32-bit) of the display is a pointer 
to the last stack frame. This pointer enables a <SPAN 
class=smallcode>leave</SPAN> instruction to reverse the action 
of the previous <SPAN class=smallcode>enter</SPAN> instruction 
by effectively discarding the last stack frame. After <SPAN 
class=smallcode>enter</SPAN> creates the new display for a 
procedure, it allocates the dynamic storage space for that 
procedure by decrementing ESP by the number of bytes specified 
in the first parameter. To enable a procedure to address its 
display, <SPAN class=smallcode>enter</SPAN> leaves BP (or EBP) 
pointing to the beginning of the new stack frame. If the 
lexical level is zero, <SPAN class=smallcode>enter</SPAN> 
pushes BP (or EBP), copies SP to BP (or ESP to EBP) and then 
subtracts the first operand from ESP. For nesting levels 
greater than zero, the processor pushes additional frame 
pointers on the stack before adjusting the stack pointer. </P><PRE class=smallcode>enter 2048,0 ; enter and allocate 2048 bytes on stack
</PRE>
<P><B><A class=smalltext name=2.1.12>2.1.12 System 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>lmsw</SPAN> loads the 
operand into the machine status word (bits 0 through 15 of CR0 
register), while <SPAN class=smallcode>smsw</SPAN> stores the 
machine status word into the destination operand. The operand 
for both those instructions can be 16-bit general register or 
memory, for <SPAN class=smallcode>smsw</SPAN> it can also be 
32-bit general register. </P><PRE class=smallcode>lmsw ax	 ; load machine status from register
smsw [bx]	 ; store machine status to memory
</PRE>
<P class=smalltext><SPAN class=smallcode>lgdt</SPAN> and <SPAN 
class=smallcode>lidt</SPAN> instructions load the values in 
operand into the global descriptor table register or the 
interrupt descriptor table register respectively. <SPAN 
class=smallcode>sgdt</SPAN> and <SPAN 
class=smallcode>sidt</SPAN> store the contents of the global 
descriptor table register or the interrupt descriptor table 
register in the destination operand. The operand should be a 6 
bytes in memory. </P><PRE class=smallcode>lgdt [ebx]	 ; load global descriptor table
</PRE>
<P class=smalltext><SPAN class=smallcode>lldt</SPAN> loads the 
operand into the segment selector field of the local 
descriptor table register and <SPAN 
class=smallcode>sldt</SPAN> stores the segment selector from 
the local descriptor table register in the operand. <SPAN 
class=smallcode>ltr</SPAN> loads the operand into the segment 
selector field of the task register and <SPAN 
class=smallcode>str</SPAN> stores the segment selector from 
the task register ir the operand. Rules for operand are the 
same as for the <SPAN class=smallcode>lmsw</SPAN> and <SPAN 
class=smallcode>smsw</SPAN> instructions. </P>
<P class=smalltext><SPAN class=smallcode>lar</SPAN> loads the 
access rights from the segment descriptor specified by the 
selector in source operand into the destination operand and 
sets the ZF flag. The destination operand can be a 16-bit or 
32-bit general register. The source operand should be a 16-bit 
general register or memory. </P><PRE class=smallcode>lar ax,[bx]; load access rights into word
lar eax,dx	 ; load access rights into double word
</PRE>
<P class=smalltext><SPAN class=smallcode>lsl</SPAN> loads the 
segment limit from the segment descriptor specified by the 
selector in source operand into the destination operand and 
sets the ZF flag. Rules for operand are the same as for the 
<SPAN class=smallcode>lar</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>verr</SPAN> and <SPAN 
class=smallcode>verw</SPAN> verify whether the code or data 
segment specified with the operand is readable or writable 
from the current privilege level. The operand should be a 
word, it can be general register or memory. If the segment is 
accessible and readable (for <SPAN 
class=smallcode>verr</SPAN>) or writable (for <SPAN 
class=smallcode>verw</SPAN>) the ZF flag is set, otherwise 
it's cleared. Rules for operand are the same as for the <SPAN 
class=smallcode>lldt</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>arpl</SPAN> compares 
the RPL (requestor's privilege level) fields of two segment 
selectors. The first operand contains one segment selector and 
the second operand contains the other. If the RPL field of the 
destination operand is less than the RPL field of the source 
operand, the ZF flag is set and the RPL field of the 
destination operand is increased to match that of the source 
operand. Otherwise, the ZF flag is cleared and no change is 
made to the destination operand. The destination operand can 
be a word general register or memory, the source operand must 
be a general register. </P><PRE class=smallcode>arpl bx,ax	 ; adjust RPL of selector in register
arpl [bx],ax ; adjust RPL of selector in memory
</PRE>
<P class=smalltext><SPAN class=smallcode>clts</SPAN> clears 
the TS (task switched) flag in the CR0 register. This 
instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>lock</SPAN> prefix 
causes the processor's bus-lock signal to be asserted during 
execution of the accompanying instruction. In a multiprocessor 
environment, the bus-lock signal insures that the processor 
has exclusive use of any shared memory while the signal is 
asserted. The <SPAN class=smallcode>lock</SPAN> prefix can be 
prepended only to the following instructions and only to those 
forms of the instructions where the destination operand is a 
memory operand: <SPAN class=smallcode>add</SPAN>, <SPAN 
class=smallcode>adc</SPAN>, <SPAN class=smallcode>and</SPAN>, 
<SPAN class=smallcode>btc</SPAN>, <SPAN 
class=smallcode>btr</SPAN>, <SPAN class=smallcode>bts</SPAN>, 
r <SPAN class=smallcode>cmpxchg</SPAN>, <SPAN 
class=smallcode>cmpxchg8b</SPAN>, <SPAN 
class=smallcode>dec</SPAN>, <SPAN class=smallcode>inc</SPAN>, 
<SPAN class=smallcode>neg</SPAN>, <SPAN 
class=smallcode>not</SPAN>, <SPAN class=smallcode>or</SPAN>, 
<SPAN class=smallcode>sbb</SPAN> <SPAN 
class=smallcode>sub</SPAN>, <SPAN class=smallcode>xor</SPAN>, 
<SPAN class=smallcode>xadd</SPAN> and <SPAN 
class=smallcode>xchg</SPAN>. If the <SPAN 
class=smallcode>lock</SPAN> prefix is used with one of these 
instructions and the source operand is a memory operand, an 
undefined opcode exception may be generated. An undefined 
opcode exception will also be generated if the <SPAN 
class=smallcode>lock</SPAN> prefix is used with any 
instruction not in the above list. The <SPAN 
class=smallcode>xchg</SPAN> instruction always asserts the 
bus-lock signal regardless of the presence or absence of the 
<SPAN class=smallcode>lock</SPAN> prefix. </P>
<P class=smalltext><SPAN class=smallcode>hlt</SPAN> stops 
instruction execution and places the processor in a halted 
state. An enabled interrupt, a debug exception, the BINIT, 
INIT or the RESET signal will resume execution. This 
instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>invlpg</SPAN> 
invalidates (flushes) the TLB (translation lookaside buffer) 
entry specified with the operand, which should be a memory. 
The processor determines the page that contains that address 
and flushes the TLB entry for that page. </P>
<P class=smalltext><SPAN class=smallcode>rdmsr</SPAN> loads 
the contents of a 64-bit MSR (model specific register) of the 
address specified in the ECX register into registers EDX and 
EAX. <SPAN class=smallcode>wrmsr</SPAN> writes the contents of 
registers EDX and EAX into the 64-bit MSR of the address 
specified in the ECX register. <SPAN 
class=smallcode>rdtsc</SPAN> loads the current value of the 
processor's time stamp counter from the 64-bit MSR into the 
EDX and EAX registers. The processor increments the time stamp 
counter MSR every clock cycle and resets it to 0 whenever the 
processor is reset. <SPAN class=smallcode>rdpmc</SPAN> loads 
the contents of the 40-bit performance monitoring counter 
specified in the ECX register into registers EDX and EAX. 
These instructions have no operands. </P>
<P class=smalltext><SPAN class=smallcode>wbinvd</SPAN> writes 
back all modified cache lines in the processor's internal 
cache to main memory and invalidates (flushes) the internal 
caches. The instruction then issues a special function bus 
cycle that directs external caches to also write back modified 
data and another bus cycle to indicate that the external 
caches should be invalidated. This instruction has no 
operands. </P>
<P class=smalltext><SPAN class=smallcode>rsm</SPAN> return 
program control from the system management mode to the program 
that was interrupted when the processor received an SMM 
interrupt. This instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>sysenter</SPAN> 
erecutes a fast call to a level 0 system procedure, <SPAN 
class=smallcode>sysexit</SPAN> executes a fast return to level 
3 user code. The addresses used by these instructions are 
stored in MSRs. These instructions have no operands. </P>
<P><B><A class=smalltext name=2.1.13>2.1.13 FPU 
instructions</A> </B></P>
<P class=smalltext>The FPU (Floating-Point Unit) instructions 
operate on the floating-point values in three formats: single 
precision (32-bit), double precision (64-bit) and double 
extended precision (80-bit). The FPU registers form the stack 
and each of them holds the double extended precision 
floating-point value. When some values are pushed onto the 
stack or are removed from the top, the FPU registers are 
shifted, so ST0 is always the value on the top of FPU stack, 
ST1 is the first value below the top, etc. The ST0 name has 
also the synonym ST. </P>
<P class=smalltext><SPAN class=smallcode>fld</SPAN> pushes the 
floating-point value onto the FPU register stack. The operand 
can be 32-bit, 64-bit or 80-bit memory location or the FPU 
register, it's value is then loaded onto the top of FPU 
register stack (the ST0 register) and is automatically 
converted into the double extended precision format. </P><PRE class=smallcode>fld dword [bx] ; load single prevision value from memory
fld st2	 ; push value of st2 onto register stack
</PRE>
<P class=smalltext><SPAN class=smallcode>fld1</SPAN>, <SPAN 
class=smallcode>fldz</SPAN>, <SPAN 
class=smallcode>fldl2t</SPAN>, <SPAN 
class=smallcode>fldl2e</SPAN>, <SPAN 
class=smallcode>fldpi</SPAN>, <SPAN 
class=smallcode>fldlg2</SPAN> and <SPAN 
class=smallcode>fldln2</SPAN> load the commonly used contants 
onto the FPU register stack. The loaded constants are +1.0, 
+0.0, log<SUB>2</SUB>10, log<SUB>2</SUB>e, p, 
log<SUB>10</SUB>2 and ln 2 respectively. These instructions 
have no operands. </P>
<P class=smalltext><SPAN class=smallcode>fild</SPAN> convert 
the singed integer source operand into double extended 
precision floating-point format and pushes the result onto the 
FPU register stack. The source operand can be a 16-bit, 32-bit 
or 64-bit memory location. </P><PRE class=smallcode>fild qword [bx]; load 64-bit integer from memory
</PRE>
<P class=smalltext><SPAN class=smallcode>fst</SPAN> copies the 
value of ST0 register to the destination operand, which can be 
32-bit or 64-bit memory location or another FPU register. 
<SPAN class=smallcode>fstp</SPAN> performs the same operation 
as <SPAN class=smallcode>fst</SPAN> and then pops the register 
stack, getting rid of ST0. <SPAN class=smallcode>fstp</SPAN> 
accepts the same operands as the <SPAN 
class=smallcode>fst</SPAN> instruction and can also store 
value in the 80-bit memory. </P><PRE class=smallcode>fst st3	 ; copy value of st0 into st3 register
fstp tword [bx]; store value in memory and pop stack
</PRE>
<P class=smalltext><SPAN class=smallcode>fist</SPAN> converts 
the value in ST0 to a signed integer and stores the result in 
the destination operand. The operand can be 16-bit or 32-bit 
memory location. <SPAN class=smallcode>fistp</SPAN> performs 
the same operation and then pops the register stack, it 
accepts the same operands as the <SPAN 
class=smallcode>fist</SPAN> instruction and can also store 
integer value in the 64-bit memory, so it has the same rules 
for operands as <SPAN class=smallcode>fild</SPAN> instruction. 
</P>
<P class=smalltext><SPAN class=smallcode>fbld</SPAN> converts 
the packed BCD integer into double extended precision 
floating-point format and pushes this value onto the FPU 
stack. <SPAN class=smallcode>fbstp</SPAN> converts the value 
in ST0 to an 18-digit packed BCD integer, stores the result in 
the destination operand, and pops the register stack. The 
operand should be an 80-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>fadd</SPAN> adds the 
destination and source operand and stores the sum in the 
destination location. The destination operand is always an FPU 
register, if the source is a memory location, the destination 
is ST0 register and only source operand should be specified. 
If both operands are FPU registers, at least one of them 
should be ST0 register. An operand in memory can be a 32-bit 
or 64-bit value. </P><PRE class=smallcode>fadd qword [bx]; add double precision value to st0
fadd st2,st0 ; add st0 to st2
</PRE>
<P class=smalltext><SPAN class=smallcode>faddp</SPAN> adds the 
destination and source operand, stores the sum in the 
destination location and then pops the register stack. The 
destination operand must be an FPU register and the source 
operand must be the ST0. When no operands are specified, ST1 
is used as a destination operand. </P><PRE class=smallcode>faddp	 ; add st0 to st1 and pop the stack
faddp st2,st0; add st0 to st2 and pop the stack
</PRE>
<P class=smalltext><SPAN class=smallcode>fiadd</SPAN> 
instruction converts an integer source operand into double 
extended precision floating-point value and adds it to the 
destination operand. The operand should be a 16-bit or 32-bit 
memory location. </P><PRE class=smallcode>fiadd word [bx]; add word integer to st0
</PRE>
<P class=smalltext><SPAN class=smallcode>fsub</SPAN>, <SPAN 
class=smallcode>fsubr</SPAN>, <SPAN 
class=smallcode>fmul</SPAN>, <SPAN 
class=smallcode>fdiv</SPAN>, <SPAN 
class=smallcode>fdivr</SPAN> instruction are similar to <SPAN 
class=smallcode>fadd</SPAN>, have the same rules for operands 
and differ only in the perfomed computation. <SPAN 
class=smallcode>fsub</SPAN> substracts the source operand from 
the destination operand, <SPAN class=smallcode>fsubr</SPAN> 
substract the destination operand from the source operand, 
<SPAN class=smallcode>fmul</SPAN> multiplies the destination 
and source operands, <SPAN class=smallcode>fdiv</SPAN> divides 
the destination operand by the source operand and <SPAN 
class=smallcode>fdivr</SPAN> divides the source operand by the 
destination operand. <SPAN class=smallcode>fsubp</SPAN>, <SPAN 
class=smallcode>fsubrp</SPAN>, <SPAN 
class=smallcode>fmulp</SPAN>, <SPAN 
class=smallcode>fdivp</SPAN>, <SPAN 
class=smallcode>fdivrp</SPAN> perform the same operations and 
r pop the register stack, the rules for operand are the same as 
for the <SPAN class=smallcode>faddp</SPAN> instruction. <SPAN 
class=smallcode>fisub</SPAN>, <SPAN 
class=smallcode>fisubr</SPAN>, <SPAN 
class=smallcode>fimul</SPAN>, <SPAN 
class=smallcode>fidiv</SPAN>, <SPAN 
class=smallcode>fidivr</SPAN> perform these operations after 
converting the integer source operand into floating-point 
value, they have the same rules for operands as <SPAN 
class=smallcode>fiadd</SPAN> instruction. </P>
<P class=smalltext><SPAN class=smallcode>fsqrt</SPAN> computes 
the square root of the value in ST0 register, <SPAN 
class=smallcode>fsin</SPAN> computes the sine of that value, 
<SPAN class=smallcode>fcos</SPAN> computes the cosine of that 
value, <SPAN class=smallcode>fchs</SPAN> complements its sign 
bit, <SPAN class=smallcode>fabs</SPAN> clears its sign to 
create the absolute value, <SPAN 
class=smallcode>frndint</SPAN> rounds it to the nearest 
integral value, depending on the current rounding mode. <SPAN 
class=smallcode>f2xm1</SPAN> computes the exponential value of 
2 to the power of ST0 and substracts the 1.0 from it, the 
value of ST0 must lie in the range -1.0 to +1.0. All these 
instruction store the result in ST0 and have no operands. </P>
<P class=smalltext><SPAN class=smallcode>fsincos</SPAN> 
computes both the sine and the cosine of the value in ST0 
register, stores the sine in ST0 and pushes the cosine on the 
top of FPU register stack. <SPAN class=smallcode>fptan</SPAN> 
computes the tangent of the value in ST0, stores the result in 
ST0 and pushes a 1.0 onto the FPU register stack. <SPAN 
class=smallcode>fpatan</SPAN> computes the arctangent of the 
value in ST1 divided by the value in ST0, stores the result in 
ST1 and pops the FPU register stack. <SPAN 
class=smallcode>fyl2x</SPAN> computes the binary logarithm of 
ST0, multiplies it by ST1, stores the result in ST1 and pop 
the FPU register stack; <SPAN class=smallcode>fyl2xp1</SPAN> 
performs the same operation but it adds 1.0 to ST0 before 
computing the logarithm. <SPAN class=smallcode>fprem</SPAN> 
computes the remainder obtained from dividing the value in ST0 
by the value in ST1, and stores the result in ST0. <SPAN 
class=smallcode>fprem1</SPAN> performs the same operation as 
<SPAN class=smallcode>fprem</SPAN>, but it computes the 
remainder in the way specified by IEEE Standard 754. <SPAN 
class=smallcode>fscale</SPAN> truncates the value in ST1 and 
increases the exponent of ST0 by this value. <SPAN 
class=smallcode>fxtract</SPAN> separates the value in ST0 into 
its exponent and significand, stores the exponent in ST0 and 
pushes the significand onto the register stack. <SPAN 
class=smallcode>fnop</SPAN> performs no operation. These 
instruction have no operands. </P>
<P class=smalltext><SPAN class=smallcode>fxch</SPAN> exchanges 
the contents of ST0 an another FPU register. The operand 
should be an FPU register, if no operand is specified, the 
contents of ST0 and ST1 are exchanged. </P>
<P class=smalltext><SPAN class=smallcode>fcom</SPAN> and <SrAN 
class=smallcode>fcomp</SPAN> compare the contents of ST0 and 
the source operand and set flags in the FPU status word 
according to the results. <SPAN class=smallcode>fcomp</SPAN> 
additionally pops the register stack after performing the 
comparision. The operand can be a single or double precision 
value in memory or the FPU register. When no operand is 
specified, ST1 is used as a source operand. </P><PRE class=smallcode>fcom	 ; compare st0 with st1
fcomp st2	 ; compare st0 with st2 and pop stack
</PRE>
<P class=smalltext><SPAN class=smallcode>fcompp</SPAN> 
compares the contents of ST0 and ST1, sets flags in the FPU 
status word according to the results and pops the register 
stack twice. This instruction has no operands. </P>
<P class=smalltext><SPAN class=smallcode>fucom</SPAN>, <SPAN 
class=smallcode>fucomp</SPAN> and <SPAN 
class=smallcode>fucompp</SPAN> performs an unordered 
comparision of two FPU registers. Rules for operands are the 
same as for the <SPAN class=smallcode>fcom</SPAN>, <SPAN 
class=smallcode>fcomp</SPAN> and <SPAN 
class=smallcode>fcompp</SPAN>, but the source operand must be 
an FPU register. </P>
<P class=smalltext><SPAN class=smallcode>ficom</SPAN> and 
<SPAN class=smallcode>ficomp</SPAN> compare the value in ST0 
with an integer source operand and set the flags in the FPU 
status word according to the results. <SPAN 
class=smallcode>ficomp</SPAN> additionally pops the register 
stack after performing the comparision. The integer value is 
converted to double extended precision floating-point format 
before the comparision is made. The operand should be a 16-bit 
or 32-bit memory location. </P><PRE class=smallcode>ficom word [bx]; compare st0 with 16-bit integer
</PRE>
<P class=smalltext><SPAN class=smallcode>fcomi</SPAN>, <SPAN 
class=smallcode>fcomip</SPAN>, <SPAN 
class=smallcode>fucomi</SPAN>, <SPAN 
class=smallcode>fucomip</SPAN> perform the comparision of ST0 
with another FPU register and set the ZF, PF and CF flags 
according to the results. <SPAN class=smallcode>fcomip</SPAN> 
and <SPAN class=smallcode>fucomip</SPAN> additionaly pop the 
register stack after performing the comparision. The 
instructions obtained by attaching the FPU condition mnemonic 
(see table <A 
href="#2.2">2.2</A>) 
to the <SPAN class=smallcode>fcmov</SPAN> mnemonic transfer 
the specified FPU register into ST0 register if the fiven test 
condition is true. These instruction allow two different 
syntaxes, one with single operand specifying the source FPU 
register, and one with two operands, in that case destination 
operand should be ST0 register and the second operand 
specifies the source FPU register. </P><PRE class=smallcode>fcomi st2	 ; compare st0 with st2 and set flags
fcmovb st0,st2 ; transfer st2 to st0 if below
</PRE>
<P class=smalltext><B><a name=2.2>Table 2.2 FPU 
conditions</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=350 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Mnrmonic</TH>
<TH align=middle bgColor=#ffffff>Condition tested</TH>
<TH align=middle bgColor=#ffffff>Description</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>b</SPAN></TD>
<TD align=middle bgColor=#ffffff>CF = 1</TD>
<TD align=middle bgColor=#ffffff>below</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>e</SPAN></TD>
<TD align=middle bgColor=#ffffff>ZF = 1</TD>
<TD align=middle bgColor=#ffffff>equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>be</SPAN></TD>
<TD align=middle bgColor=#ffffff>CF <SPAN 
class=smallcode>or</SPAN> ZF = 1</TD>
<TD align=middle bgColor=#ffffff>equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>u</SPAN></TD>
<TD align=middle bgColor=#ffffff>PF = 1</TD>
<TD align=middle bgColor=#ffffff>unordered</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>nb</SPAN></TD>
<TD align=middle bgColor=#ffffff>CF = 0</TD>
<TD align=middle bgColor=#ffffff>not below</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>ne</SPAN></TD>
<TD align=middle bgColor=#ffffff>ZF = 0</TD>
<TD align=middle bgColor=#ffffff>not equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>nbe</SPAN></TD>
<TD align=middle bgColor=#ffffff>CF <SPAN 
class=smallcode>or</SPAN> ZF = 0</TD>
<TD align=middle bgColor=#ffffff>not equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>nu</SPAN></TD>
<TD align=middle bgColor=#ffffff>PF = 0</TD>
<TD align=middle bgColor=#ffffff>not 
unordered</TD></TR></TBODY></TABLE>
<P class=smalltext><SPAN class=smallcode>ftst</SPAN> compares 
the value in ST0 with 0.0 and sets the flags in the FPU status 
word according to the results. <SPAN 
class=smallcode>fxam</SPAN> examines the contents of the ST0 
and sets the flags in FPU status word to indicate the class of 
value in the register. These instructions have no operands. 
</P>
<P class=smalltext><SPAN class=smallcode>fstsw</SPAN> and 
<SPAN class=smallcode>fnstsw</SPAN> store the current value of 
the FPU status word in the destination location. The 
destination operand can be either a 16-bit memory or the AX 
register. <SPAN class=smallcode>fstsw</SPAN> checks for 
pending umasked FPU exceptions before storing the status word, 
<SPAN class=smallcode>fnstsw</SPAN> does not. </P>
<P class=smalltext><SPAN class=smallcode>fstcw</SPAN> and 
<SPAN class=smallcode>fnstcw</SPAN> store the current value of 
the FPU control word at the specified destination in memory. 
<SPAN class=smallcode>fstcw</SPAN> checks for pending umasked 
FPU exceptions before storing the control word, <SPAN 
class=smallcodr>fnstcw</SPAN> does not. <SPAN 
class=smallcode>fldcw</SPAN> loads the operand into the FPU 
control word. The operand should be a 16-bit memory location. 
</P>
<P class=smalltext><SPAN class=smallcode>fstenv</SPAN> and 
<SPAN class=smallcode>fnstenv</SPAN> store the current FPU 
operating environment at the memory location specified with 
the destination operand, and then mask all FPU exceptions. 
<SPAN class=smallcode>fstenv</SPAN> checks for pending umasked 
FPU exceptions before proceeding, <SPAN 
class=smallcode>fnstenv</SPAN> does not. <SPAN 
class=smallcode>fldenv</SPAN> loads the complete operating 
environment from memory into the FPU. <SPAN 
class=smallcode>fsave</SPAN> and <SPAN 
class=smallcode>fnsave</SPAN> store the current FPU state 
(operating environment and register stack) at the specified 
destination in memory and reinitializes the FPU. <SPAN 
class=smallcode>fsave</SPAN> check for pending unmasked FPU 
exceptions before proceeding, <SPAN 
class=smallcode>fnsave</SPAN> does not. <SPAN 
class=smallcode>frstor</SPAN> loads the FPU state from the 
specified memory location. All these instructions need an 
operand being a memory location. </P>
<P class=smalltext><SPAN class=smallcode>finit</SPAN> and 
<SPAN class=smallcode>fninit</SPAN> set the FPU operating 
environment into its default state. <SPAN 
class=smallcode>finit</SPAN> checks for pending unmasked FPU 
exception before proceeding, <SPAN 
class=smallcode>fninit</SPAN> does not. <SPAN 
class=smallcode>fclex</SPAN> and <SPAN 
class=smallcode>fnclex</SPAN> clear the FPU exception flags in 
the FPU status word. <SPAN class=smallcode>fclex</SPAN> checks 
for pending unmasked FPU exception before proceeding, <SPAN 
class=smallcode>fnclex</SPAN> does not. <SPAN 
class=smallcode>wait</SPAN> and <SPAN 
class=smallcode>fwait</SPAN> are synonyms for the same 
instruction, which causes the processor to check for pending 
unmasked FPU exceptions and handle them before proceeding. 
These instruction have no operands. </P>
<P class=smalltext><SPAN class=smallcode>ffree</SPAN> sets the 
tag associated with specified FPU register to empty. The 
operand should be an FPU register. </P>
<P class=smalltext><SPAN class=smallcode>fincstp</SPAN> and 
<SPAN class=smallcode>fdecstp</SPAN> rotate the FPU stack by 
one by adding or substracting one to the pointer of the top of 
stack. These instruction have no operands. </P>
<P><B><A class=smalltext name=2.1.14>2.1.14 MMX 
instructions</A> </B></P>
<P class=smalltext>The MMX instructions operate on the packed 
integer types and use the MMX registers, which are the low 
64-bit parts of the 80-bit FPU registers. Because of this MMX 
instructions cannot be used at the same time as FPU 
instructions. They can operate on packed bytes (eight 8-bit 
integers), packed words (four 16-bit integers) or packed 
double words (two 32-bit integers), use of packed formats 
allows to perform operations on multiple data at one time. 
</P>
<P class=smalltext><SPAN class=smallcode>movq</SPAN> copres a 
quad word from the source operand to the destination operand. 
At least one of the operands must be a MMX register, the 
second one can be also a MMX register or 64-bit memory 
location. </P><PRE class=smallcode>movq mm0,mm1 ; move quad word from register to register
movq mm2,[ebx] ; move quad word from memory to register
</PRE>
<P class=smalltext><SPAN class=smallcode>movd</SPAN> copies a 
double word from the source operand to the destination 
operand. One of the operands must be a MMX register, the 
second one can be a general register or 32-bit memory 
location. Only low double word of MMX register is used. </P>
<P class=smalltext>All general MMX operations have two 
operands, the destination operand should be a MMX register, 
the source operand can be a MMX register or 64-bit memory 
location. Operation is performed on the corresponding data 
elements of the source and destination operand and stored in 
the data elements of the destination operand. <SPAN 
class=smallcode>paddb</SPAN>, <SPAN 
class=smallcode>paddw</SPAN> and <SPAN 
class=smallcode>paddd</SPAN> perform the addition of packed 
bytes, packed words, or packed double words. <SPAN 
class=smallcode>psubb</SPAN>, <SPAN 
class=smallcode>psubw</SPAN> and <SPAN 
class=smallcode>psubd</SPAN> perform the substraction of 
appropriate types. <SPAN class=smallcode>paddsb</SPAN>, <SPAN 
class=smallcode>paddsw</SPAN>, <SPAN 
class=smallcode>psubsb</SPAN> and <SPAN 
class=smallcode>psubsw</SPAN> perform the addition or 
substraction of packed bytes or packed words with the signed 
saturation. <SPAN class=smallcode>paddusb</SPAN>, <SPAN 
class=smallcode>paddusw</SPAN>, <SPAN 
class=smallcode>psubusb</SPAN>, <SPAN 
class=smallcode>psubusw</SPAN> are analoguous, but with 
unsigned saturation. <SPAN class=smallcode>pmulhw</SPAN> and 
<SPAN class=smallcode>pmullw</SPAN> performs a signed multiply 
of the packed words and store the high or low words of the 
results in the destination operand. <SPAN 
class=smallcode>pmaddwd</SPAN> performs a multiply of the 
packed words and adds the four intermediate double word 
products in pairs to produce result as a packed double words. 
<SPAN class=smallcode>pand</SPAN>, <SPAN 
class=smallcode>por</SPAN> and <SPAN 
class=smallcode>pxor</SPAN> perform the logical operations on 
the quad words, <SPAN class=smallcode>pandn</SPAN> peforms 
also a logical negation of the destination operand before 
performing the <SPAN class=smallcode>and</SPAN> operation. 
<SPAN class=smallcode>pcmpeqb</SPAN>, <SPAN 
class=smallcode>pcmpeqw</SPAN> and <SPAN 
class=smallcode>pcmpeqd</SPAN> compare for equality of packed 
bytes, packed words or packed double words. If a pair of data 
elements is equal, the corresponding data element in the 
destination operand is filled with bits of value 1, otherwise 
it's set to 0. <SPAN class=smallcode>pcmpgtb</SPAN>, <SPAN 
class=smallcode>pcmpgtw</SPAN> and <SPAN 
class=smallcode>pcmpgtd</SPAN> perform the similar operation, 
but they check whether the data elements in the destination 
 roperand are greater than the correspoding data elements in the 
source operand. <SPAN class=smallcode>packsswb</SPAN> converts 
packed signed words into packed signed bytes, <SPAN 
class=smallcode>packssdw</SPAN> converts packed signed double 
words into packed signed words, using saturation to handle 
overflow conditions. <SPAN class=smallcode>packuswb</SPAN> 
converts packed signed words into packed unsigned bytes. 
Converted data elements from the source operand are stored in 
the low part of the destination operand, while converted data 
elements from the destination operand are stored in the high 
part. <SPAN class=smallcode>punpckhbw</SPAN>, <SPAN 
class=smallcode>punpckhwd</SPAN> and <SPAN 
class=smallcode>punpckhdq</SPAN> interleaves the data elements 
from the high parts of the source and destination operands and 
stores the result into the destination operand. <SPAN 
class=smallcode>punpcklbw</SPAN>, <SPAN 
class=smallcode>punpcklwd</SPAN> and <SPAN 
class=smallcode>punpckldq</SPAN> perform the same operation, 
but the low parts of the source and destination operand are 
used. </P><PRE class=smallcode>paddsb mm0,[esi] ; add packed bytes with signed saturation
pcmpeqw mm3,mm7; compare packed words for equality
</PRE>
<P class=smalltext><SPAN class=smallcode>psllw</SPAN>, <SPAN 
class=smallcode>pslld</SPAN> and <SPAN 
class=smallcode>psllq</SPAN> perform logical shift left of the 
packed words, packed double words or a single quad word in the 
destination operand by the amount specified in the source 
operand. <SPAN class=smallcode>psrlw</SPAN>, <SPAN 
class=smallcode>psrld</SPAN> and <SPAN 
class=smallcode>psrlq</SPAN> perform logical shift right of 
the packed words, packed double words or a single quad word. 
<SPAN class=smallcode>psraw</SPAN> and <SPAN 
class=smallcode>psrad</SPAN> perform arithmetic shift of the 
packed words or double words. The destination operand should 
be a MMX register, while source operand can be a MMX register, 
64-bit memory location, or 8-bit immediate value. </P><PRE class=smallcode>psllw mm2,mm4; shift words left logically
psrad mm4,[ebx]; shift double words right arithmetically
</PRE>
<P class=smalltext><SPAN class=smallcode>emms</SPAN> makes the 
FPU registers usable for the FPU instructions, it must be used 
before using the FPU instructions if any MMX instructions were 
used. </P>
<P><B><A class=smalltext name=2.1.15>2.1.15 SSE 
instructions</A> </B></P>
<P class=smalltext>The SSE extension adds more MMX 
instructions and also introduces the operations on packed 
single precision floating point values. The 128-bit packed 
single precision format consists of four single precision 
floating point values. The 128-bit SSE registers are designed 
for the purpose of operations on this data type. </P>
<P class=smalltext><SPAN class=smallcode>movaps</SPAN> and 
<SPAN class=smallcode>movups</SPAN> transfer a double quad 
word operand containing packed single precision values from 
source operand to destination operand. At least one of the 
operands have to be a SSE register, the second one can be also 
 ra SSE register or 128-bit memory location. Memory operands for 
<SPAN class=smallcode>movaps</SPAN> instruction must be 
aligned on boundary of 16 bytes, operands for <SPAN 
class=smallcode>movups</SPAN> instruction don't have to be 
aligned. </P><PRE class=smallcode>movups xmm0,[ebx]; move unaligned double quad word
</PRE>
<P class=smalltext><SPAN class=smallcode>movlps</SPAN> moves 
packed two single precision values between the memory and the 
low quad word of SSE register. <SPAN 
class=smallcode>movhps</SPAN> moved packed two single 
precision values between the memory and the high quad word of 
SSE register. One of the operands must be a SSE register, and 
the other operand must be a 64-bit memory location. </P><PRE class=smallcode>movlps xmm0,[ebx]; move memory to low quad word of xmm0
movhps [esi],xmm7; move high quad word of xmm7 to memory
</PRE>
<P class=smalltext><SPAN class=smallcode>movlhps</SPAN> moves 
packed two single precision values from the low quad word of 
source register to the high quad word of destination register. 
<SPAN class=smallcode>movhlps</SPAN> moves two packed single 
precision values from the high quad word of source register to 
the low quad word of destination register. Both operands have 
to be a SSE registers. </P>
<P class=smalltext><SPAN class=smallcode>movmskps</SPAN> 
transfers the most significant bit of each of the four single 
precision values in the SSE register into low four bits of a 
general register. The source operand must be a SSE register, 
the destination operand must be a general register. </P>
<P class=smalltext><SPAN class=smallcode>movss</SPAN> 
transfers a single precision value between source and 
destination operand (only the low double word is trasferred). 
At least one of the operands have to be a SSE register, the 
second one can be also a SSE register or 32-bit memory 
location. </P><PRE class=smallcode>movss [edi],xmm3 ; move low double word of xmm3 to memory
</PRE>
<P class=smalltext>Each of the SSE arithmetic operations has 
two variants. When the mnemonic ends with <SPAN 
class=smallcode>ps</SPAN>, the source operand can be a 128-bit 
memory location or a SSE register, the destination operand 
must be a SSE register and the operation is performed on 
packed four single precision values, for each pair of the 
corresponding data elements separately, the result is stored 
in the destination register. When the mnemonic ends with <SPAN 
class=smallcode>ss</SPAN>, the source operand can be a 32-bit 
memory location or a SSE register, the destination operand 
must be a SSE register and the operation is performed on 
single precision values, only low double words of SSE 
registers are used in this case, the result is stored in the 
low double word of destination register. <SPAN 
class=smallcode>addps</SPAN> and <SPAN 
class=smallcode>addss</SPAN> add the values, <SPAN 
class=smallcode>subps</SPAN> and <SPAN 
class=smallcode>subss</SPAN> substract the source value from 
destination value, <SPAN class=smallcode>mulps</SPAN> and 
<SPAN class=smallcode>mulss</SPAN> multiply the values, <SPAN 
r class=smallcode>divps</SPAN> and <SPAN 
class=smallcode>divss</SPAN> divide the destination value by 
the source value, <SPAN class=smallcode>rcpps</SPAN> and <SPAN 
class=smallcode>rcpss</SPAN> compute the approximate 
reciprocal of the source value, <SPAN 
class=smallcode>sqrtps</SPAN> and <SPAN 
class=smallcode>sqrtss</SPAN> compute the square root of the 
source value, <SPAN class=smallcode>rsqrtps</SPAN> and <SPAN 
class=smallcode>rsqrtss</SPAN> compute the approximate 
reciprocal of square root of the source value, <SPAN 
class=smallcode>maxps</SPAN> and <SPAN 
class=smallcode>maxss</SPAN> compare the source and 
destination values and return the greater one, <SPAN 
class=smallcode>minps</SPAN> and <SPAN 
class=smallcode>minss</SPAN> compare the source and 
destination values and return the lesser one. </P><PRE class=smallcode>mulss xmm0,[ebx] ; multiply single precision values
addps xmm3,xmm7; add packed single precision values
</PRE>
<P class=smalltext><SPAN class=smallcode>andps</SPAN>, <SPAN 
class=smallcode>andnps</SPAN>, <SPAN 
class=smallcode>orps</SPAN> and <SPAN 
class=smallcode>xorps</SPAN> perform the logical operations on 
packed single precision values. The source operand can be a 
128-bit memory location or a SSE register, the destination 
operand must be a SSE register. </P>
<P class=smalltext><SPAN class=smallcode>cmpps</SPAN> compares 
packed single precision values and returns a mask result into 
the destination operand, which must be a SSE register. The 
source operand can be a 128-bit memory location or SSE 
register, the third operand must be an immediate operand 
selecting code of one of the eight compare conditions (table 
<A 
href="#2.3">2.3</A>). 
<SPAN class=smallcode>cmpss</SPAN> performs the same operation 
on single precision values, only low double word of 
destination register is affected, in this case source operand 
can be a 32-bit memory location or SSE register. These two 
instructions have also variants with only two operands and the 
condition encoded within mnemonic. Their mnemonics are 
obtained by attaching the mnemonic from table <A 
href="#2.3">2.3</A> 
to the <SPAN class=smallcode>cmp</SPAN> mnemonic and then 
attaching the <SPAN class=smallcode>ps</SPAN> or <SPAN 
class=smallcode>ss</SPAN> at the end. </P><PRE class=smallcode>cmpps xmm2,xmm4,0; compare packed single precision values
cmpltss xmm0,[ebx] ; compare single precision values
</PRE>
<P class=smalltext><B><a name=2.3>Table 2.3 SSE 
conditions</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=350 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle bgColor=#ffffff>Code</TH>
<TH align=middle bgColor=#ffffff>Mnemonic</TH>
<TH align=middle bgColor=#ffffff>Description</TH></TR>
<TR>
<TD align=middle bgColor=#ffffff>0</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>eq</SPAN></TD>
<TD align=middle bgColor=#ffffff>equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>1</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>lt</SPAN></TD>
<TD align=middle bgColor=#ffffff>less than</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>2</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>le</SPAN></TD>
<TD align=middle bgColor=#ffffff>less than or 
equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>3</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>unord</SPAN></TD>
<TD align=middle bgColor=#ffffff>unordered</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>4</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>neq</SPAN></TD>
<TD align=middle bgColor=#ffffff>not equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>5</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>nlt</SPAN></TD>
<TD align=middle bgColor=#ffffff>not less than</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>6</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>nle</SPAN></TD>
<TD align=middle bgColor=#ffffff>not less than nor 
equal</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff>7</TD>
<TD align=middle bgColor=#ffffff><SPAN 
class=smallcode>ord</SPAN></TD>
<TD align=middle 
bgColor=#ffffff>ordered</TD></TR></TBODY></TABLE>
<P class=smalltext><SPAN class=smallcode>comiss</SPAN> and 
<SPAN class=smallcode>ucomiss</SPAN> compare the single 
precision values and set the ZF, PF and CF flags to show the 
result. The destination operand must be a SSE register, the 
source operand can be a 32-bit memory location or SSE 
register. </P>
<P class=smalltext><SPAN class=smallcode>shufps</SPAN> moves 
any two of the four single precision values from the 
destination operand into the low quad word of the destination 
operand, and any two of the four values from the source 
operand into the high quad word of the destination operand. 
The destination operand must be a SSE register, the source 
operand can be a 128-bit memory location or SSE register, the 
third operand must be an 8-bit immediate value selecting which 
values will be moved into the destination operand. Bits 0 and 
1 select the value to be moved from destination operand to the 
low double word of the result, bits 2 and 3 select the value 
to be moved from the destination operand to the second double 
word, bits 4 and 5 select the value to be moved from the 
source operand to the third double word, and bits 6 and 7 
select the value to be moved from the source operand to the 
high double word of the result. </P><PRE class=smallcode>shufps xmm0,xmm0,10010011b ; shuffle double words
</PRE>
<P class=smalltext><SPAN class=smallcode>unpckhps</SPAN> 
performs an interleaved unpack of the values from the high 
parts of the source and destination operands and stores thr 
result in the destination operand, which must be a SSE 
register. The source operand can be a 128-bit memory location 
or a SSE register. <SPAN class=smallcode>unpcklps</SPAN> 
performs an interleaved unpack of the values from the low 
parts of the source and destination operand and stores the 
result in the destination operand, the rules for operands are 
the same. </P>
<P class=smalltext><SPAN class=smallcode>cvtpi2ps</SPAN> 
converts packed two double word integers into the the packed 
two single precision floating point values and stores the 
result in the low quad word of the destination operand, which 
should be a SSE register. The source operand can be a 64-bit 
memory location or MMX register. </P><PRE class=smallcode>cvtpi2ps xmm0,mm0; convert integers to single precision values
</PRE>
<P class=smalltext><SPAN class=smallcode>cvtsi2ss</SPAN> 
converts a double word integer into a single precision 
floating point value and stores the result in the low double 
word of the destination operand, which should be a SSE 
register. The source operand can be a 32-bit memory location 
or 32-bit general register. </P><PRE class=smallcode>cvtsi2ss xmm0,eax; convert integer to single precision value
</PRE>
<P class=smalltext><SPAN class=smallcode>cvtps2pi</SPAN> 
converts packed two single precision floating point values 
into packed two double word integers and stores the result in 
the destination operand, which should be a MMX register. The 
source operand can be a 64-bit memory location or SSE 
register, only low quad word of SSE register is used. <SPAN 
class=smallcode>cvttps2pi</SPAN> performs the similar 
operation, except that truncation is used to round a source 
values to integers, rules for the operands are the same. </P><PRE class=smallcode>cvtps2pi mm0,xmm0; convert single precision values to integers
</PRE>
<P class=smalltext><SPAN class=smallcode>cvtss2si</SPAN> 
convert a single precision floating point value into a double 
word integer and stores the result in the destination operand, 
which should be a 32-bit general register. The source operand 
can be a 32-bit memory location or SSE register, only low 
double word of SSE register is used. <SPAN 
class=smallcode>cvttss2si</SPAN> performs the similar 
operation, except that truncation is used to round a source 
value to integer, rules for the operands are the same. </P><PRE class=smallcode>cvtss2si eax,xmm0; convert single precision value to integer
</PRE>
<P class=smalltext><SPAN class=smallcode>pextrw</SPAN> copies 
the word in the source operand specified by the third operand 
to the destination operand. The source operand must be a MMX 
register, the destination operand must be a 32-bit general 
register (but only the low word of it is affected), the third 
operand must an 8-bit immediate value. </P><PRE class=smallcode>pextrw eax,mm0,1 ; extract word into eax
</PRE>
<P class=smalltext><SPAN class=smallcode>pinsrw</SPAN> inserts 
a word from the source operand in the destination operand at 
the location specified with the third operand, which must be 
an 8-bit immediate value. The destination operand must be a 
MMX regisrer, the source operand can be a 16-bit memory 
location or 32-bit general register (only low word of the 
register is used). </P><PRE class=smallcode>pinsrw mm1,ebx,2 ; insert word from ebx
</PRE>
<P class=smalltext><SPAN class=smallcode>pavgb</SPAN> and 
<SPAN class=smallcode>pavgw</SPAN> compute average of packed 
bytes or words. <SPAN class=smallcode>pmaxub</SPAN> return the 
maximum values of packed unsigned bytes, <SPAN 
class=smallcode>pminub</SPAN> returns the minimum values of 
packed unsigned bytes, <SPAN class=smallcode>pmaxsw</SPAN> 
returns the maximum values of packed signed words, <SPAN 
class=smallcode>pminsw</SPAN> returns the minimum values of 
packed signed words. <SPAN class=smallcode>pmulhuw</SPAN> 
performs a unsigned multiply of the packed words and stores 
the high words of the results in the destination operand. 
<SPAN class=smallcode>psadbw</SPAN> computes the absolute 
differences of packed unsigned bytes, sums the differences, 
and stores the sum in the low word of destination operand. All 
these instructions follow the same rules for operands as the 
general MMX operations described in previous section. </P>
<P class=smalltext><SPAN class=smallcode>pmovmskb</SPAN> 
creates a mask made of the most significant bit of each byte 
in the source operand and stores the result in the low byte of 
destination operand. The source operand must be a MMX 
register, the destination operand must a 32-bit general 
register. </P>
<P class=smalltext><SPAN class=smallcode>pshufw</SPAN> inserts 
words from the source operand in the destination operand from 
the locations specified with the third operand. The 
destination operand must be a MMX register, the source operand 
can be a 64-bit memory location or MMX register, third operand 
must an 8-bit immediate value selecting which values will be 
moved into destination operand, in the similar way as the 
third operand of the <SPAN class=smallcode>shufps</SPAN> 
instruction. </P>
<P class=smalltext><SPAN class=smallcode>movntq</SPAN> moves 
the quad word from the source operand to memory using a 
non-temporal hint to minimize cache pollution. The source 
operand should be a MMX register, the destination operand 
should be a 64-bit memory location. <SPAN 
class=smallcode>movntps</SPAN> stores packed single precision 
values from the SSE register to memory using a non-temporal 
hint. The source operand should be a SSE register, the 
destination operand should be a 128-bit memory location. <SPAN 
class=smallcode>maskmovq</SPAN> stores selected bytes from the 
first operand into a 64-bit memory location using a 
non-temporal hint. Both operands should be a MMX registers, 
the second operand selects wich bytes from the source operand 
are written to memory. The memory location is pointed by DI 
(or EDI) register in the segment selected by DS. </P>
<P class=smalltext><SPAN class=smallcode>prefetcht0</SPAN>, 
<SPAN class=smallcode>prefetcht1</SPAN>, <SPAN 
class=smallcode>prefetcht2</SPAN> and <SPAN 
class=smallcode>prefetchnta</SPAN> fetch the line of data from 
memory thatrcontains byte specified with the operand to a 
specified location in hierarchy. The operand should be an 
8-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>sfence</SPAN> 
performs a serializing operation on all instruction storing to 
memory that were issued prior to it. This instruction has no 
operands. </P>
<P class=smalltext><SPAN class=smallcode>ldmxcsr</SPAN> loads 
the 32-bit memory operand into the MXCSR register. <SPAN 
class=smallcode>stmxcsr</SPAN> stores the contents of MXCSR 
into a 32-bit memory operand. </P>
<P class=smalltext><SPAN class=smallcode>fxsave</SPAN> saves 
the current state of the FPU, MXCSR register, and all the FPU 
and SSE registers to a 512-byte memory location specified in 
the destination operand. <SPAN class=smallcode>fxrstor</SPAN> 
reloads data previously stored with <SPAN 
class=smallcode>fxsave</SPAN> instruction from the specified 
512-byte memory location. The memory operand for both those 
instructions must be aligned on 16 byte boundary, it should 
declare operand of no specified size. </P>
<P><B><A class=smalltext name=2.1.16>2.1.16 SSE2 
instructions</A> </B></P>
<P class=smalltext>The SSE2 extension introduces the 
operations on packed double precision floating point values, 
extends the syntax of MMX instructions, and adds also some new 
instructions. </P>
<P class=smalltext><SPAN class=smallcode>movapd</SPAN> and 
<SPAN class=smallcode>movupd</SPAN> transfer a double quad 
word operand containing packed double precision values from 
source operand to destination operand. These instructions are 
analogous to <SPAN class=smallcode>movaps</SPAN> and <SPAN 
class=smallcode>movups</SPAN> and have the same rules for 
operands. </P>
<P class=smalltext><SPAN class=smallcode>movlpd</SPAN> moves 
double precision value between the memory and the low quad 
word of SSE register. <SPAN class=smallcode>movhpd</SPAN> 
moved double precision value between the memory and the high 
quad word of SSE register. These instructions are analogous to 
<SPAN class=smallcode>movlps</SPAN> and <SPAN 
class=smallcode>movhps</SPAN> and have the same rules for 
operands. </P>
<P class=smalltext><SPAN class=smallcode>movmskpd</SPAN> 
transfers the most significant bit of each of the two double 
precision values in the SSE register into low two bits of a 
general register. This instruction is analogous to <SPAN 
class=smallcode>movmskps</SPAN> and has the same rules for 
operands. </P>
<P class=smalltext><SPAN class=smallcode>movsd</SPAN> 
transfers a double precision value between source and 
destination operand (only the low quad word is trasferred). At 
least one of the operands have to be a SSE register, the 
second one can be also a SSE register or 64-bit memory 
location. </P>
<P class=smalltext>Arithmetic operations on double precision 
values are: <SPAN class=smallcode>addpd</SPAN>, <SPAN 
class=smallcode>addsd</SPAN>, <SPAN 
class=smallcode>subpd</SPAN>, <SPAN 
class=smallcode>subsd</SPAN>, <SPAN 
 rclass=smallcode>mulpd</SPAN>, <SPAN 
class=smallcode>mulsd</SPAN>, <SPAN 
class=smallcode>divpd</SPAN>, <SPAN 
class=smallcode>divsd</SPAN>, <SPAN 
class=smallcode>sqrtpd</SPAN>, <SPAN 
class=smallcode>sqrtsd</SPAN>, <SPAN 
class=smallcode>maxpd</SPAN>, <SPAN 
class=smallcode>maxsd</SPAN>, <SPAN 
class=smallcode>minpd</SPAN>, <SPAN 
class=smallcode>minsd</SPAN>, and they are analoguous to 
arithmetic operations on single precision values described in 
previous section. When the mnemonic ends with <SPAN 
class=smallcode>pd</SPAN> instead of <SPAN 
class=smallcode>ps</SPAN>, the operation is performed on 
packed two double precision values, but rules for operands are 
the same. When the mnemonic ends with <SPAN 
class=smallcode>sd</SPAN> instead of <SPAN 
class=smallcode>ss</SPAN>, the source operand can be a 64-bit 
memory location or a SSE register, the destination operand 
must be a SSE register and the operation is performed on 
double precision values, only low quad words of SSE registers 
are used in this case. </P>
<P class=smalltext><SPAN class=smallcode>andpd</SPAN>, <SPAN 
class=smallcode>andnpd</SPAN>, <SPAN 
class=smallcode>orpd</SPAN> and <SPAN 
class=smallcode>xorpd</SPAN> perform the logical operations on 
packed double precision values. They are analoguous to SSE 
logical operations on single prevision values and have the 
same rules for operands. </P>
<P class=smalltext><SPAN class=smallcode>cmppd</SPAN> compares 
packed double precision values and returns and returns a mask 
result into the destination operand. This instruction is 
analoguous to <SPAN class=smallcode>cmpps</SPAN> and has the 
same rules for operands. <SPAN class=smallcode>cmpsd</SPAN> 
performs the same operation on double precision values, only 
low quad word of destination register is affected, in this 
case source operand can be a 64-bit memory or SSE register. 
Variant with only two operands are obtained by attaching the 
condition mnemonic from table <A 
href="#2.3">2.3</A> 
to the <SPAN class=smallcode>cmp</SPAN> mnemonic and then 
attaching the <SPAN class=smallcode>pd</SPAN> or <SPAN 
class=smallcode>sd</SPAN> at the end. </P>
<P class=smalltext><SPAN class=smallcode>comisd</SPAN> and 
<SPAN class=smallcode>ucomisd</SPAN> compare the double 
precision values and set the ZF, PF and CF flags to show the 
result. The destination operand must be a SSE register, the 
source operand can be a 128-bit memory location or SSE 
register. </P>
<P class=smalltext><SPAN class=smallcode>shufpd</SPAN> moves 
any of the two double precision values from the destination 
operand into the low quad word of the destination operand, and 
any of the two values from the source operand into the high 
quad word of the destination operand. This instruction is 
analoguous to <SPAN class=smallcode>shufps</SPAN> and has the 
same rules for operand. Bit 0 of the third operand selects the 
value to be moved from the destination operand, bit 1 selects 
r the value to be moved from the source operand, the rest of 
bits are reserved and must be zeroed. </P>
<P class=smalltext><SPAN class=smallcode>unpckhpd</SPAN> 
performs an unpack of the high quad words from the source and 
destination operands, <SPAN class=smallcode>unpcklpd</SPAN> 
performs an unpack of the low quad words from the source and 
destination operands. They are analoguous to <SPAN 
class=smallcode>unpckhps</SPAN> and <SPAN 
class=smallcode>unpcklps</SPAN>, and have the same rules for 
operands. </P>
<P class=smalltext><SPAN class=smallcode>cvtps2pd</SPAN> 
converts the packed two single precision floating point values 
to two packed double precision floating point values, the 
destination operand must be a SSE register, the source operand 
can be a 64-bit memory location or SSE register. <SPAN 
class=smallcode>cvtpd2ps</SPAN> converts the packed two double 
precision floating point values to packed two single precision 
floating point values, the destination operand must be a SSE 
register, the source operand can be a 128-bit memory location 
or SSE register. <SPAN class=smallcode>cvtss2sd</SPAN> 
converts the single precision floating point value to double 
precision floating point value, the destination operand must 
be a SSE register, the source operand can be a 32-bit memory 
location or SSE register. <SPAN 
class=smallcode>cvtsd2ss</SPAN> converts the double precision 
floating point value to single precision floating point value, 
the destination operand must be a SSE register, the source 
operand can be 64-bit memory location or SSE register. </P>
<P class=smalltext><SPAN class=smallcode>cvtpi2pd</SPAN> 
converts packed two double word integers into the the packed 
double precision floating point values, the destination 
operand must be a SSE register, the source operand can be a 
64-bit memory location or MMX register. <SPAN 
class=smallcode>cvtsi2sd</SPAN> converts a double word integer 
into a double precision floating point value, the destination 
operand must be a SSE register, the source operand can be a 
32-bit memory location or 32-bit general register. <SPAN 
class=smallcode>cvtpd2pi</SPAN> converts packed double 
precision floating point values into packed two double word 
integers, the destination operand should be a MMX register, 
the source operand can be a 128-bit memory location or SSE 
register. <SPAN class=smallcode>cvttpd2pi</SPAN> performs the 
similar operation, except that truncation is used to round a 
source values to integers, rules for operands are the same. 
<SPAN class=smallcode>cvtsd2si</SPAN> converts a double 
precision floating point value into a double word integer, the 
destination operand should be a 32-bit general register, the 
source operand can be a 64-bit memory location or SSE 
register. <SPAN class=smallcode>cvttsd2si</SPAN> performs the 
similar operation, except that truncation is used to round a 
source value to integer, rules for operands are the same. </P>
<P class=smalltext><SPAN class=smallcode>cvtps2dq</SPAN> and 
<SPAN class=smallcode>cvttps2dq</SPAN> convert packed single 
 rprecision floating point values to packed four double word 
integers, storing them in the destination operand. <SPAN 
class=smallcode>cvtpd2dq</SPAN> and <SPAN 
class=smallcode>cvttpd2dq</SPAN> convert packed double 
precision floating point values to packed two double word 
integers, storing the result in the low quad word of the 
destination operand. <SPAN class=smallcode>cvtdq2ps</SPAN> 
converts packed four double word integers to packed single 
precision floating point values. <SPAN 
class=smallcode>cvtdq2pd</SPAN> converts packed two double 
word integers from the low quad word of the source operand to 
packed double precision floating point values. For all these 
instruction destination operand must be a SSE register, the 
source operand can be a 128-bit memory location or SSE 
register. </P>
<P class=smalltext><SPAN class=smallcode>movdqa</SPAN> and 
<SPAN class=smallcode>movdqu</SPAN> transfer a double quad 
word operand containing packed integers from source operand to 
destination operand. At least one of the operands have to be a 
SSE register, the second one can be also a SSE register or 
128-bit memory location. Memory operands for <SPAN 
class=smallcode>movdqa</SPAN> instruction must be aligned on 
boundary of 16 bytes, operands for <SPAN 
class=smallcode>movdqu</SPAN> instruction don't have to be 
aligned. </P>
<P class=smalltext><SPAN class=smallcode>movq2dq</SPAN> moves 
the contents of the MMX source register to the low quad word 
of destination SSE register. <SPAN 
class=smallcode>movdq2q</SPAN> moves the low quad word from 
the source SSE register to the destination MMX register. <PRE class=smallcode>movq2dq xmm0,mm1 ; move from MMX register to SSE register
movdq2q mm0,xmm1 ; move from SSE register to MMX register
</PRE>
<P class=smalltext>All MMX instructions operating on the 
64-bit packed integers (those with mnemonics starting with 
<SPAN class=smallcode>p</SPAN>) are extended to operate on 
128-bit packed integers located in SSE registers. Additional 
syntax for these instructions needs an SSE register where MMX 
register was needed, and the 128-bit memory location or SSE 
register where 64-bit memory location of MMX register were 
needed. The exception is <SPAN class=smallcode>pshufw</SPAN> 
instruction, which doesn't allow extended syntax, but has two 
new variants: <SPAN class=smallcode>pshufhw</SPAN> and <SPAN 
class=smallcode>pshuflw</SPAN>, which allow only the extended 
syntax, and perform the same operation as <SPAN 
class=smallcode>pshufw</SPAN> on the high or low quad words of 
operands respectively. Also the new instruction <SPAN 
class=smallcode>pshufd</SPAN> is introduced, which performs 
the same operation as <SPAN class=smallcode>pshufw</SPAN>, but 
on the double words instead of words, it allows only the 
extended syntax. </P><PRE class=smallcode>psubb xmm0,[esi] ; substract 16 packed bytes
pextrw eax,xmm0,7; extract highest word into eax
</PRE>
<P class=smalltext><SPAN class=smallcode>paddq</SPAN> performs 
the addition of packed quad words, <SPAN 
class=smallcode>psubq</SPAN> performs the substractior of 
packed quad words, <SPAN class=smallcode>pmuludq</SPAN> 
performs an unsigned multiply of low double words from each 
corresponding quad words and returns the results in packed 
quad words. These instructions follow the same rules for 
operands as the general MMX operations described in <A 
href="#2.1.14">2.1.14</A>. 
</P>
<P class=smalltext><SPAN class=smallcode>pslldq</SPAN> and 
<SPAN class=smallcode>psrldq</SPAN> perform logical shift left 
or right of the double quad word in the destination operand by 
the amount of bits specified in the source operand. The 
destination operand should be a SSE register, source operand 
should be an 8-bit immediate value. </P>
<P class=smalltext><SPAN class=smallcode>punpckhqdq</SPAN> 
interleaves the high quad word of the source operand and the 
high quad word of the destination operand and writes them to 
the destination SSE register. <SPAN 
class=smallcode>punpcklqdq</SPAN> interleaves the low quad 
word of the source operand and the low quad word of the 
destination operand and writes them to the destination SSE 
register. The source operand can be a 128-bit memory location 
or SSE register. </P>
<P class=smalltext><SPAN class=smallcode>movntdq</SPAN> stores 
packed integer data from the SSE register to memory using 
non-temporal hint. The source operand should be a SSE 
register, the destination operand should be a 128-bit memory 
location. <SPAN class=smallcode>movntpd</SPAN> stores packed 
double precision values from the SSE register to memory using 
a non-temporal hint. Rules for operand are the same. <SPAN 
class=smallcode>movnti</SPAN> stores integer from a general 
register to memory using a non-temporal hint. The source 
operand should be a 32-bit general register, the destination 
operand should be a 32-bit memory location. <SPAN 
class=smallcode>maskmovdqu</SPAN> stores selected bytes from 
the first operand into a 128-bit memory location using a 
non-temporal hint. Both operands should be a SSE registers, 
the second operand selects wich bytes from the source operand 
are written to memory. The memory location is pointed by DI 
(or EDI) register in the segment selected by DS and does not 
need to be aligned. </P>
<P class=smalltext><SPAN class=smallcode>clflush</SPAN> writes 
and invalidates the cache line associated with the address of 
byte specified with the operand, which should be a 8-bit 
memory location. </P>
<P class=smalltext><SPAN class=smallcode>lfence</SPAN> 
performs a serializing operation on all instruction loading 
from memory that were issued prior to it. <SPAN 
class=smallcode>mfence</SPAN> performs a serializing operation 
on all instruction accesing memory that were issued prior to 
it, and so it combines the functions of <SPAN 
class=smallcode>sfence</SPAN> (described in previous section) 
and <SPAN class=smallcode>lfence</SPAN> instructions. These 
instructions have no operands. </P>
<P><B><A class=smalltext name=2.1.17>2.1.17 SSE3 
instructions</A> </B></P>
 r<P class=smalltext>Prescott technology introduces some new 
instructions to improve the performance of SSE and SSE2 - this 
extension is called SSE3. </P>
<P class=smalltext><SPAN class=smallcode>fisttp</SPAN> behaves 
like the <SPAN class=smallcode>fistp</SPAN> instruction and 
accepts the same operands, the only difference is that it 
always used truncation, irrespective of the rounding mode. 
</P>
<P class=smalltext><SPAN class=smallcode>movshdup</SPAN> loads 
into destination operand the 128-bit value obtained from the 
source value of the same size by filling the each quad word 
with the two duplicates of the value in its high double word. 
<SPAN class=smallcode>movsldup</SPAN> performs the same 
action, except it duplicates the values of low double words. 
The destination operand should be SSE register, the source 
operand can be SSE register or 128-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>movddup</SPAN> loads 
the 64-bit source value and duplicates it into high and low 
quad word of the destination operand. The destination operand 
should be SSE register, the source operand can be SSE register 
or 64-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>lddqu</SPAN> is 
functionally equivalent to <SPAN class=smallcode>movdqu</SPAN> 
instruction with memory as source operand, but it may improve 
performance when the source operand crosses a cacheline 
boundary. The destination operand has to be SSE register, the 
source operand must be 128-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>addsubps</SPAN> 
performs single precision addition of second and fourth pairs 
and single precision substracion of the first and third pairs 
of floating point values in the operands. <SPAN 
class=smallcode>addsubpd</SPAN> performs double precision 
addition of the second pair and double precision substraction 
of the first pair of floating point values in the operand. 
<SPAN class=smallcode>haddps</SPAN> performs the addition of 
two single precision values within the each quad word of 
source and destination operands, and stores the results of 
such horizontal addition of values from destination operand 
into low quad word of destination operand, and the results 
from the source operand into high quad word of destination 
operand. <SPAN class=smallcode>haddpd</SPAN> performs the 
addition of two double precision values within each operand, 
and stores the result from destination operand into low quad 
word of destination operand, and the result from source 
operand into high quad word of destination operand. All these 
instruction need the destination operand to be SSE register, 
source operand can be SSE register or 128-bit memory location. 
</P>
<P class=smalltext><SPAN class=smallcode>monitor</SPAN> sets 
up an address range for monitoring of write-back stores. It 
need its three operands to be EAX, ECX and EDX register in 
that order. <SPAN class=smallcode>mwait</SPAN> waits for a 
write-back store to the address range set up by the <SPAN 
class=smallcode>monitor</SPAN> instruction. It rses two 
operands with additional parameters, first being the EAX and 
second the ECX register. </P>
<P><B><A class=smalltext name=2.1.18>2.1.18 AMD 3DNow! 
instructions</A> </B></P>
<P class=smalltext>The 3DNow! extension adds a new MMX 
instructions to those described in <A 
href="#2.1.14">2.1.14</A>, 
and introduces operation on the 64-bit packed floating point 
values, each consisting of two single precision floating point 
values. </P>
<P class=smalltext>These instructions follow the same rules as 
the general MMX operations, the destination operand should be 
a MMX register, the source operand can be a MMX register or 
64-bit memory location. <SPAN class=smallcode>pavgusb</SPAN> 
computes the rounded averages of packed unsigned bytes. <SPAN 
class=smallcode>pmulhrw</SPAN> performs a signed multiply of 
the packed words, round the high word of each double word 
results and stores them in the destination operand. <SPAN 
class=smallcode>pi2fd</SPAN> converts packed double word 
integers into packed floating point values. <SPAN 
class=smallcode>pf2id</SPAN> converts packed floating point 
values into packed double word integers using truncation. 
<SPAN class=smallcode>pi2fw</SPAN> converts packed word 
integers into packed floating point values, only low words of 
each double word in source operand are used. <SPAN 
class=smallcode>pf2iw</SPAN> converts packed floating point 
values to packed word integers, results are extended to double 
words using the sign extension. <SPAN 
class=smallcode>pfadd</SPAN> adds packed floating point 
values. <SPAN class=smallcode>pfsub</SPAN> and <SPAN 
class=smallcode>pfsubr</SPAN> substracts packed floating point 
values, the first one substracts source values from 
destination values, the second one substracts destination 
values from the source values. <SPAN 
class=smallcode>pfmul</SPAN> multiplies packed floating point 
values. <SPAN class=smallcode>pfacc</SPAN> adds the low and 
high floating point values of the destination operand, storing 
the result in the low double word of destination, and adds the 
low and high floating point values of the source operand, 
storing the result in the high double word of destination. 
<SPAN class=smallcode>pfnacc</SPAN> substracts the high 
floating point value of the destination operand from the low, 
storing the result in the low double word of destination, and 
substracts the high floating point value of the source operand 
from the low, storing the result in the high double word of 
destination. <SPAN class=smallcode>pfpnacc</SPAN> substracts 
the high floating point value of the destination operand from 
the low, storing the result in the low double word of 
destination, and adds the low and high floating point values 
of the source operand, storing the result in the high double 
word of destination. <SPAN class=smallcode>pfmax</SPAN> and 
<SPAN class=smallcode>pfmin</SPAN> compute the maximum and 
minimum of floating point values. <SPAN 
class=smallcode>pswapd</SPAN> reverses the higr and low double 
word of the source operand. <SPAN class=smallcode>pfrcp</SPAN> 
returns an estimates of the reciprocals of floating point 
values from the source operand, <SPAN 
class=smallcode>pfrsqrt</SPAN> returns an estimates of the 
reciprocal square roots of floating point values from the 
source operand, <SPAN class=smallcode>pfrcpit1</SPAN> performs 
the first step in the Newton-Raphson iteration to refine the 
reciprocal approximation produced by <SPAN 
class=smallcode>pfrcp</SPAN> instruction, <SPAN 
class=smallcode>pfrsqit1</SPAN> performs the first step in the 
Newton-Raphson iteration to refine the reciprocal square root 
approximation produced by <SPAN class=smallcode>pfrsqrt</SPAN> 
instruction, <SPAN class=smallcode>pfrcpit2</SPAN> performs 
the second final step in the Newton-Raphson iteration to 
refine the reciprocal approximation or the reciprocal square 
root approximation. <SPAN class=smallcode>pfcmpeq</SPAN>, 
<SPAN class=smallcode>pfcmpge</SPAN> and <SPAN 
class=smallcode>pfcmpgt</SPAN> compare the packed floating 
point values and sets all bits or zeroes all bits of the 
correspoding data element in the destination operand according 
to the result of comparision, first checks whether values are 
equal, second checks whether destination value is greater or 
equal to source value, third checks whether destination value 
is greater than source value. </P>
<P class=smalltext><SPAN class=smallcode>prefetch</SPAN> and 
<SPAN class=smallcode>prefetchw</SPAN> load the line of data 
from memory that contains byte specified with the operand into 
the data cache, <SPAN class=smallcode>prefetchw</SPAN> 
instruction should be used when the data in the cache line is 
expected to be modified, otherwise the <SPAN 
class=smallcode>prefetch</SPAN> instruction should be used. 
The operand should be an 8-bit memory location. </P>
<P class=smalltext><SPAN class=smallcode>femms</SPAN> performs 
a fast clear of MMX state. This instruction has no operands. 
</P>
<P><B><A class=smalltext name=2.1.19>2.1.19 The x86-64 long 
mode instructions</A> </B></P>
<P class=smalltext>The AMD64 and EM64T architectures (we will 
use the common name x86-64 for them both) extend the x86 
instruction set for the 64-bit processing. While legacy and 
compatibility modes use the same set of registers and 
instructions, the new long mode extends the x86 operations to 
64 bits and introduces several new registers. You can turn on 
generating the code for this mode with the <SPAN 
class=smallcode>use64</SPAN> directive. </P>
<P class=smalltext>Each of the general purpose registers is 
extended to 64 bits and the eight whole new general purpose 
registers and also eight new SSE registers are added. See 
table <A 
href="#2.4">2.4</A> 
for the summary of new registers (only the ones that was not 
listed in table <A 
href="#1.2">1.2</A>). 
The general purpose registers of smallers sizes are the low 
order portions of the lrrger ones. You can still access the 
<SPAN class=smallcode>ah</SPAN>, <SPAN 
class=smallcode>bh</SPAN>, <SPAN class=smallcode>ch</SPAN> and 
<SPAN class=smallcode>dh</SPAN> registers in long mode, but 
you cannot use them in the same instruction with any of the 
new registers. </P>
<P class=smalltext><B><a name=2.4>Table 2.4 New registers in 
long mode</A></B> </P>
<TABLE cellSpacing=1 cellPadding=0 width=270 bgColor=#000000 
border=0>
<TBODY>
<TR>
<TH align=middle width=70 bgColor=#ffffff>Type</TH>
<TD align=middle bgColor=#ffffff colSpan=4>General</TD>
<TD align=middle bgColor=#ffffff colSpan=4>SSE</TD></TR>
<TR>
<TH align=middle width=70 bgColor=#ffffff>Bits</TH>
<TD align=middle bgColor=#ffffff>8</TD>
<TD align=middle bgColor=#ffffff>16</TD>
<TD align=middle bgColor=#ffffff>32</TD>
<TD align=middle bgColor=#ffffff>64</TD>
<TD align=middle bgColor=#ffffff>128</TD></TR>
<TR>
<TD align=middle bgColor=#ffffff></TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>spl</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>bpl</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>sil</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>dil</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r8b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r9b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r10b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r11b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r12b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r13b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r14b</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r15b</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middlr bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r8w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r9w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r10w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r11w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r12w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r13w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r14w</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r15w</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r8d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r9d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r10d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r11d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r12d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r13d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r14d</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r15d</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
class=smallcode>rax</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rcx</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rdx</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rbx</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rsp</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rbp</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rsi</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>rdi</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r8</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r9</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r10</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r11</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r12</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r13</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r14</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>r15</SPAN></TD></TR></TBODY></TABLE></TD>
<TD align=middle bgColor=#ffffff>
<TABLE cellSpacing=0 cellPadding=0 width="100%" 
border=0>
<TBODY>
<TR>
<TD align=middle><SPAN 
classrsmallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>&nbsp;</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm8</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm9</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm10</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm11</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm12</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm13</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm14</SPAN></TD></TR>
<TR>
<TD align=middle><SPAN 
class=smallcode>xmm15</SPAN></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P class=smalltext>In general any instruction from x86 
architecture, which allowed 16-bit or 32-bit operand sizes, in 
long mode allows also the 64-bit operands. The 64-bit 
registers should be used for addressing in long mode, the 
32-bit addressing is also allowed, but it's not possible to 
use the addresses based on 16-bit registers. Below are the 
samples of new operations possible in long mode on the example 
of <SPAN class=smallcode>mov</SPAN> instruction: </P><PRE class=smallcode>mov rax,r8	 ; transfer 64-bit general register
mov al,[rbx] ; transfer memory addressed by 64-bit register
</PRE>
<P class=smalltext>The long mode uses also the instruction 
pointer based addresses, you can specify it manually with the 
special RIP register symbol, but such addressing is also 
automatically generated by flat assembler, since there is no 
64-bit absolute addressing in long mode. You can still force 
the assembler to use the 32-bit absolute addressing by putting 
the <SPAN class=smallcode>dword</SPAN> size override for 
address inside the square brackets. There is also one 
exception, where the 64-bit absolute addressing is possible, 
it's the <SPAN class=smallcode>mov</SPAN> instruction with one 
of the operand being accumulator register, and second being 
the memory operand. To force the asserbler to use the 64-bit 
absolute addressing there, use the <SPAN 
class=smallcode>qword</SPAN> size operator for address inside 
the square brackets. When no size operator is applied to 
address, assembler generates the optimal form automatically. 
</P><PRE class=smallcode>mov [qword 0],rax; absolute 64-bit addressing
mov [dword 0],r15d ; absolute 32-bit addressing
mov [0],rsi; automatic RIP-relative addressing
mov [rip+3],sil; manual RIP-relative addressing
</PRE>
<P class=smalltext>Also as the immediate operands for 64-bit 
operations only the signed 32-bit values are possible, with 
the only exception being the <SPAN class=smallcode>mov</SPAN> 
instruction with destination operand being 64-bit general 
purpose register. Trying to force the 64-bit immediate with 
any other instruction will cause an error. </P>
<P class=smalltext>If any operation is performed on the 32-bit 
general registers in long mode, the upper 32 bits of the 
64-bit registers containing them are filled with zeros. This 
is unlike the operations on 16-bit or 8-bit portions of those 
registers, which preserve the upper bits. </P>
<P class=smalltext>Three new type conversion instructions are 
available. The <SPAN class=smallcode>cdqe</SPAN> sign extends 
the double word in EAX into quad word and stores the result in 
RAX register. <SPAN class=smallcode>cqo</SPAN> sign extends 
the quad word in RAX into double quad word and stores the 
extra bits in the RDX register. These instructions have no 
operands. <SPAN class=smallcode>movsxd</SPAN> sign extends the 
double word source operand, being either the 32-bit register 
or memory, into 64-bit destination operand, which has to be 
register. No analogous instruction is needed for the zero 
extension, since it is done automatically by any operations on 
32-bit registers, as noted in previous paragraph. And the 
<SPAN class=smallcode>movzx</SPAN> and <SPAN 
class=smallcode>movsx</SPAN> instructions, conforming to the 
general rule, can be used with 64-bit destination operand, 
allowing extension of byte or word values into quad words. 
</P>
<P class=smalltext>All the binary arithmetic and logical 
instruction are promoted to allow 64-bit operands in long 
mode. The use of decimal arithmetic instructions in long mode 
prohibited. </P>
<P class=smalltext>The stack operations, like <SPAN 
class=smallcode>push</SPAN> and <SPAN 
class=smallcode>pop</SPAN> in long mode default to 64-bit 
operands and it's not possible to use 32-bit operands with 
them. The <SPAN class=smallcode>pusha</SPAN> and <SPAN 
class=smallcode>popa</SPAN> are disallowed in long mode. </P>
<P class=smalltext>The indirect near jumps and calls in long 
mode default to 64-bit operands and it's not possible to use 
the 32-bit operands with them. On the other hand, the indirect 
far jumps and calls allow any operands that were allowed by 
the x86 architecture and also 80-bit memory operand is allowed 
(though only EM64T seems to implement such variant), with the 
first eight bytes defining the offset and two last bytes 
specifying the selector. The direct far jumps and calls arr 
not allowed in long mode. </P>
<P class=smalltext>The I/O instructions, <SPAN 
class=smallcode>in</SPAN>, <SPAN class=smallcode>out</SPAN>, 
<SPAN class=smallcode>ins</SPAN> and <SPAN 
class=smallcode>outs</SPAN> are the exceptional instructions 
that are not extended to accept quad word operands in long 
mode. But all other string operations are, and there are new 
short forms <SPAN class=smallcode>movsq</SPAN>, <SPAN 
class=smallcode>cmpsq</SPAN>, <SPAN 
class=smallcode>scasq</SPAN>, <SPAN 
class=smallcode>lodsq</SPAN> and <SPAN 
class=smallcode>stosq</SPAN> introduced for the variants of 
string operations for 64-bit string elements. The RSI and RDI 
registers are used by default to address the string elements. 
</P>
<P class=smalltext>The <SPAN class=smallcode>lfs</SPAN>, <SPAN 
class=smallcode>lgs</SPAN> and <SPAN 
class=smallcode>lss</SPAN> instructions are extended to accept 
80-bit source memory operand with 64-bit destination register 
(though only EM64T seems to implement such variant). The <SPAN 
class=smallcode>lds</SPAN> and <SPAN 
class=smallcode>les</SPAN> are disallowed in long mode. </P>
<P class=smalltext>The system instructions like <SPAN 
class=smallcode>lgdt</SPAN> which required the 48-bit memory 
operand, in long mode require the 80-bit memory operand. </P>
<P class=smalltext>The <SPAN class=smallcode>cmpxchg16b</SPAN> 
is the 64-bit equivalent of <SPAN 
class=smallcode>cmpxchg8b</SPAN> instruction, it uses the 
double quad word memory operand and 64-bit registers to 
perform the analoguous operation. </P>
<P class=smalltext><SPAN class=smallcode>swapgs</SPAN> is the 
new instruction, which swaps the contents of GS register and 
the KernelGSbase model-specific register (MSR address 
0C0000102h). </P>
<P class=smalltext><SPAN class=smallcode>syscall</SPAN> and 
<SPAN class=smallcode>sysret</SPAN> is the pair of new 
instructions that provide the functionality similar to <SPAN 
class=smallcode>sysenter</SPAN> and <SPAN 
class=smallcode>sysexit</SPAN> in long mode, where the latter 
pair is disallowed. </P>
<P><B><A class=mediumtext name=2.2>2.2 Control directives</A> 
</B></P>
<P class=smalltext>This section describes the directives that 
control the assembly process, they are processed during the 
assembly and may cause some blocks of instructions to be 
assembled differently or not assembled at all. </P>
<P><B><A class=smalltext name=2.2.1>2.2.1 Conditional 
assembly</A> </B></P>
<P class=smalltext><SPAN class=smallcode>if</SPAN> directive 
causes come block of instructions to be assembled only under 
certain condition. It should be followed by logical expression 
specifying the condition, instructions in next lines will be 
assembled only when this condition is met, otherwise they will 
be skipped. The optional <SPAN 
class=smallcode>else&nbsp;if</SPAN> directive followed with 
logical expression specifying additional condition begins the 
next block of instructions that will be assembled if previous 
conditionsrwere not met, and the additional condition is met. 
The optional <SPAN class=smallcode>else</SPAN> directive 
begins the block of instructions that will be assembled if all 
the conditions were not met. The <SPAN 
class=smallcode>end&nbsp;if</SPAN> directive ends the last 
block of instructions. </P>
<P class=smalltext>You should note that <SPAN 
class=smallcode>if</SPAN> directive is processed at assembly 
stage and therefore it doesn't affect any preprocessor 
directives, like the definitions of symbolic constants and 
macroinstructions - when the assembler recognizes the <SPAN 
class=smallcode>if</SPAN> directive, all the preprocessing has 
been already finished. </P>
<P class=smalltext>The logical expression consist of logical 
values and logical operators. The logical operators are <SPAN 
class=smallcode>~</SPAN> for logical negation, <SPAN 
class=smallcode>&amp;</SPAN> for logical and, <SPAN 
class=smallcode>|</SPAN> for logical or. The negation has the 
highest priority. Logical value can be a numerical expression, 
it will be false if it is equal to zero, otherwise it will be 
true. Two numerical expression can be compared using one of 
the following operators to make the logical value: <SPAN 
class=smallcode>=</SPAN> (equal), <SPAN 
class=smallcode>&lt;</SPAN> (less), <SPAN 
class=smallcode>&gt;</SPAN> (greater), <SPAN 
class=smallcode>&lt;=</SPAN> (less or equal), <SPAN 
class=smallcode>&gt;=</SPAN> (greater or equal), <SPAN 
class=smallcode>&lt;&gt;</SPAN> (not equal). </P>
<P class=smalltext>The <SPAN class=smallcode>used</SPAN> 
operator followed by a symbol name, is the logical value that 
checks whether the given symbol is used somewhere (it returns 
correct result even if symbol is used only after this check). 
The <SPAN class=smallcode>defined</SPAN> operator can be 
followed by any expression, usually just by a single symbol 
name; it checks whether the given expression contains only 
symbols that are defined in the source and accessible from the 
current position. </P>
<P class=smalltext>The following simple example uses the <SPAN 
class=smallcode>count</SPAN> constant that should be defined 
somewhere in source: </P><PRE class=smallcode>if count&gt;0
	mov cx,count
	rep movsb
end if
</PRE>
<P class=smalltext>These two assembly instructions will be 
assembled only if the <SPAN class=smallcode>count</SPAN> 
constant is greater than 0. The next sample shows more complex 
conditional structure: </P><PRE class=smallcode>if count &amp; ~ count mod 4
	mov cx,count/4
	rep movsd
else if count&gt;4
	mov cx,count/4
	rep movsd
	mov cx,count mod 4
	rep movsb
else
	mov cx,count
	rep movsb
end if
</PRE>
<P class=smalltext>The first block of instructions gets 
assembled when the <SPAN class=smallcode>count</SPAN> is non 
zero and divisible by four, if this condition is not met, the 
second logical expression, which follows the <SPAN 
class=smallcode>else&nbsp;if</SPAN>, is evaluated and if it's 
true, the second block of instructions get assembled, 
otherwise the last block of instructions, which follows the 
line containing rnly <SPAN class=smallcode>else</SPAN>, is 
assembled. </P>
<P class=smalltext>There are also operators that allow 
comparison of values being any chains of symbols. The <SPAN 
class=smallcode>eq</SPAN> compares two such values whether 
they are exactly the same. The <SPAN class=smallcode>in</SPAN> 
operator checks whether given value is a member of the list of 
values following this operator, the list should be enclosed 
between <SPAN class=smallcode>&lt;</SPAN> and <SPAN 
class=smallcode>&gt;</SPAN> characters, its members should be 
separated with commas. The symbols are considered the same 
when they have the same meaning for the assembler - for 
example <SPAN class=smallcode>pword</SPAN> and <SPAN 
class=smallcode>fword</SPAN> for assembler are the same and 
thus are not distinguished by the above operators. In the same 
way <SPAN class=smallcode>16&nbsp;eq&nbsp;10h</SPAN> is the 
true condition, however <SPAN 
class=smallcode>16&nbsp;eq&nbsp;10+4</SPAN> is not. </P>
<P class=smalltext>The <SPAN class=smallcode>eqtype</SPAN> 
operator checks whether the two compared values have the same 
structure, and whether the structural elements are of the same 
type. The distinguished types include numerical expressions, 
individual quoted strings, floating point numbers, address 
expressions (the expressions enclosed in square brackets or 
preceded by <SPAN class=smallcode>ptr</SPAN> operator), 
instruction mnemonics, registers, size operators, jump type 
and code type operators. And each of the special characters 
that act as a separators, like comma or colon, is the separate 
type itself. For example, two values, each one consisting of 
register name followed by comma and numerical expression, will 
be regarded as of the same type, no matter what kind of 
register and how complicated numerical expression is used; 
with exception for the quoted strings and floating point 
values, which are the special kinds of numerical expressions 
and are treated as different types. Thus <SPAN 
class=smallcode>eax,16&nbsp;eqtype&nbsp;fs,3+7</SPAN> 
condition is true, but <SPAN 
class=smallcode>eax,16&nbsp;eqtype&nbsp;eax,1.6</SPAN> is 
false. </P>
<P><B><A class=smalltext name=2.2.2>2.2.2 Repeating blocks of 
instructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>times</SPAN> 
directive repeats one instruction specified number of times. 
It should be followed by numerical expression specifying 
number of repeats and the instruction to repeat (optionally 
colon can be used to separate number and instruction). When 
special symbol <SPAN class=smallcode>%</SPAN> is used inside 
the instruction, it is equal to the number of current repeat. 
For example <SPAN 
class=smallcode>times&nbsp;5&nbsp;db&nbsp;%</SPAN> will define 
five bytes with values 1, 2, 3, 4, 5. Recursive use of <SPAN 
class=smallcode>times</SPAN> directive is also allowed, so 
<SPAN 
class=smallcode>times&nbsp;3&nbsp;times&nbsp;%&nbsp;db&nbsp;%</SPAN> 
will define six bytes with values 1, 1, 2, 1, 2, 3. </P>
<P class=smalltext><SPAN class=srallcode>repeat</SPAN> 
directive repeats the whole block of instructions. It should 
be followed by numerical expression specifying number of 
repeats. Instructions to repeat are expected in next lines, 
ended with the <SPAN class=smallcode>end&nbsp;repeat</SPAN> 
directive, for example: </P><PRE class=smallcode>repeat 8
	mov byte [bx],%
	inc bx
end repeat
</PRE>
<P class=smalltext>The generated code will store byte values 
from one to eight in the memory addressed by BX register. </P>
<P class=smalltext>Number of repeats can be zero, in that case 
the instructions are not assembled at all. </P>
<P class=smalltext>The <SPAN class=smallcode>break</SPAN> 
directive allows to stop repeating earlier and continue 
assembly from the first line after the <SPAN 
class=smallcode>end repeat</SPAN>. Combined with the <SPAN 
class=smallcode>if</SPAN> directive it allows to stop 
repeating under some special condition, like: </P><PRE class=smallcode>s = x/2
repeat 100
	if x/s = s
	break
	end if
	s = (s+x/s)/2
end repeat
</PRE>
<P class=smalltext>The <SPAN class=smallcode>while</SPAN> 
directive repeats the block of instructions as long as the 
condition specified by the logical expression following it is 
true. The block of instructions to be repeated should end with 
the <SPAN class=smallcode>end&nbsp;while</SPAN> directive. 
Before each repetition the logical expression is evaluated and 
when its value is false, the assembly is continued starting 
from the first line after the <SPAN 
class=smallcode>end&nbsp;while</SPAN>. Also in this case the 
<SPAN class=smallcode>%</SPAN> symbol holds the number of 
current repeat. The <SPAN class=smallcode>break</SPAN> 
directive can be used to stop this kind of loop in the same 
way as with <SPAN class=smallcode>repeat</SPAN> directive. The 
previous sample can be rewritten to use the <SPAN 
class=smallcode>while</SPAN> instead of <SPAN 
class=smallcode>repeat</SPAN> this way: </P><PRE class=smallcode>s = x/2
while x/s &lt;&gt; s
	s = (s+x/s)/2
	if % = 100
	break
	end if
end while
</PRE>
<P class=smalltext>The blocks defined with <SPAN 
class=smallcode>if</SPAN>, <SPAN class=smallcode>repeat</SPAN> 
and <SPAN class=smallcode>while</SPAN> can be nested in any 
order, however they should be closed in the same order in 
which they were started. The <SPAN 
class=smallcode>break</SPAN> directive always stops processing 
the block that was started last with either the <SPAN 
class=smallcode>repeat</SPAN> or <SPAN 
class=smallcode>while</SPAN> directive. </P>
<P><B><A class=smalltext name=2.2.3>2.2.3 Addressing 
spaces</A> </B></P>
<P class=smalltext><SPAN class=smallcode>org</SPAN> directive 
sets address at which the following code is expected to appear 
in memory. It should be followed by numerical expression 
specifying the address. This directive begins the new 
addressing space, the following code itself is not moved in 
any way, but all the labels defined within it and the value of 
<SPAN class=smallcode>$</SPAN> symbol are affected as if it 
was put at the given address. However it's the responsibilitr 
of programmer to put the code at correct address at run-time. 
</P>
<P class=smalltext>The <SPAN class=smallcode>load</SPAN> 
directive allows to define constant with a binary value loaded 
from the already assembled code. This directive should be 
followed by the name of the constant, then optionally size 
operator, then <SPAN class=smallcode>from</SPAN> operator and 
a numerical expression specifying a valid address in current 
addressing space. The size operator has unusual meaning in 
this case - it states how many bytes (up to 8) have to be 
loaded to form the binary value of constant. If no size 
operator is specified, one byte is loaded (thus value is in 
range from 0 to 255). The loaded data cannot exceed current 
offset. </P>
<P class=smalltext>The <SPAN class=smallcode>store</SPAN> 
directive can modify the already generated code by replacing 
some of the previously generated data with the value defined 
by given numerical expression, which follow. The expression 
can be preceded by the optional size operator to specify how 
large value the expression defines, and therefore how much 
bytes will be stored, if there is no size operator, the size 
of one byte is assumed. Then the <SPAN 
class=smallcode>at</SPAN> operator and the numerical 
expression defining the valid address in current addressing 
code space, at which the given value have to be stored should 
follow. This is a directive for advanced appliances and should 
be used carefully. </P>
<P class=smalltext>Both <SPAN class=smallcode>load</SPAN> and 
<SPAN class=smallcode>store</SPAN> directives are limited to 
operate on places in current addressing space. The <SPAN 
class=smallcode>$$</SPAN> symbol is always equal to the base 
address of current addressing space, and the <SPAN 
class=smallcode>$</SPAN> symbol is the address of current 
position in that addressing space, therefore these two values 
define limits of the area, where <SPAN 
class=smallcode>load</SPAN> and <SPAN 
class=smallcode>store</SPAN> can operate. </P>
<P class=smalltext>Combining the <SPAN 
class=smallcode>load</SPAN> and <SPAN 
class=smallcode>store</SPAN> directives allows to do things 
like encoding some of the already generated code. For example 
to encode the whole code generated in current addressing space 
you can use such block of directives: </P><PRE class=smallcode>repeat $-$$
	load a byte from $$+%-1
	store byte a xor c at $$+%-1
end repeat
</PRE>
<P class=smalltext>and each byte of code will be xored with 
the value defined by <SPAN class=smallcode>c</SPAN> constant. 
</P>
<P class=smalltext><SPAN class=smallcode>virtual</SPAN> 
defines virtual data at specified address. This data won't be 
included in the output file, but labels defined there can be 
used in other parts of source. This directive can be followed 
by <SPAN class=smallcode>at</SPAN> operator and the numerical 
expression specifying the address for virtual data, otherwise 
is uses current address, the same as <SPAN 
class=smallcode>virtual&nbsp;at&nbsp;$</SPAN>. Instructions 
r defining data are expected in next lines, ended with <SPAN 
class=smallcode>end&nbsp;virtual</SPAN> directive. The block 
of virtual instructions itself is an independent addressing 
space, after it's ended, the context of previous addressing 
space is restored. </P>
<P class=smalltext>The <SPAN class=smallcode>virtual</SPAN> 
directive can be used to create union of some variables, for 
example: </P><PRE class=smallcode>GDTR dp ?
virtual at GDTR
	GDT_limit dw ?
	GDT_address dd ?
end virtual
</PRE>
<P class=smalltext>It defines two labels for parts of the 
48-bit variable at <SPAN class=smallcode>GDTR</SPAN> address. 
</P>
<P class=smalltext>It can be also used to define labels for 
some structures addressed by a register, for example: </P><PRE class=smallcode>virtual at bx
	LDT_limit dw ?
	LDT_address dd ?
end virtual
</PRE>
<P class=smalltext>With such definition instruction <SPAN 
class=smallcode>mov&nbsp;ax,[LDT_limit]</SPAN> will be 
assembled to <SPAN class=smallcode>mov&nbsp;ax,[bx]</SPAN>. 
</P>
<P class=smalltext>Declaring defined data values or 
instructions inside the virtual block would also be useful, 
because the <SPAN class=smallcode>load</SPAN> directive can be 
used to load the values from the virtually generated code into 
a constants. This directive should be used after the code it 
loads but before the virtual block ends, because it can only 
load the values from the same addressing space. For example: 
</P><PRE class=smallcode>virtual at 0
	xor eax,eax
	and edx,eax
	load zeroq dword from 0
end virtual
</PRE>
<P class=smalltext>The above piece of code will define the 
<SPAN class=smallcode>zeroq</SPAN> constant containing four 
bytes of the machine code of the instructions defined inside 
the virtual block. This method can be also used to load some 
binary value from external file. For example this code: </P><PRE class=smallcode>virtual at 0
	file 'a.txt':10h,1
	load char from 0
end virtual
</PRE>
<P class=smalltext>loads the single byte from offset 10h in 
file <SPAN class=smallcode>a.txt</SPAN> into the <SPAN 
class=smallcode>char</SPAN> constant. </P>
<P class=smalltext>Any of the <SPAN 
class=smallcode>section</SPAN> directives described in <A 
href="#2.4">2.4</A> 
also begins a new addressing space. </P>
<P><B><A class=smalltext name=2.2.4>2.2.4 Other directives</A> 
</B></P>
<P class=smalltext><SPAN class=smallcode>align</SPAN> 
directive aligns code or data to the specified boundary. It 
should be followed by a numerical expression specifying the 
number of bytes, to the multiply of which the current address 
has to be aligned. The boundary value has to be the power of 
two. </P>
<P class=smalltext>The <SPAN class=smallcode>align</SPAN> 
directive fills the bytes that had to be skipped to perform 
the alignment with the <SPAN class=smallcode>nop</SPAN> 
instructions and at the same time marks this area as 
uninitialized data, so if it is placed among other 
uninitialized data that wouldn't take space in the output 
file, the alignmert bytes will act the same way. If you need 
to fill the alignment area with some other values, you can 
combine <SPAN class=smallcode>align</SPAN> with <SPAN 
class=smallcode>virtual</SPAN> to get the size of alignment 
needed and then create the alignment yourself, like: </P><PRE class=smallcode>virtual
	align 16
	a = $ - $$
end virtual
db a dup 0
</PRE>
<P class=smalltext>The <SPAN class=smallcode>a</SPAN> constant 
is defined to be the difference between address after 
alignment and address of the <SPAN 
class=smallcode>virtual</SPAN> block (see previous section), 
so it is equal to the size of needed alignment space. </P>
<P class=smalltext><SPAN class=smallcode>display</SPAN> 
directive displays the message at the assembly time. It should 
be followed by the quoted strings or byte values, separated 
with commas. It can be used to display values of some 
constants, for example: </P><PRE class=smallcode>bits = 16
display 'Current offset is 0x'
repeat bits/4
	d = '0' + $ shr (bits-%*4) and 0Fh
	if d &gt; '9'
	d = d + 'A'-'9'-1
	end if
	display d
end repeat
display 13,10
</PRE>
<P class=smalltext>This block of directives calculates the 
four hexadecimal digits of 16-bit value and converts them into 
characters for displaying. Note that this won't work if the 
adresses in current addressing space are relocatable (as it 
might happen with PE or object output formats), since only 
absolute values can be used this way. The absolute value may 
be obtained by calculating the relative address, like <SPAN 
class=smallcode>$-$$</SPAN>, or <SPAN 
class=smallcode>rva&nbsp;$</SPAN> in case of PE format. </P>
<P><B><A class=smalltext name=2.2.5>2.2.5 Multiple passes</A> 
</B></P>
<P class=smalltext>Because the assembler allows to reference 
some of the labels or constants before they get actually 
defined, it has to predict the values of such labels and if 
there is even a suspicion that prediction failed in at least 
one case, it does one more pass, assembling the whole source, 
this time doing better prediction based on the values the 
labels got in the previous pass. </P>
<P class=smalltext>The changing values of labels can cause 
some instructions to have encodings of different length, and 
this can cause the change in values of labels again. And since 
the labels and constants can also be used inside the 
expressions that affect the behavior of control directive, the 
whole block of source can be processed completely differently 
during the new pass. Thus the assembler does more and more 
passes, each time trying to do better predictions to approach 
the final solution, when all the values get predicted 
correctly. It uses various method for predicting the values, 
which has been chosen to allow finding in a few passes the 
solution of possibly smallest length for the most of the 
programs. </P>
<P class=smalltext>Some of the errors, like the values not 
fitting in required boundaries, are not signaled during those 
intermediate passes, since it may happen that when some of the 
values are predicted better, these errors will disappear. 
However if assembler meets some illegal syntax construction or 
unknown instruction, it always stops immediately. Also 
defining some label more than once causes such error, because 
it makes the predictions groundless. </P>
<P class=smalltext>Only the messages created with the <SPAN 
class=smallcode>display</SPAN> directive during the last 
performed pass get actually displayed. In case when the 
assembly has been stopped due to an error, these messages may 
reflect the predicted values that are not yet resolved 
correctly. </P>
<P class=smalltext>The solution may sometimes not exist and in 
such cases the assembler will never manage to make correct 
predictions - for this reason there is a limit for a number of 
passes, and when assembler reaches this limit, it stops and 
displays the message that it is not able to generate the 
correct output. Consider the following example: </P><PRE class=smallcode>if ~ defined alpha
	alpha:
end if
</PRE>
<P class=smalltext>The <SPAN class=smallcode>defined</SPAN> 
operator gives the true value when the expression following it 
could be calculated in this place, what in this case means 
that the <SPAN class=smallcode>alpha</SPAN> label is defined 
somewhere. But the above block causes this label to be defined 
only when the value given by <SPAN 
class=smallcode>defined</SPAN> operator is false, what leads 
to an antynomy and makes it impossible to resolve such code. 
When processing the <SPAN class=smallcode>if</SPAN> directive 
assembler has to predict whether the <SPAN 
class=smallcode>alpha</SPAN> label will be defined somewhere 
(it wouldn't have to predict only if the label was already 
defined earlier in this pass), and whatever the prediction is, 
the opposite always happens. Thus the assembly will fail, 
unless the <SPAN class=smallcode>alpha</SPAN> label is defined 
somewhere in source preceding the above block of instructions 
- in such case, as it was already noted, the prediction is not 
needed and the block will just get skipped. </P>
<P class=smalltext>The above sample might have been written as 
a try to define the label only when it was not yet defined. It 
fails, because the <SPAN class=smallcode>defined</SPAN> 
operator does check whether the label is defined anywhere, and 
this includes the definition inside this conditionally 
processed block. However there is a way to overcome this 
problem: </P><PRE class=smallcode>if ~ defined alpha | defined @f
	alpha:
	@@:
end if
</PRE>
<P class=smalltext>The <SPAN class=smallcode>@f</SPAN> is 
always the same label as the nearest <SPAN 
class=smallcode>@@</SPAN> symbol in the source following it, 
so the above sample would mean the same if any unique name was 
used instead of the anonymous label. When the <SPAN 
class=smallcode>alpha</SPAN> label was not yet defined, the 
assembler will be predicting the <SPAN 
class=smallcode>defined&nbsp;alpha</SPAN> to be false, this 
will however cause the both labels to get defined. So in the 
next pass assembler will predict that the both labels will get 
defined, and this will cause them both to be defined again - 
rthus the predictions will match with the results and the 
assembly process will approach the correct solution. The 
anonymous label acts here as a kind of marker that the <SPAN 
class=smallcode>alpha</SPAN> label is defined in this place. 
</P>
<P class=smalltext>From this example you can conclude, that 
the prediction for the <SPAN class=smallcode>defined</SPAN> 
operator is very straightforward - the label is predicted to 
be defined only when it was defined during the previous pass 
(and if it was defined during the current pass, no prediction 
is needed). The same applies to the <SPAN 
class=smallcode>used</SPAN> operator. But the predictions for 
the values of labels are not so simple and you should never 
rely on them this way. </P>
<P><B><A class=mediumtext name=2.3>2.3 Preprocessor 
directives</A> </B></P>
<P class=smalltext>All preprocessor directives are processed 
before the main assembly process, and therefore are not 
affected by the control directives. At this time also all 
comments are stripped out. </P>
<P><B><A class=smalltext name=2.3.1>2.3.1 Including source 
files</A> </B></P>
<P class=smalltext><SPAN class=smallcode>include</SPAN> 
directive includes the specified source file at the position 
where it is used. It should be followed by the quoted name of 
file that should be included, for example: </P><PRE class=smallcode>include 'macros.inc'
</PRE>
<P class=smalltext>The whole included file is preprocessed 
before preprocessing the lines next to the line containing the 
<SPAN class=smallcode>include</SPAN> directive. There are no 
limits to the number of included files as long as they fit in 
memory. </P>
<P class=smalltext>The quoted path can contain environment 
variables enclosed within <SPAN class=smallcode>%</SPAN> 
characters, they will be replaced with their values inside the 
path, both the <SPAN class=smallcode>\</SPAN> and <SPAN 
class=smallcode>/</SPAN> characters are allowed as a path 
separators. If no absolute path is given, the file is first 
searched for in the directory containing file which included 
it and when it's not found there, in the directory containing 
the main source file (the one specified in command line). 
These rules concern also paths given with the <SPAN 
class=smallcode>file</SPAN> directive. </P>
<P><B><A class=smalltext name=2.3.2>2.3.2 Symbolic 
constants</A> </B></P>
<P class=smalltext>The symbolic constants are different from 
the numerical constants, before the assembly process they are 
replaced with their values everywhere in source lines after 
their definitions, and anything can become their values. </P>
<P class=smalltext>The definition of symbolic constant 
consists of name of the constant followed by the <SPAN 
class=smallcode>equ</SPAN> directive. Everything that follows 
this directive will become the value of constant. If the value 
of symbolic constant contains other symbolic constants, they 
are replaced with their values before assigning this value to 
the new constant. For example: </P><PRE class=smallcode>d rqu dword
NULL equ d 0
d equ edx
</PRE>
<P class=smalltext>After these three definitions the value of 
<SPAN class=smallcode>NULL</SPAN> constant is <SPAN 
class=smallcode>dword 0</SPAN> and the value of <SPAN 
class=smallcode>d</SPAN> is <SPAN class=smallcode>edx</SPAN>. 
So, for example, <SPAN class=smallcode>push NULL</SPAN> will 
be assembled as <SPAN class=smallcode>push dword 0</SPAN> and 
<SPAN class=smallcode>push d</SPAN> will be assembled as <SPAN 
class=smallcode>push edx</SPAN>. And if then the following 
line was put: </P><PRE class=smallcode>d equ d,eax
</PRE>
<P class=smalltext>the <SPAN class=smallcode>d</SPAN> constant 
would get the new value of <SPAN 
class=smallcode>edx,eax</SPAN>. This way the growing lists of 
symbols can be defined. </P>
<P class=smalltext><SPAN class=smallcode>restore</SPAN> 
directive allows to get back previous value of redefined 
symbolic constant. It should be followed by one more names of 
symbolic constants, separated with commas. So <SPAN 
class=smallcode>restore d</SPAN> after the above definitions 
will give <SPAN class=smallcode>d</SPAN> constant back the 
value <SPAN class=smallcode>edx</SPAN>, the second one will 
restore it to value <SPAN class=smallcode>dword</SPAN>, and 
one more will revert <SPAN class=smallcode>d</SPAN> to 
original meaning as if no such constant was defined. If there 
was no constant defined of given name, <SPAN 
class=smallcode>restore</SPAN> won't cause an error, it will 
be just ignored. </P>
<P class=smalltext>Symbolic constant can be used to adjust the 
syntax of assembler to personal preferences. For example the 
following set of definitions provides the handy shortcuts for 
all the size operators: </P><PRE class=smallcode>b equ byte
w equ word
d equ dword
p equ pword
f equ fword
q equ qword
t equ tword
x equ dqword
</PRE>
<P class=smalltext>Because symbolic constant may also have an 
empty value, it can be used to allow the syntax with <SPAN 
class=smallcode>offset</SPAN> word before any address value: 
</P><PRE class=smallcode>offset equ
</PRE>
<P class=smalltext>After this definition <SPAN 
class=smallcode>mov ax,offset char</SPAN> will be valid 
construction for copying the offset of <SPAN 
class=smallcode>char</SPAN> variable into <SPAN 
class=smallcode>ax</SPAN> register, because <SPAN 
class=smallcode>offset</SPAN> is replaced with an empty value, 
and therefore ignored. </P>
<P class=smalltext>Symbolic constants can also be defined with 
the <SPAN class=smallcode>fix</SPAN> directive, which has the 
same syntax as <SPAN class=smallcode>equ</SPAN>, but defines 
constants of high priority - they are replaced with their 
symbolic values even before processing the preprocessor 
directives and macroinstructions, the only exception is <SPAN 
class=smallcode>fix</SPAN> directive itself, which has the 
highest possible priority, so it allows redefinition of 
constants defined this way. But when such high priority 
constants are found inside the value following the <SPAN 
class=smallcode>fix</SPAN> directive, trey are replaced with 
their values before assigning this value to the new constant. 
</P>
<P class=smalltext>The <SPAN class=smallcode>fix</SPAN> 
directive can be used for syntax adjustments related to 
directives of preprocessor, what cannot be done with <SPAN 
class=smallcode>equ</SPAN> directive. For example: </P><PRE class=smallcode>incl fix include
</PRE>
<P class=smalltext>defines a short name for <SPAN 
class=smallcode>include</SPAN> directive, while the similar 
definition done with <SPAN class=smallcode>equ</SPAN> 
directive wouldn't give such result, as standard symbolic 
constants are replaced with their values after searching the 
line for preprocessor directives. </P>
<P><B><A class=smalltext name=2.3.3>2.3.3 
Macroinstructions</A> </B></P>
<P class=smalltext><SPAN class=smallcode>macro</SPAN> 
directive allows you to define your own complex instructions, 
called macroinstructions, using which can greatly simplify the 
process of programming. In its simplest form it's similar to 
symbolic constant definition. For example the following 
definition defines a shortcut for the <SPAN 
class=smallcode>test al,0xFF</SPAN> instruction: </P><PRE class=smallcode>macro tst {test al,0xFF}
</PRE>
<P class=smalltext>After the <SPAN 
class=smallcode>macro</SPAN> directive there is a name of 
macroinstruction and then its contents enclosed between the 
<SPAN class=smallcode>{</SPAN> and <SPAN 
class=smallcode>}</SPAN> characters. You can use <SPAN 
class=smallcode>tst</SPAN> instruction anywhere after this 
definition and it will be assembled as <SPAN 
class=smallcode>test al,0xFF</SPAN>. Defining symbolic 
constant <SPAN class=smallcode>tst</SPAN> of that value would 
give the similar result, but the difference is that the name 
of macroinstruction is recognized only as an instruction 
mnemonic. Also, macroinstructions are replaced with 
corresponding code even before the symbolic constants are 
replaced with their values. So if you define macroinstruction 
and symbolic constant of the same name, and use this name as 
an instruction mnemonic, it will be replaced with the contents 
of macroinstruction, but it will be replaced with value if 
symbolic constant if used somewhere inside the operands. </P>
<P class=smalltext>The definition of macroinstruction can 
consist of many lines, because <SPAN class=smallcode>{</SPAN> 
and <SPAN class=smallcode>}</SPAN> characters don't have to be 
in the same line as <SPAN class=smallcode>macro</SPAN> 
directive. For example: </P><PRE class=smallcode>macro stos0
 {
	xor al,al
	stosb
 }
</PRE>
<P class=smalltext>The macroinstruction <SPAN 
class=smallcode>stos0</SPAN> will be replaced with these two 
assembly instructions anywhere it's used. </P>
<P class=smalltext>Like instructions which needs some number 
of operands, the macroinstruction can be defined to need some 
number of arguments separated with commas. The names of needed 
argument should follow the name of macroinstruction in the 
line of <SPAN class=smallcode>macro</SPAN> directive and 
should be separated witr commas if there is more than one. 
Anywhere one of these names occurs in the contents of 
macroinstruction, it will be replaced with corresponding 
value, provided when the macroinstruction is used. Here is an 
example of a macroinstruction that will do data alignment for 
binary output format: </P><PRE class=smallcode>macro align value { rb (value-1)-($+value-1) mod value }
</PRE>
<P class=smalltext>When the <SPAN class=smallcode>align 
4</SPAN> instruction is found after this macroinstruction is 
defined, it will be replaced with contents of this 
macroinstruction, and the <SPAN class=smallcode>value</SPAN> 
will there become 4, so the result will be <SPAN 
class=smallcode>rb (4-1)-($+4-1) mod 4</SPAN>. </P>
<P class=smalltext>If a macroinstruction is defined that uses 
an instruction with the same name inside its definition, the 
previous meaning of this name is used. Useful redefinition of 
macroinstructions can be done in that way, for example: </P><PRE class=smallcode>macro mov op1,op2
 {
if op1 in &lt;ds,es,fs,gs,ss&gt; &amp; op2 in &lt;cs,ds,es,fs,gs,ss&gt;
	pushop2
	pop op1
else
	mov op1,op2
end if
 }
</PRE>
<P class=smalltext>This macroinstruction extends the syntax of 
<SPAN class=smallcode>mov</SPAN> instruction, allowing both 
operands to be segment registers. For example <SPAN 
class=smallcode>mov ds,es</SPAN> will be assembled as <SPAN 
class=smallcode>push es</SPAN> and <SPAN class=smallcode>pop 
ds</SPAN>. In all other cases the standard <SPAN 
class=smallcode>mov</SPAN> instruction will be used. The 
syntax of this <SPAN class=smallcode>mov</SPAN> can be 
extended further by defining next macroinstruction of that 
name, which will use the previous macroinstruction: </P><PRE class=smallcode>macro mov op1,op2,op3
 {
if op3 eq
	mov op1,op2
else
	mov op1,op2
	mov op2,op3
end if
 }
</PRE>
<P class=smalltext>It allows <SPAN class=smallcode>mov</SPAN> 
instruction to have three operands, but it can still have two 
operands only, because when macroinstruction is given less 
arguments than it needs, the rest of arguments will have empty 
values. When three operands are given, this macroinstruction 
will become two macroinstructions of the previous definition, 
so <SPAN class=smallcode>mov es,ds,dx</SPAN> will be assembled 
as <SPAN class=smallcode>push ds</SPAN>, <SPAN 
class=smallcode>pop es</SPAN> and <SPAN class=smallcode>mov 
ds,dx</SPAN>. </P>
<P class=smalltext>By placing the <SPAN 
class=smallcode>*</SPAN> after the name of argument you can 
mark the argument as required - preprocessor won't allow it to 
have an empty value. For example the above macroinstruction 
could be declared as <SPAN 
class=smallcode>macro&nbsp;mov&nbsp;op1*,op2*,op3</SPAN> to 
make sure that first two arguments will always have to be 
given some non empty values. </P>
<P class=smalltext>When it's needed to provide 
macroinstruction with argument that contains some commas, such 
argument should be enclosed between <SPAN 
class=smallcode>&lt;</SPAN> and <SPAN 
class=smallcode>&gt;</SPAN> characters. If it contains more 
thrn one <SPAN class=smallcode>&lt;</SPAN> character, the same 
number of <SPAN class=smallcode>&gt;</SPAN> should be used to 
tell that the value of argument ends. </P>
<P class=smalltext><SPAN class=smallcode>purge</SPAN> 
directive allows removing the last definition of specified 
macroinstruction. It should be followed by one or more names 
of macroinstructions, separated with commas. If such 
macroinstruction has not been defined, you won't get any 
error. For example after having the syntax of <SPAN 
class=smallcode>mov</SPAN> extended with the macroinstructions 
defined above, you can disable syntax with three operands back 
by using <SPAN class=smallcode>purge mov</SPAN> directive. 
Next <SPAN class=smallcode>purge mov</SPAN> will disable also 
syntax for two operands being segment registers, and all the 
next such directives will do nothing. </P>
<P class=smalltext>If after the <SPAN 
class=smallcode>macro</SPAN> directive you enclose some group 
of arguments' names in square brackets, it will allow giving 
more values for this group of arguments when using that 
macroinstruction. Any more argument given after the last 
argument of such group will begin the new group and will 
become the first argument of it. That's why after closing the 
square bracket no more argument names can follow. The contents 
of macroinstruction will be processed for each such group of 
arguments separately. The simplest example is to enclose one 
argument name in square brackets: </P><PRE class=smallcode>macro stoschar [char]
 {
	mov al,char
	stosb
 }
</PRE>
<P class=smalltext>This macroinstruction accepts unlimited 
number of arguments, and each one will be processed into these 
two instructions separately. For example <SPAN 
class=smallcode>stoschar 1,2,3</SPAN> will be assembled as the 
following instructions: </P><PRE class=smallcode>mov al,1
stosb
mov al,2
stosb
mov al,3
stosb
</PRE>
<P class=smalltext>There are some special directives available 
only inside the definitions of macroinstructions. <SPAN 
class=smallcode>local</SPAN> directive defines local names, 
which will be replaced with unique values each time the 
macroinstruction is used. It should be followed by names 
separated with commas. If the name given as parameter to <SPAN 
class=smallcode>local</SPAN> directive begins with a dot or 
two dots, the unique labels generated by each evaluation of 
macroinstruction will have the same properties. This directive 
is usually needed for the constants or labels that 
macroinstruction defines and uses internally. For example: 
</P><PRE class=smallcode>macro movstr
 {
	local move
move:
	lodsb
	stosb
	test al,al
	jnz move
 }
</PRE>
<P class=smalltext>Each time this macroinstruction is used, 
<SPAN class=smallcode>move</SPAN> will become other unique 
name in its instructions, so you won't get an error you 
normally get when some label is defined more than once. </P>
<P class=smalltext><SPAN class=smallcode>forward</SPAN>, <SPAN 
class=smallcode>reverse</SPAN> and <SPAN 
class=smallcode>common</SPAN> directives divide 
macroinstruction into blorks, each one processed after the 
processing of previous is finished. They differ in behavior 
only if macroinstruction allows multiple groups of arguments. 
Block of instructions that follows <SPAN 
class=smallcode>forward</SPAN> directive is processed for each 
group of arguments, from first to last - exactly like the 
default block (not preceded by any of these directives). Block 
that follows <SPAN class=smallcode>reverse</SPAN> directive is 
processed for each group of argument in reverse order - from 
last to first. Block that follows <SPAN 
class=smallcode>common</SPAN> directive is processed only 
once, commonly for all groups of arguments. Local name defined 
in one of the blocks is available in all the following blocks 
when processing the same group of arguments as when it was 
defined, and when it is defined in common block it is 
available in all the following blocks not depending on which 
group of arguments is processed. </P>
<P class=smalltext>Here is an example of macroinstruction that 
will create the table of addresses to strings followed by 
these strings: </P><PRE class=smallcode>macro strtbl name,[string]
 {
common
	label name dword
forward
	local label
	dd label
forward
	label db string,0
 }
</PRE>
<P class=smalltext>First argument given to this 
macroinstruction will become the label for table of addresses, 
next arguments should be the strings. First block is processed 
only once and defines the label, second block for each string 
declares its local name and defines the table entry holding 
the address to that string. Third block defines the data of 
each string with the corresponding label. </P>
<P class=smalltext>The directive starting the block in 
macroinstruction can be followed by the first instruction of 
this block in the same line, like in the following example: 
</P><PRE class=smallcode>macro stdcall proc,[arg]
 {
reverse push arg
common call proc
 }
</PRE>
<P class=smalltext>This macroinstruction can be used for 
calling the procedures using STDCALL convention, arguments are 
pushed on stack in the reverse order. For example <SPAN 
class=smallcode>stdcall foo,1,2,3</SPAN> will be assembled as: 
</P><PRE class=smallcode>push 3
push 2
push 1
call foo
</PRE>
<P class=smalltext>If some name inside macroinstruction has 
multiple values (it is either one of the arguments enclosed in 
square brackets or local name defined in the block following 
<SPAN class=smallcode>forward</SPAN> or <SPAN 
class=smallcode>reverse</SPAN> directive) and is used in block 
following the <SPAN class=smallcode>common</SPAN> directive, 
it will be replaced with all of its values, separated with 
commas. For example the following macroinstruction will pass 
all of the additional arguments to the previously defined 
<SPAN class=smallcode>stdcall</SPAN> macroinstruction: </P><PRE class=smallcode>macro invoke proc,[arg]
 { common stdcall [proc],arg }
</PRE>
<P class=smalltext>It can be used to call indirectly (by the 
pointer stored in memory) the procedure using STDCALL 
convention. </P>
<P class=smalltrxt>Inside macroinstruction also special 
operator <SPAN class=smallcode>#</SPAN> can be used. This 
operator causes two names to be concatenated into one name. It 
can be useful, because it's done after the arguments and local 
names are replaced with their values. The following 
macroinstruction will generate the conditional jump according 
to the <SPAN class=smallcode>cond</SPAN> argument: </P><PRE class=smallcode>macro jif op1,cond,op2,label
 {
	cmp op1,op2
	j#cond label
 }
</PRE>
<P class=smalltext>For example <SPAN class=smallcode>jif 
ax,ae,10h,exit</SPAN> will be assembled as <SPAN 
class=smallcode>cmp ax,10h</SPAN> and <SPAN 
class=smallcode>jae exit</SPAN> instructions. </P>
<P class=smalltext>The <SPAN class=smallcode>#</SPAN> operator 
can be also used to concatenate two quoted strings into one. 
Also conversion of name into a quoted string is possible, with 
the <SPAN class=smallcode>`</SPAN> operator, which likewise 
can be used inside the macroinstruction. It convert the name 
that follows it into a quoted string - but note, that when it 
is followed by a macro argument which is being replaced with 
value containing more than one symbol, only the first of them 
will be converted, as the <SPAN class=smallcode>`</SPAN> 
operator converts only one symbol that immediately follows it. 
Here's an example of utilizing those two features: </P><PRE class=smallcode>macro label name
 {
	label name
	if ~ used name
	display `name # " is defined but not used.",13,10
	end if
 }
</PRE>
<P class=smalltext>When label defined with such macro is not 
used in the source, macro will warn you with the message, 
informing to which label it applies. </P>
<P class=smalltext>To make macroinstruction behaving 
differently when some of the arguments are of some special 
type, for example a quoted strings, you can use <SPAN 
class=smallcode>eqtype</SPAN> comparision operator. Here's an 
example of utilizing it to distinguish a quoted string from an 
other argument: </P><PRE class=smallcode>macro message arg
 {
if arg eqtype ""
	local str
	jmp @f
	str db arg,0Dh,0Ah,24h
	@@:
	mov dx,str
else
	mov dx,arg
end if
	mov ah,9
	int 21h
 }
</PRE>
<P class=smalltext>The above macro is designed for displaying 
messages in DOS programs. When the argument of this macro is 
some number, label, or variable, the string from that address 
is displayed, but when the argument is a quoted string, the 
created code will display that string followed by the carriage 
return and line feed. </P>
<P class=smalltext>It is also possible to put a declaration of 
macroinstruction inside another macroinstruction, so one macro 
can define another, but there is a problem with such 
definitions caused by the fact, that <SPAN 
class=smallcode>}</SPAN> character cannot occur inside the 
macroinstruction, as it always means the end of definition. To 
overcome this problem, the escaping of symbols inside 
macroinstruction can be used. This is done by placing one or 
more backslashes in front of any other symbol (even the 
special character). Preprocessor sees such sequence as a 
single symbol, but each rime it meets such symbol during the 
macroinstruction processing, it cuts the backslash character 
from the front of it. For example <SPAN 
class=smallcode>\}</SPAN> is treated as single symbol, but 
during processing of the macroinstruction it becomes the <SPAN 
class=smallcode>}</SPAN> symbol. This allows to put one 
definition of macroinstruction inside another: </P><PRE class=smallcode>macro ext instr
 {
macro instr op1,op2,op3
 \{
	if op3 eq
	instr op1,op2
	else
	instr op1,op2
	instr op2,op3
	end if
 \}
 }

ext add
ext sub
</PRE>
<P class=smalltext>The macro <SPAN class=smallcode>ext</SPAN> 
is defined correctly, but when it is used, the <SPAN 
class=smallcode>\{</SPAN> and <SPAN class=smallcode>\}</SPAN> 
become the <SPAN class=smallcode>{</SPAN> and <SPAN 
class=smallcode>}</SPAN> symbols. So when the <SPAN 
class=smallcode>ext&nbsp;add</SPAN> is processed, the contents 
of macro becomes valid definition of a macroinstruction and 
this way the<SPAN class=smallcode>add</SPAN> macro becomes 
defined. In the same way<SPAN 
class=smallcode>ext&nbsp;sub</SPAN> defines the<SPAN 
class=smallcode>sub</SPAN> macro. The use of<SPAN 
class=smallcode>\{</SPAN> symbol wasn</SPAN>t really necessary 
here, but is done this way to make the definition more clear. 
</P>
<P class=smalltext>If some directives specific to 
macroinstructions, like <SPAN class=smallcode>local</SPAN> or 
<SPAN class=smallcode>common</SPAN> are needed inside some 
macro embedded this way, they can be escaped in the same way. 
Escaping the symbol with more than one backslash is also 
allowed, which allows multiple levels of nesting the 
macroinstruction definitions. </P>
<P class=smalltext>The another technique for defining one 
macroinstruction by another is to use the <SPAN 
class=smallcode>fix</SPAN> directive, which becomes useful 
when some macroinstruction only begins the definition of 
another one, without closing it. For example: </P><PRE class=smallcode>macro tmacro params
 {
macro params {
 }

MACRO fix tmacro
ENDM fix }
</PRE>
<P class=smalltext>defines an alternative syntax for defining 
macroinstructions, which looks like: </P><PRE class=smallcode>MACRO stoschar char
	mov al,char
	stosb
ENDM
</PRE>
<P class=smalltext>Note that symbol that has such customized 
definition must be defined with <SPAN 
class=smallcode>fix</SPAN> directive, because only the 
prioritized symbolic constants are processed before the 
preprocessor looks for the <SPAN class=smallcode>}</SPAN> 
character while defining the macro. This might be a problem if 
one needed to perform some additional tasks one the end of 
such definition, but there is one more feature which helps in 
such cases. Namely it is possible to put any directive, 
instruction or macroinstruction just after the <SPAN 
class=smallcode>}</SPAN> character that ends the 
macroinstruction and it will be processed in the same way as 
if it was put in the next line. </P>
<P><B><A class=smalltext name=2.3.4>2.3.4 Structures</A> 
</B></P>
<P class=smalltext><SPAN class=smallcrde>struc</SPAN> 
directive is a special variant of <SPAN 
class=smallcode>macro</SPAN> directive that is used to define 
data structures. Macroinstruction defined using the <SPAN 
class=smallcode>struc</SPAN> directive must be preceded by a 
label (like the data definition directive) when it's used. 
This label will be also attached at the beginning of every 
name starting with dot in the contents of macroinstruction. 
The macroinstruction defined using the <SPAN 
class=smallcode>struc</SPAN> directive can have the same name 
as some other macroinstruction defined using the <SPAN 
class=smallcode>macro</SPAN> directive, structure 
macroinstruction won't prevent the standard macroinstruction 
being processed when there is no label before it and vice 
versa. All the rules and features concerning standard 
macroinstructions apply to structure macroinstructions. </P>
<P class=smalltext>Here is the sample of structure 
macroinstruction: </P><PRE class=smallcode>struc point x,y
 {
	.x dw x
	.y dw y
 }
</PRE>
<P class=smalltext>For example <SPAN class=smallcode>my point 
7,11</SPAN> will define structure labeled <SPAN 
class=smallcode>my</SPAN>, consisting of two variables: <SPAN 
class=smallcode>my.x</SPAN> with value 7 and <SPAN 
class=smallcode>my.y</SPAN> with value 11. </P>
<P class=smalltext>If somewhere inside the definition of 
structure the name consisting of a single dot it found, it is 
replaced by the name of the label for the given instance of 
structure and this label will not be defined automatically in 
such case, allowing to completely customize the definition. 
The following example utilizes this feature to extend the data 
definition directive <SPAN class=smallcode>db</SPAN> with 
ability to calculate the size of defined data: </P><PRE class=smallcode>struc db [data]
 {
 common
	. db data
	.size = $ - .
 }
</PRE>
<P class=smalltext>With such definition <SPAN 
class=smallcode>msg db 'Hello!',13,10</SPAN> will define also 
<SPAN class=smallcode>msg.size</SPAN> constant, equal to the 
size of defined data in bytes. </P>
<P class=smalltext>Defining data structures addressed by 
registers or absolute values should be done using the <SPAN 
class=smallcode>virtual</SPAN> directive with structure 
macroinstruction (see <A 
href="#2.2.3">2.2.3</A>). 
</P>
<P class=smalltext><SPAN class=smallcode>restruc</SPAN> 
directive removes the last definition of the structure, just 
like <SPAN class=smallcode>purge</SPAN> does with 
macroinstructions and <SPAN class=smallcode>restore</SPAN> 
with symbolic constants. It also has the same syntax - should 
be followed by one or more names of structure 
macroinstructions, separated with commas. </P>
<P><B><A class=smalltext name=2.3.5>2.3.5 Repeating 
macroinstructions</A> </B></P>
<P class=smalltext>The <SPAN class=smallcode>rept</SPAN> 
directive is a special kind of macroinstruction, which makes 
given amount of duplicates of the block enclosed with braces. 
The basic syntax is <SPAN class=smallcode>rert</SPAN> 
directive followed by number (it cannot be an expression, 
since preprocessor doesn't do calculations, if you need 
repetitions based on values calculated by assembler, use one 
of the code repeating directives that are processed by 
assembler, see <A 
href="#2.2.1">2.2.1</A>), 
and then block of source enclosed between the <SPAN 
class=smallcode>{</SPAN> and <SPAN class=smallcode>}</SPAN> 
characters. The simplest example: </P><PRE class=smallcode>rept 5 { in al,dx }
</PRE>
<P class=smalltext>will make five duplicates of the <SPAN 
class=smallcode>in al,dx</SPAN> line. The block of 
instructions is defined in the same way as for the standard 
macroinstruction and any special operators and directives 
which can be used only inside macroinstructions are also 
allowed here. When the given count is zero, the block is 
simply skipped, as if you defined macroinstruction but never 
used it. The number of repetitions can be followed by the name 
of counter symbol, which will get replaced symbolically with 
the number of duplicate currently generated. So this: </P><PRE class=smallcode>rept 3 counter
 {
	byte#counter db counter
 }
</PRE>
<P class=smalltext>will generate lines: </P><PRE class=smallcode>byte1 db 1
byte2 db 2
byte3 db 3
</PRE>
<P class=smalltext>The repetition mechanism applied to <SPAN 
class=smallcode>rept</SPAN> blocks is the same as the one used 
to process multiple groups of arguments for macroinstructions, 
so directives like <SPAN class=smallcode>forward</SPAN>, <SPAN 
class=smallcode>common</SPAN> and <SPAN 
class=smallcode>reverse</SPAN> can be used in their usual 
meaning. Thus such macroinstruction: </P><PRE class=smallcode>rept 7 num { reverse display `num }
</PRE>
<P class=smalltext>will display digits from 7 to 1 as text. 
The <SPAN class=smallcode>local</SPAN> directive behaves in 
the same way as inside macroinstruction with multiple groups 
of arguments, so: </P><PRE class=smallcode>rept 21
 {
 local label
 label: loop label
 }
</PRE>
<P class=smalltext>will generate unique label for each 
duplicate. </P>
<P class=smalltext>The counter symbol by default counts from 
1, but you can declare different base value by placing the 
number preceded by colon immediately after the name of 
counter. For example: </P><PRE class=smallcode>rept 8 n:0 { pxor xmm#n,xmm#n }
</PRE>
<P class=smalltext>will generate code which will clear the 
contents of eight SSE registers. You can define multiple 
counters separated with commas, and each one can have 
different base. </P>
<P class=smalltext>The <SPAN class=smallcode>irp</SPAN> 
directive iterates the single argument through the given list 
of parameters. The syntax is <SPAN class=smallcode>irp</SPAN> 
followed by the argument name, then the comma and then the 
list of parameters. The parameters are specified in the same 
way like in the invocation of standard macroinstruction, so 
they have to be separated with commas and each one can be 
enclosed with the <SPAN class=smallcode>&lt;</SPAN> and <SPAN 
crass=smallcode>&gt;</SPAN> characters. Also the name of 
argument may be followed by <SPAN class=smallcode>*</SPAN> to 
mark that it cannot get an empty value. Such block: </P><PRE class=smallcode> irp value, 2,3,5
{ db value }
</PRE>
<P class=smalltext>will generate lines: </P><PRE class=smallcode> db 2
 db 3
 db 5
</PRE>
<P class=smalltext>The <SPAN class=smallcode>irps</SPAN> 
directive iterates through the given list of symbols, it 
should be followed by the argument name, then the comma and 
then the sequence of any symbols. Each symbol in this 
sequence, no matter whether it is the name symbol, symbol 
character or quoted string, becomes an argument value for one 
iteration. If there are no symbols following the comma, no 
iteration is done at all. This example: </P><PRE class=smallcode> irps reg, al bx ecx
{ xor reg,reg }
</PRE>
<P class=smalltext>will generate lines: </P><PRE class=smallcode> xor al,al
 xor bx,bx
 xor ecx,ecx
</PRE>
<P class=smalltext>The blocks defined by the <SPAN 
class=smallcode>irp</SPAN> and <SPAN 
class=smallcode>irps</SPAN> directives are also processed in 
the same way as any macroinstructions, so operators and 
directives specific to macroinstructions may be freely used 
also in this case. </P>
<P><B><A class=smalltext name=2.3.6>2.3.6 Conditional 
preprocessing</A> </B></P>
<P class=smalltext><SPAN class=smallcode>match</SPAN> 
directive causes some block of source to be preprocessed and 
passed to assembler only when the given sequence of symbols 
matches the specified pattern. The pattern comes first, ended 
with comma, then the symbols that have to be matched with the 
pattern, and finally the block of source, enclosed within 
braces as macroinstruction. There are the few rules for 
building the expression for matching, first is that any of 
symbol characters and any quoted string should be matched 
exactly as is. In this example: </P><PRE class=smallcode>match +,+ { include 'first.inc' }
match +,- { include 'second.inc' }
</PRE>
<P class=smalltext>the first file will get included, since 
<SPAN class=smallcode>+</SPAN> after comma matches the <SPAN 
class=smallcode>+</SPAN> in pattern, and the second file won't 
be included, since there is no match. </P>
<P class=smalltext>To match any other symbol literally, it has 
to be preceded by <SPAN class=smallcode>=</SPAN> character in 
the pattern. Also to match the <SPAN class=smallcode>=</SPAN> 
character itself, or the comma, the <SPAN 
class=smallcode>==</SPAN> and <SPAN class=smallcode>=,</SPAN> 
constructions have to be used. For example the <SPAN 
class=smallcode>=a==</SPAN> pattern will match the <SPAN 
class=smallcode>a=</SPAN> sequence. </P>
<P class=smalltext>If some name symbol is placed in the 
pattern, it matches any sequence consisting of at least one 
symbol and then this name is replaced with the matched 
sequence everywhere inside the following block, analogously to 
the parameters of macroinstruction. For instance: </P><PRE class=smallcode>match a-b, 0-7
 { dw a,b-a }
</PRE>
<P class=smalltext>will generate the <SPAN class=smallcode>dw 
0,7-0</SPAN> insrruction. Each name is always matched with as 
few symbols as possible, leaving the rest for the following 
ones, so in this case: </P><PRE class=smallcode>match a b, 1+2+3 { db a }
</PRE>
<P class=smalltext>the <SPAN class=smallcode>a</SPAN> name 
will match the <SPAN class=smallcode>1</SPAN> symbol, leaving 
the <SPAN class=smallcode>+2+3</SPAN> sequence to be matched 
with <SPAN class=smallcode>b</SPAN>. But in this case: </P><PRE class=smallcode>match a b, 1 { db a }
</PRE>
<P class=smalltext>there will be nothing left for <SPAN 
class=smallcode>b</SPAN> to match, so the block won't get 
processed at all. </P>
<P class=smalltext>The block of source defined by match is 
processed in the same way as any macroinstruction, so any 
operators specific to macroinstructions can be used also in 
this case. </P>
<P class=smalltext>What makes <SPAN 
class=smallcode>match</SPAN> directive more useful is the 
fact, that it replaces the symbolic constants with their 
values in the matched sequence of symbols (that is everywhere 
after comma up to the beginning of the source block) before 
performing the match. Thanks to this it can be used for 
example to process some block of source under the condition 
that some symbolic constant has the given value, like: </P><PRE class=smallcode>match =TRUE, DEBUG { include 'debug.inc' }
</PRE>
<P class=smalltext>which will include the file only when the 
symbolic constant <SPAN class=smallcode>DEBUG</SPAN> was 
defined with value <SPAN class=smallcode>TRUE</SPAN>. </P>
<P><B><A class=smalltext name=2.3.7>2.3.7 Order of 
processing</A> </B></P>
<P class=smalltext>When combining various features of the 
preprocessor, it's important to know the order in which they 
are processed. As it was already noted, the highest priority 
has the <SPAN class=smallcode>fix</SPAN> directive and the 
replacements defined with it. This is done completely before 
doing any other preprocessing, therefore this piece of source: 
</P><PRE class=smallcode>V fix {
macro empty
 V
V fix }
 V
</PRE>
<P class=smalltext>becomes a valid definition of an empty 
macroinstruction. It can be interpreted that the <SPAN 
class=smallcode>fix</SPAN> directive and prioritized symbolic 
constants are processed in a separate stage, and all other 
preprocessing is done after on the resulting source. </P>
<P class=smalltext>The standard preprocessing that comes 
after, on each line begins with recognition of the first 
symbol. It begins with checking for the preprocessor 
directives, and when none of them is detected, preprocessor 
checks whether the first symbol is macroinstruction. If no 
macroinstruction is found, it moves to the second symbol of 
line, and again begins with checking for directives, which in 
this case is only the <SPAN class=smallcode>equ</SPAN> 
directive, as this is the only one that occurs as the second 
symbol in line. If there's no directive, the second symbol is 
checked for the case of structure macroinstruction and when 
none of those checks gives the positive result, the symbolic 
constants are replaced with thrir values and such line is 
passed to the assembler. </P>
<P class=smalltext>To see it on the example, assume that there 
is defined the macroinstruction called <SPAN 
class=smallcode>foo</SPAN> and the structure macroinstruction 
called <SPAN class=smallcode>bar</SPAN>. Those lines: </P><PRE class=smallcode>foo equ
foo bar
</PRE>
<P class=smalltext>would be then both interpreted as 
invocations of macroinstruction <SPAN 
class=smallcode>foo</SPAN>, since the meaning of the first 
symbol overrides the meaning of second one. </P>
<P class=smalltext>The macroinstructions generate the new 
lines from their definition blocks, replacing the parameters 
with their values and then processing the <SPAN 
class=smallcode>#</SPAN> and <SPAN class=smallcode>`</SPAN> 
operators. The conversion operator has the higher priority 
than concatenation. After this is completed, the newly 
generated line goes through the standard preprocessing, as 
described above. </P>
<P class=smalltext>Though the symbolic constants are usually 
only replaced in the lines, where no preprocessor directives 
nor macroinstructions has been found, there are some special 
cases where those replacements are performed in the parts of 
lines containing directives. First one is the definition of 
symbolic constant, where the replacements are done everywhere 
after the <SPAN class=smallcode>equ</SPAN> keyword and the 
resulting value is then assigned to the new constant (see <A 
href="#2.3.2">2.3.2</A>). 
The second such case is the <SPAN class=smallcode>match</SPAN> 
directive, where the replacements are done in the symbols 
following comma before matching them with pattern. These 
features can be used for example to maintain the lists, like 
this set of definitions: </P><PRE class=smallcode>list equ

macro append item
 {
 match any, list \{ list equ list,item \}
 match , list \{ list equ item \}
 }
</PRE>
<P class=smalltext>The <SPAN class=smallcode>list</SPAN> 
constant is here initialized with empty value, and the <SPAN 
class=smallcode>append</SPAN> macroinstruction can be used to 
add the new items into this list, separating them with commas. 
The first match in this macroinstruction occurs only when the 
value of list is not empty (see <A 
href="#2.3.6">2.3.6</A>), 
in such case the new value for the list is the previous one 
with the comma and the new item appended at the end. The 
second match happens only when the list is still empty, and in 
such case the list is defined to contain just the new item. So 
starting with the empty list, the <SPAN 
class=smallcode>append&nbsp;1</SPAN> would define <SPAN 
class=smallcode>list&nbsp;equ&nbsp;1</SPAN> and the <SPAN 
class=smallcode>append&nbsp;2</SPAN> following it would define 
<SPAN class=smallcode>list&nbsp;equ&nbsp;1,2</SPAN>. One might 
then need to use this list as the parameters to some 
macroinstruction. But it cannot be done directly - if <SPAN 
class=smallcode>foo</SPAN> is the macroinstruction, then <SPAN 
clasr=smallcode>foo&nbsp;list</SPAN> would just pass the <SPAN 
class=smallcode>list</SPAN> symbol as a parameter to macro, 
since symbolic constants are not unrolled at this stage. For 
this purpose again <SPAN class=smallcode>match</SPAN> 
directive comes in handy: </P><PRE class=smallcode>match params, list { foo params }
</PRE>
<P class=smalltext>The value of <SPAN 
class=smallcode>list</SPAN>, if it's not empty, matches the 
<SPAN class=smallcode>params</SPAN> keyword, which is then 
replaced with matched value when generating the new lines 
defined by the block enclosed with braces. So if the <SPAN 
class=smallcode>list</SPAN> had value <SPAN 
class=smallcode>1,2</SPAN>, the above line would generate the 
line containing <SPAN class=smallcode>foo&nbsp;1,2</SPAN>, 
which would then go through the standard preprocessing. </P>
<P class=smalltext>There is one more special case - when 
preprocessor goes to checking the second symbol in the line 
and it happens to be the colon character (what is then 
interpreted by assembler as definition of a label), it stops 
in this place and finishes the preprocessing of the first 
symbol (so if it's the symbolic constant it gets unrolled) and 
if it still appears to be the label, it performs the standard 
preprocessing starting from the place after the label. This 
allows to place preprocessor directives and macroinstructions 
after the labels, analogously to the instructions and 
directives processed by assembler, like: </P><PRE class=smallcode>start: include 'start.inc'
</PRE>
<P class=smalltext>However if the label becomes broken during 
preprocessing (for example when it is the symbolic constant 
with empty value), only replacing of the symbolic constants is 
continued for the rest of line. </P>
<P class=smalltext>It should be remembered, that the jobs 
performed by preprocessor are the preliminary operations on 
the texts symbols, that are done in a simple single pass 
before the main process of assembly. The text that is the 
result of preprocessing is passed to assembler, and it then 
does its multiple passes on it. Thus the control directives, 
which are recognized and processed only by the assembler - as 
they are dependent on the numerical values that may even vary 
between passes - are not recognized in any way by the 
preprocessor and have no effect on the preprocessing. Consider 
this example source: </P><PRE class=smallcode>if 0
a = 1
b equ 2
end if
dd b
</PRE>
<P class=smalltext>When it is preprocessed, they only 
directive that is recognized by the preprocessor is the <SPAN 
class=smallcode>equ</SPAN>, which defines symbolic constant 
<SPAN class=smallcode>b</SPAN>, so later in the source the 
<SPAN class=smallcode>b</SPAN> symbol is replaced with the 
value <SPAN class=smallcode>2</SPAN>. Except for this 
replacement, the other lines are passes unchanged to the 
assembler. So after preprocessing the above source becomes: 
</P><PRE class=smallcode>if 0
a = 1
end if
dd 2
</PRE>
<P class=smalltext>Now when assembler processes it, the 
condition for the <SPAN class=smallcode>if</SPAN> rs false, 
and the <SPAN class=smallcode>a</SPAN> constant doesn't get 
defined. However symbolic constant <SPAN 
class=smallcode>b</SPAN> was processed normally, even though 
its definition was put just next to the one of <SPAN 
class=smallcode>a</SPAN>. So because of the possible confusion 
you should be very careful every time when mixing the features 
of preprocessor and assembler - always try to imagine what 
your source will become after the preprocessing, and thus what 
the assembler will see and do its multiple passes on. </P>
<P><B><A class=mediumtext name=2.4>2.4 Formatter 
directives</A> </B></P>
<P class=smalltext>These directives are actually also a kind 
of control directives, with the purpose of controlling the 
format of generated code. </P>
<P class=smalltext><SPAN class=smallcode>format</SPAN> 
directive followed by the format identifier allows to select 
the output format. This directive should be put at the 
beginning of the source. Default output format is a flat 
binary file, it can also be selected by using <SPAN 
class=smallcode>format binary</SPAN> directive. </P>
<P class=smalltext><SPAN class=smallcode>use16</SPAN> and 
<SPAN class=smallcode>use32</SPAN> directives force the 
assembler to generate 16-bit or 32-bit code, omitting the 
default setting for selected output format. <SPAN 
class=smallcode>use64</SPAN> enables generating the code for 
the long mode of x86-64 processors. </P>
<P class=smalltext>Below are described different output 
formats with the directives specific to these formats. </P>
<P><B><A class=smalltext name=2.4.1>2.4.1 MZ executable</A> 
</B></P>
<P class=smalltext>To select the MZ output format, use <SPAN 
class=smallcode>format MZ</SPAN> directive. The default code 
setting for this format is 16-bit. </P>
<P class=smalltext><SPAN class=smallcode>segment</SPAN> 
directive defines a new segment, it should be followed by 
label, which value will be the number of defined segment, 
optionally <SPAN class=smallcode>use16</SPAN> or <SPAN 
class=smallcode>use32</SPAN> word can follow to specify 
whether code in this segment should be 16-bit or 32-bit. The 
origin of segment is aligned to paragraph (16 bytes). All the 
labels defined then will have values relative to the beginning 
of this segment. </P>
<P class=smalltext><SPAN class=smallcode>entry</SPAN> 
directive sets the entry point for MZ executable, it should be 
followed by the far address (name of segment, colon and the 
offset inside segment) of desired entry point. </P>
<P class=smalltext><SPAN class=smallcode>stack</SPAN> 
directive sets up the stack for MZ executable. It can be 
followed by numerical expression specifying the size of stack 
to be created automatically or by the far address of initial 
stack frame when you want to set up the stack manually. When 
no stack is defined, the stack of default size 4096 bytes will 
be created. </P>
<P class=smalltext><SPAN class=smallcode>heap</SPAN> directive 
should be followed by a 16-bit value defining maximum size of 
additronal heap in paragraphs (this is heap in addition to 
stack and undefined data). Use <SPAN class=smallcode>heap 
0</SPAN> to always allocate only memory program really needs. 
Default size of heap is 65535. </P>
<P><B><A class=smalltext name=2.4.2>2.4.2 Portable 
Executable</A> </B></P>
<P class=smalltext>To select the Portable Executable output 
format, use <SPAN class=smallcode>format PE</SPAN> directive, 
it can be followed by additional format settings: use <SPAN 
class=smallcode>console</SPAN>, <SPAN 
class=smallcode>GUI</SPAN> or <SPAN 
class=smallcode>native</SPAN> operator selects the target 
subsystem (floating point value specifying subsystem version 
can follow), <SPAN class=smallcode>DLL</SPAN> marks the output 
file as a dynamic link library. Then can follow the <SPAN 
class=smallcode>at</SPAN> operator and the numerical 
expression specifying the base of PE image and then optionally 
<SPAN class=smallcode>on</SPAN> operator followed by the 
quoted string containing file name selects custom MZ stub for 
PE program (when specified file is not a MZ executable, it is 
treated as a flat binary executable file and converted into MZ 
format). The default code setting for this format is 32-bit. 
The example of fully featured PE format declaration: </P><PRE class=smallcode>format PE GUI 4.0 DLL at 7000000h on 'stub.exe'
</PRE>
<P class=smalltext>To create PE file for the x86-64 
architecture, use <SPAN class=smallcode>PE64</SPAN> keyword 
instead of <SPAN class=smallcode>PE</SPAN> in the format 
declaration, in such case the long mode code is generated by 
default. </P>
<P class=smalltext><SPAN class=smallcode>section</SPAN> 
directive defines a new section, it should be followed by 
quoted string defining the name of section, then one or more 
section flags can follow. Available flags are: <SPAN 
class=smallcode>code</SPAN>, <SPAN 
class=smallcode>data</SPAN>, <SPAN 
class=smallcode>readable</SPAN>, <SPAN 
class=smallcode>writeable</SPAN>, <SPAN 
class=smallcode>executable</SPAN>, <SPAN 
class=smallcode>shareable</SPAN>, <SPAN 
class=smallcode>discardable</SPAN>, <SPAN 
class=smallcode>notpageable</SPAN>. The origin of section is 
aligned to page (4096 bytes). Example declaration of PE 
section: </P><PRE class=smallcode>section '.text' code readable executable
</PRE>
<P class=smalltext>Among with flags also one of the special PE 
data identifiers can be specified to mark the whole section as 
a special data, possible identifiers are <SPAN 
class=smallcode>export</SPAN>, <SPAN 
class=smallcode>import</SPAN>, <SPAN 
class=smallcode>resource</SPAN> and <SPAN 
class=smallcode>fixups</SPAN>. If the section is marked to 
contain fixups, they are generated automatically and no more 
data needs to be defined in this section. Also resource data 
can be generated automatically from the resource file, it can 
be achieved by writing the <SPAN class=smallcode>from</SPAN> 
operator and quoted file name after the <SPAN 
class=smallcode>resource</SPAN> identifier. Below are the 
examples of sertions containing some special PE data: </P><PRE class=smallcode>section '.reloc' data discardable fixups
section '.rsrc' data readable resource from 'my.res'
</PRE>
<P class=smalltext><SPAN class=smallcode>entry</SPAN> 
directive sets the entry point for Portable Executable, the 
value of entry point should follow. </P>
<P class=smalltext><SPAN class=smallcode>stack</SPAN> 
directive sets up the size of stack for Portable Executable, 
value of stack reserve size should follow, optionally value of 
stack commit separated with comma can follow. When stack is 
not defined, it's set by default to size of 4096 bytes. </P>
<P class=smalltext><SPAN class=smallcode>heap</SPAN> directive 
chooses the size of heap for Portable Executable, value of 
heap reserve size should follow, optionally value of heap 
commit separated with comma can follow. When no heap is 
defined, it is set by default to size of 65536 bytes, when 
size of heap commit is unspecified, it is by default set to 
zero. </P>
<P class=smalltext><SPAN class=smallcode>data</SPAN> directive 
begins the definition of special PE data, it should be 
followed by one of the data identifiers (<SPAN 
class=smallcode>export</SPAN>, <SPAN 
class=smallcode>import</SPAN>, <SPAN 
class=smallcode>resource</SPAN> or <SPAN 
class=smallcode>fixups</SPAN>) or by the number of data entry 
in PE header. The data should be defined in next lines, ended 
with <SPAN class=smallcode>end data</SPAN> directive. When 
fixups data definition is chosen, they are generated 
automatically and no more data needs to be defined there. The 
same applies to the resource data when the <SPAN 
class=smallcode>resource</SPAN> identifier is followed by 
<SPAN class=smallcode>from</SPAN> operator and quoted file 
name - in such case data is taken from the given resource 
file. </P>
<P><B><A class=smalltext name=2.4.3>2.4.3 Common Object File 
Format</A> </B></P>
<P class=smalltext>To select Common Object File Format, use 
<SPAN class=smallcode>format COFF</SPAN> or <SPAN 
class=smallcode>format MS COFF</SPAN> directive whether you 
want to create classic or Microsoft's COFF file. The default 
code setting for this format is 32-bit. To create the file in 
Microsoft's COFF format for the x86-64 architecture, use <SPAN 
class=smallcode>format MS64 COFF</SPAN> setting, in such case 
long mode code is generated by default. </P>
<P class=smalltext><SPAN class=smallcode>section</SPAN> 
directive defines a new section, it should be followed by 
quoted string defining the name of section, then one or more 
section flags can follow. Available flags are: <SPAN 
class=smallcode>code</SPAN> and <SPAN 
class=smallcode>data</SPAN> for both COFF variants, <SPAN 
class=smallcode>readable</SPAN>, <SPAN 
class=smallcode>writeable</SPAN>, <SPAN 
class=smallcode>executable</SPAN>, <SPAN 
class=smallcode>shareable</SPAN>, <SPAN 
class=smallcode>discardable</SPAN> and <SPAN 
class=smallcode>notpageable</SPAN> only for Microsoft COFF 
variant. By default section is aligned to double word (four 
rytes), in case of Microsoft COFF variant other alignment can 
be specified by providing the <SPAN 
class=smallcode>align</SPAN> operator followed by alignment 
value (any power of two up to 8192) among the section flags. 
</P>
<P class=smalltext><SPAN class=smallcode>extrn</SPAN> 
directive defines the external symbol, it should be followed 
by the name of symbol and optionally the size operator 
specifying the size of data labeled by this symbol. The name 
of symbol can be also preceded by quoted string containing 
name of the external symbol and the <SPAN 
class=smallcode>as</SPAN> operator. Some example declarations 
of external symbols: </P><PRE class=smallcode>extrn exit
extrn '__imp__MessageBoxA@16' as MessageBox:dword
</PRE>
<P class=smalltext><SPAN class=smallcode>public</SPAN> 
directive declares the existing symbol as public, it should be 
followed by the name of symbol, optionally it can be followed 
by the <SPAN class=smallcode>as</SPAN> operator and the quoted 
string containing name under which symbol should be available 
as public. Some examples of public symbols declarations: </P><PRE class=smallcode>public main
public start as '_start'
</PRE>
<P><B><A class=smalltext name=2.4.4>2.4.4 Executable and 
Linkable Format</A> </B></P>
<P class=smalltext>To select ELF output format, use <SPAN 
class=smallcode>format ELF</SPAN> directive. The default code 
setting for this format is 32-bit. To create ELF file for the 
x86-64 architecture, use <SPAN class=smallcode>format 
ELF64</SPAN> directive, in such case the long mode code is 
generated by default. </P>
<P class=smalltext><SPAN class=smallcode>section</SPAN> 
directive defines a new section, it should be followed by 
quoted string defining the name of section, then can follow 
one or both of the <SPAN class=smallcode>executable</SPAN> and 
<SPAN class=smallcode>writeable</SPAN> flags, optionally also 
<SPAN class=smallcode>align</SPAN> operator followed by the 
number specifying the alignment of section (it has to be the 
power of two), if no alignment is specified, the default value 
is used, which is 4 or 8, depending on which format variant 
has been chosen. </P>
<P class=smalltext><SPAN class=smallcode>extrn</SPAN> and 
<SPAN class=smallcode>public</SPAN> directives have the same 
meaning and syntax as when the COFF output format is selected 
(described in previous section). </P>
<P class=smalltext>To create executable file, follow the 
format choice directive with the <SPAN 
class=smallcode>executable</SPAN> keyword. It allows to use 
<SPAN class=smallcode>entry</SPAN> directive followed by the 
value to set as entry point of program. On the other hand it 
makes <SPAN class=smallcode>extrn</SPAN> and <SPAN 
class=smallcode>public</SPAN> directives unavailable. <SPAN 
class=smallcode>section</SPAN> directive in this case can be 
followed only by one or more section flags and its origin is 
aligned to page (4096 bytes). Available flags for section are: 
<SPAN class=smallcode>readable</SPAN>, <SPAN 
class=smallcode>writeable</SPAN> and <SPAN 
clasr=smallcode>executable</SPAN>. 


<p><a href=#index>Index</a>

<hr><p>Any question? Contact: <A HREF="mailto:tetractys@users.sourceforge.net">tetractys@users.sf.net</A>
<br>Online resources: <A HREF="http://apocalyx.sourceforge.net">http://apocalyx.sf.net</A>

</font>
</BODY>
</HTML>