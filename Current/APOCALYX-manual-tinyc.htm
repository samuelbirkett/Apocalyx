<html>
<head>
<title>APOCALYX Engine - Programmer's Manual - C Interface</title>
</head>

<body bgcolor=#CCCCCC>
<font face="verdana,arial" size=-1>

<center>
<h1>APOCALYX Engine</h1>
<h2>Programmer's Manual</h2>
<h3>C Interface</h3>
<h5>Copyright &copy 2002-2007 <A HREF="mailto:tetractys@users.sourceforge.net">Leonardo Boselli</A></h5>
</center>
<p><hr>
<p>This paper is provided as is without warranties of any kind.
<ul>
<p><li><b>Tiny C</b> interface
<p>
<ul>
<li><b><a href="#the_tinyc_compiler">Part IV</a></b> is an excerpt taken from the "<i>Tiny C Compiler Reference Documentation (0.9.23)</i>", copyright &copy; 2001-2004 Fabrice Bellard, that is included in the official documentation of the compiler. To get the complete manual visit the site <a href="http://www.tinycc.org">http://www.tinycc.org</a>.
<li><b><a href="#the_TinyC_API">Part V</a></b> describes the API accessible to C functions compiled with the Tiny C compiler.
</ul>
</ul>

<center><p><hr><a name=index><h2>Index</h2></a><hr></center>

<ul>

<p><li><a href="#the_tinyc_compiler">Part IV - The Tiny C Compiler</a><br>
<p>
<A NAME="TOC1" HREF="#SEC1">4.1. Introduction</A>
<br><A NAME="TOC5" HREF="#SEC5">4.3. C language support</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC6" HREF="#SEC6">4.3.1 ANSI C</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC7" HREF="#SEC7">4.3.2 ISOC99 extensions</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC8" HREF="#SEC8">4.3.3 GNU C extensions</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC9" HREF="#SEC9">4.3.4 TinyCC extensions</A>
<br><A NAME="TOC10" HREF="#SEC10">4.4. TinyCC Assembler</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC11" HREF="#SEC11">4.4.1 Syntax</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC12" HREF="#SEC12">4.4.2 Expressions</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC13" HREF="#SEC13">4.4.3 Labels</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC14" HREF="#SEC14">4.4.4 Directives</A>
<br>&nbsp;&nbsp;&nbsp;<A NAME="TOC15" HREF="#SEC15">4.4.5 X86 Assembler</A>

<p><li><a href=#the_TinyC_API>Part V - The Tiny C API</a>
<p><a href="#basic_interface">5.0 Basic functions</a><br>
<a href="#lua_interface">5.1 Lua functions</a>
<UL>
<LI><A HREF="#3">3 - The Application Program Interface</A>
<UL>
<LI><A HREF="#3.1">3.1 - The Stack</A>
<LI><A HREF="#3.2">3.2 - Stack Size</A>
<LI><A HREF="#3.3">3.3 - Pseudo-Indices</A>
<LI><A HREF="#3.4">3.4 - C Closures</A>
<LI><A HREF="#3.5">3.5 - Registry</A>
<LI><A HREF="#3.6">3.6 - Error Handling in C</A>
<LI><A HREF="#3.7">3.7 - Functions and Types</A>
<LI><A HREF="#3.8">3.8 - The Debug Interface</A>
</UL>
<LI><A HREF="#4">4 - The Auxiliary Library</A>
<UL>
<LI><A HREF="#4.1">4.1 - Functions and Types</A>
</UL>
<LI><A HREF="#tolua">The toLua++ Library</A>
</UL>
<br>
<a href="#engine_interface">5.2 APOCALYX Engine functions</a><br>
<a href="#sdl_interface">5.3 Simple DirectMedia Layer (SDL) functions</a><br>
<a href="#ode_interface">5.4 Open Dynamics Engine (ODE) functions</a><br>
<a href="#csl_interface">5.5 CSL functions</a><br>
<a href="#angel_interface">5.6 AngelScript functions</a><br>
<a href="#small_interface">5.7 SMALL functions</a><br>

</ul>

<hr><center><p align=center><a name=the_tinyc_compiler><h2>Part IV - The Tiny C Compiler</h2></a></center><hr>

<p>
<i>Excerpt from the</i>
</p>

<h4>
&nbsp;&nbsp;&nbsp; Tiny C Compiler Reference Documentation
</h4>

&nbsp;&nbsp;&nbsp; by Fabrice Bellard
<p>
<small>
&nbsp;&nbsp;&nbsp;
Copyright &copy; 2001-2003 Fabrice Bellard.<br>
</small>
<hr>


<H2><A NAME="SEC1" HREF="#TOC1">4.1. Introduction</A></H2>

<P>
TinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C
compilers, it is meant to be self-relying: you do not need an
external assembler or linker because TCC does that for you.


<P>
TCC compiles so <EM>fast</EM> that even for big projects <CODE>Makefile</CODE>s may
not be necessary. 


<P>
TCC not only supports ANSI C, but also most of the new ISO C99
standard and many GNUC extensions including inline assembly.


<P>
TCC can also be used to make <EM>C scripts</EM>, i.e. pieces of C source
that you run as a Perl or Python script. Compilation is so fast that
your script will be as fast as if it was an executable.


<P>[...]

<P>
TCC mainly supports the i386 target. There are alpha ports for the ARM
(<CODE>arm-tcc</CODE>) and the TMS320C67xx targets (<CODE>c67-tcc</CODE>). More
information about the ARM port is available at
<A HREF="http://lists.gnu.org/archive/html/tinycc-devel/2003-10/msg00044.html">http://lists.gnu.org/archive/html/tinycc-devel/2003-10/msg00044.html</A>.

<P>[...]

<H2><A NAME="SEC5" HREF="#TOC5">4.3. C language support</A></H2>



<H3><A NAME="SEC6" HREF="#TOC6">4.3.1 ANSI C</A></H3>

<P>
TCC implements all the ANSI C standard, including structure bit fields
and floating point numbers (<CODE>long double</CODE>, <CODE>double</CODE>, and
<CODE>float</CODE> fully supported).




<H3><A NAME="SEC7" HREF="#TOC7">4.3.2 ISOC99 extensions</A></H3>

<P>
TCC implements many features of the new C standard: ISO C99. Currently
missing items are: complex and imaginary numbers and variable length
arrays.


<P>
Currently implemented ISOC99 features:



<UL>

<LI>64 bit <CODE>long long</CODE> types are fully supported.

<LI>The boolean type <CODE>_Bool</CODE> is supported.

<LI><CODE>__func__</CODE> is a string variable containing the current

function name.

<LI>Variadic macros: <CODE>__VA_ARGS__</CODE> can be used for

   function-like macros:

<PRE>
    #define dprintf(level, __VA_ARGS__) printf(__VA_ARGS__)
</PRE>

<CODE>dprintf</CODE> can then be used with a variable number of parameters.

<LI>Declarations can appear anywhere in a block (as in C++).

<LI>Array and struct/union elements can be initialized in any order by

  using designators:

<PRE>
    struct { int x, y; } st[10] = { [0].x = 1, [0].y = 2 };

    int tab[10] = { 1, 2, [5] = 5, [9] = 9};
</PRE>

    
<LI>Compound initializers are supported:


<PRE>
    int *p = (int []){ 1, 2, 3 };
</PRE>

to initialize a pointer pointing to an initialized array. The same
works for structures and strings.

<LI>Hexadecimal floating point constants are supported:


<PRE>
          double d = 0x1234p10;
</PRE>

is the same as writing 

<PRE>
          double d = 4771840.0;
</PRE>

<LI><CODE>inline</CODE> keyword is ignored.

<LI><CODE>restrict</CODE> keyword is ignored.

</UL>



<H3><A NAME="SEC8" HREF="#TOC8">4.3.3 GNU C extensions</A></H3>

<P>
TCC implements some GNU C extensions:



<UL>

<LI>array designators can be used without '=':


<PRE>
    int a[10] = { [0] 1, [5] 2, 3, 4 };
</PRE>

<LI>Structure field designators can be a label:


<PRE>
    struct { int x, y; } st = { x: 1, y: 1};
</PRE>

instead of

<PRE>
    struct { int x, y; } st = { .x = 1, .y = 1};
</PRE>

<LI><CODE>\e</CODE> is ASCII character 27.

<LI>case ranges : ranges can be used in <CODE>case</CODE>s:


<PRE>
    switch(a) {
    case 1 ... 9:
          printf(&quot;range 1 to 9\n&quot;);
          break;
    default:
          printf(&quot;unexpected\n&quot;);
          break;
    }
</PRE>

<LI>The keyword <CODE>__attribute__</CODE> is handled to specify variable or

function attributes. The following attributes are supported:

<UL>
<LI><CODE>aligned(n)</CODE>: align data to n bytes (must be a power of two).

<LI><CODE>section(name)</CODE>: generate function or data in assembly

  section name (name is a string containing the section name) instead
  of the default section.

<LI><CODE>unused</CODE>: specify that the variable or the function is unused.

<LI><CODE>cdecl</CODE>: use standard C calling convention.

<LI><CODE>stdcall</CODE>: use Pascal-like calling convention.

</UL>

Here are some examples:

<PRE>
    int a __attribute__ ((aligned(8), section(&quot;.mysection&quot;)));
</PRE>

align variable <CODE>a</CODE> to 8 bytes and put it in section <CODE>.mysection</CODE>.


<PRE>
    int my_add(int a, int b) __attribute__ ((section(&quot;.mycodesection&quot;))) 
    {
        return a + b;
    }
</PRE>

generate function <CODE>my_add</CODE> in section <CODE>.mycodesection</CODE>.

<LI>GNU style variadic macros:


<PRE>
    #define dprintf(fmt, args...) printf(fmt, ## args)

    dprintf(&quot;no arg\n&quot;);
    dprintf(&quot;one arg %d\n&quot;, 1);
</PRE>

<LI><CODE>__FUNCTION__</CODE> is interpreted as C99 <CODE>__func__</CODE>

(so it has not exactly the same semantics as string literal GNUC
where it is a string literal).

<LI>The <CODE>__alignof__</CODE> keyword can be used as <CODE>sizeof</CODE>

to get the alignment of a type or an expression.

<LI>The <CODE>typeof(x)</CODE> returns the type of <CODE>x</CODE>.

<CODE>x</CODE> is an expression or a type.

<LI>Computed gotos: <CODE>&#38;&#38;label</CODE> returns a pointer of type

<CODE>void *</CODE> on the goto label <CODE>label</CODE>. <CODE>goto *expr</CODE> can be
used to jump on the pointer resulting from <CODE>expr</CODE>.

<LI>Inline assembly with asm instruction:

<A NAME="IDX1"></A>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>

<PRE>
static inline void * my_memcpy(void * to, const void * from, size_t n)
{
int d0, d1, d2;
__asm__ __volatile__(
        &quot;rep ; movsl\n\t&quot;
        &quot;testb $2,%b4\n\t&quot;
        &quot;je 1f\n\t&quot;
        &quot;movsw\n&quot;
        &quot;1:\ttestb $1,%b4\n\t&quot;
        &quot;je 2f\n\t&quot;
        &quot;movsb\n&quot;
        &quot;2:&quot;
        : &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;S&quot; (d2)
        :&quot;0&quot; (n/4), &quot;q&quot; (n),&quot;1&quot; ((long) to),&quot;2&quot; ((long) from)
        : &quot;memory&quot;);
return (to);
}
</PRE>

<A NAME="IDX4"></A>
TCC includes its own x86 inline assembler with a <CODE>gas</CODE>-like (GNU
assembler) syntax. No intermediate files are generated. GCC 3.x named
operands are supported.

<LI><CODE>__builtin_types_compatible_p()</CODE> and <CODE>__builtin_constant_p()</CODE>

are supported.

</UL>



<H3><A NAME="SEC9" HREF="#TOC9">4.3.4 TinyCC extensions</A></H3>


<UL>

<LI><CODE>__TINYC__</CODE> is a predefined macro to <CODE>1</CODE> to

indicate that you use TCC.

<LI><CODE>#!</CODE> at the start of a line is ignored to allow scripting.

<LI>Binary digits can be entered (<CODE>0b101</CODE> instead of

<CODE>5</CODE>).

<LI><CODE>__BOUNDS_CHECKING_ON</CODE> is defined if bound checking is activated.

</UL>



<H2><A NAME="SEC10" HREF="#TOC10">4.4. TinyCC Assembler</A></H2>

<P>
Since version 0.9.16, TinyCC integrates its own assembler. TinyCC
assembler supports a gas-like syntax (GNU assembler). You can
desactivate assembler support if you want a smaller TinyCC executable
(the C compiler does not rely on the assembler).


<P>
TinyCC Assembler is used to handle files with <TT>`.S'</TT> (C
preprocessed assembler) and <TT>`.s'</TT> extensions. It is also used to
handle the GNU inline assembler with the <CODE>asm</CODE> keyword.




<H3><A NAME="SEC11" HREF="#TOC11">4.4.1 Syntax</A></H3>

<P>
TinyCC Assembler supports most of the gas syntax. The tokens are the
same as C.



<UL>

<LI>C and C++ comments are supported.

<LI>Identifiers are the same as C, so you cannot use '.' or '$'.

<LI>Only 32 bit integer numbers are supported.

</UL>



<H3><A NAME="SEC12" HREF="#TOC12">4.4.2 Expressions</A></H3>


<UL>

<LI>Integers in decimal, octal and hexa are supported.

<LI>Unary operators: +, -, ~.

<LI>Binary operators in decreasing priority order:


<OL>
<LI>*, /, %

<LI>&#38;, |, ^

<LI>+, -

</OL>

<LI>A value is either an absolute number or a label plus an offset.

All operators accept absolute values except '+' and '-'. '+' or '-' can be
used to add an offset to a label. '-' supports two labels only if they
are the same or if they are both defined and in the same section.

</UL>



<H3><A NAME="SEC13" HREF="#TOC13">4.4.3 Labels</A></H3>


<UL>

<LI>All labels are considered as local, except undefined ones.

<LI>Numeric labels can be used as local <CODE>gas</CODE>-like labels.

They can be defined several times in the same source. Use 'b'
(backward) or 'f' (forward) as suffix to reference them:


<PRE>
 1:
      jmp 1b /* jump to '1' label before */
      jmp 1f /* jump to '1' label after */
 1:
</PRE>

</UL>



<H3><A NAME="SEC14" HREF="#TOC14">4.4.4 Directives</A></H3>
<P>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>


<P>
All directives are preceeded by a '.'. The following directives are
supported:



<UL>
<LI>.align n[,value]

<LI>.skip n[,value]

<LI>.space n[,value]

<LI>.byte value1[,value2...]

<LI>.word value1[,value2...]

<LI>.short value1[,value2...]

<LI>.int value1[,value2...]

<LI>.long value1[,value2...]

<LI>.string string

<LI>.globl symbol

<LI>.global symbol

<LI>.section section

<LI>.text

<LI>.data

<LI>.bss

<LI>.fill repeat[,size[,value]]

<LI>.org n

<LI>.previous

<LI>.string string[,...]

<LI>.asciz string[,...]

<LI>.ascii string[,...]

</UL>



<H3><A NAME="SEC15" HREF="#TOC15">4.4.5 X86 Assembler</A></H3>
<P>
<A NAME="IDX22"></A>


<P>
All X86 opcodes are supported. Only ATT syntax is supported (source
then destination operand order). If no size suffix is given, TinyCC
tries to guess it from the operand sizes.


<P>
Currently, MMX opcodes are supported but not SSE ones.

<p>[...]

<p><a href=#index>Index</a><hr>
<center><p align=center><a name=the_TinyC_API><h2>Part V - The Tiny C API</h2></a></center><hr>

This section describes all the C functions accessible to code compiled with Tiny C. Functions with similar functionalities are grouped together.

<p><a href=#index>Index</a>
<hr><p><a name="basic_interface"><h3>5.0 Basic functions</h3></a>

<p>Several functions usually available to C programs are accessible to Tiny C compiled code as well. Their include file is "<i>core.h</i>". The following are the registered functions:

<ul>
<p><li><b>I/O</b> (read a C manual for more details)
<ul>
<li>void <b>printf</b>(const char* format, ...);<br>writes formatted output
<li>int <b>putchar</b>(int c);<br>writes a single character 
<li>FILE* <b>fopen</b>(const char *file_name, const char *mode);<br>opens a stream (mode must be "w" for writing, "r" for reading)
<li>int <b>fprintf</b>(FILE *file, const char *format, ...);<br>writes formatted output to a stream
<li>int <b>fscanf</b>(FILE *file, const char *format, ...);<br>reads formatted output from a stream
<li>int <b>fwrite</b>(const void *buffer, int itemSize, int itemCount, FILE *file);<br>writes an <i>itemCount</i> number of items of <i>itemSize</i> size from <i>buffer</i> to a stream
<li>int <b>fread</b>(void *buffer, int itemSize, int itemCount, FILE *file);<br>reads an <i>itemCount</i> number of items of <i>itemSize</i> size from a stream to a <i>buffer</i>
<li>int <b>fseek</b>(FILE* file, int offset, int whence);<br>repositions a file pointer on a stream. <i>whence</i> may be 0 (file beginning), 1 (current position) or 2 (end of file)
<li>int <b>ftell</b>(FILE* file);<br>returns the current file pointer. The offset is measured in bytes from the beginning of the file (if the file is binary). The value returned by ftell can be used in a subsequent call to fseek.
<li>int <b>fclose</b>(FILE *file);<br>closes a stream
</ul>
<p><li><b>Math</b> (read a C manual for more details)
<ul>
<li>double <b>acos</b>(double x);<br>calculates the arc cosine of x
<li>double <b>asin</b>(double x);<br>calculates the arc sine of x
<li>double <b>atan</b>(double x);<br>calculates the arc tangent of x
<li>double <b>atan2</b>(double y, double x);<br>calculates the arc tangent of y/x
<li>double <b>ceil</b>(double x);<br>finds the smallest integer not less than x
<li>double <b>cos</b>(double x);<br>computes the cosine of x: angles are specified in radians
<li>double <b>exp</b>(double x);<br>calculates the exponential e to the x
<li>double <b>fabs</b>(double x);<br>calculates the absolute value of x
<li>double <b>floor</b>(double x);<br>finds the largest integer not greater than x
<li>double <b>fmod</b>(double x, double y);<br>calculates x modulo y (the remainder f, where x = ay + f for some integer a, and 0 &le; f &lt; y)
<li>double <b>log</b>(double x);<br>calculates the natural logarithm of x
<li>double <b>log10</b>(double x);<br>calculates the base 10 logarithm of x
<li>double <b>modf</b>(double x, double *ipart);<br>breaks the double x into two parts: the integer and the fraction: it stores the integer in ipart and returns the fraction
<li>double <b>pow</b>(double x, double y);<br>calculates x to the power of y
<li>double <b>sin</b>(double x);<br>calculates the sine of x: angles are specified in radians
<li>double <b>sqrt</b>(double x);<br>calculates the positive square root of the argument x
<li>double <b>tan</b>(double x);<br>calculates the tangent of x: angles are specified in radians
<li>void <b>randomize</b>(void);<br>initializes the random number generator with a random value
<li>int <b>rand</b>(void);<br>uses a multiplicative congruential random number generator with period 2 to the 32nd power to return successive pseudorandom numbers in the range from 0 to 32767
<li>void <b>srand</b>(unsigned seed);<br>initializes random number generator: it is reinitialized with argument equal to 1, while it can be set to a new starting point with a given seed number
</ul>
<p><li><b>String</b> (read a C manual for more details)
<ul>
<li>void <b>sprintf</b>(const char* buffer, const char* format, ...);<br>writes formatted output to buffer
<li>void <b>sscanf</b>(const char* buffer, const char* format, ...);<br>reads formatted output from buffer
<li>int <b>strcmp</b>(const char *s1, const char *s2);<br>compares one string to another. Returns a negative value if <i>s1</i> &lt; <i>s2</i>, zero if <i>s1</i> is the same as <i>s2</i>, a positive value if <i>s1</i> &gt; <i>s2</i>
<li>int <b>strlen</b>(const char *s);<br>calculates the length of a string
<li>char* <b>strstr</b>(char *s1, char *s2);<br>scans a string for the occurrence of a given substring
<li>char* <b>strtok</b>(char *s1, const char *s2);<br>searches one string for tokens, which are separated by delimiters defined in a second string
</ul>
<p><li><b>Memory</b> (read a C manual for more details)
<ul>
<li>void* <b>malloc</b>(int size);<br>allocates main memory
<li>void* <b>realloc</b>(void* block, int size);<br>reallocates main memory
<li>void <b>free</b>(void* block);<br>frees allocated block
<li>void* <b>memset</b>(void* s, int c, int n);<br>sets n bytes of a block of memory to byte c
<li>void* <b>memcpy</b>(void *dest, const void *src, int n);<br>copies n bytes of <i>src</i> block of memory to <i>dest</i>
</ul>
<p><li><b>Time</b> (read a C manual for more details)
<ul>
<li>int <b>time</b>(int* timer);<br>gives the current time, in seconds, elapsed since 00:00:00 GMT, January 1, 1970.
<li>int <b>clock</b>(void);<br>gives the current time, in milliseconds, from the beginning of the program invocation.
</ul>
<p><li><b>Environment</b> (read a C manual for more details)
<ul>
<li>char* <b>getenv</b>(const char* name);<br>finds or deletes an environment variable from the system environment.
The environment consists of a series of entries that are of the form "name=string\0". On success, it returns the value associated with name. 
If the specified name is not defined in the environment, it returns a NULL pointer.
<li>int <b>putenv</b>(const char* name);<br>adds string to current environment. On success, it returns 0; on failure, -1.
</ul>
<p><li><b>Libraries</b> (the following functions provide an access to external DLLs)
<ul>
<li>Library* <b>libraryLoad</b>(const char* libName);<br>loads a library (DLL) given its name and returns an identifier. Returns NULL if the load failed
<li>int <b>libraryFree</b>(Library* lib);<br>unloads a library given its identifier. Returns zero if the unload failed
<li>void* <b>libraryGetProcAddress</b>(Library* lib, const char* funcName);<br>gets the address of the function specified by <i>funcName</i> in the library identified by <i>lib</i>
</ul>
<p><li><b>OpenGL</b> (the following functions provide an access to the OpenGL API)
<ul>
<li>void* <b>oglGetProcAddress</b>(const char* funcName);<br>gets the address of the OpenGL function specified by <i>funcName</i>
<li>int <b>oglIsExtensionSupported</b>(const char* extName);<br>returns 1 (true) if the OpenGL extension specified by <i>extName</i> is supported by the graphic card
</ul>
<p><li><b>Exiting</b> (basic function that does not fit in the above categories)
<ul>
<li>void <b>exitC</b>(void);<br>exits the C rendering mode and returns to LUA rendering mode. This function is called to restore the LUA rendering loop after the control was given to C code through a <i>Compiler:enterC()</i> call</ul>
</ul>

<p><a href=#index>Index</a>
<hr><p><a name="lua_interface"><h3>5.1 Lua functions</h3></a>

<p>This is again mainly an excerpt taken from the manual of the LUA language already cited (&copy; 1994-2006 Lua.org, PUC-Rio).

<p>This section describes the C API for Lua, that is,
the set of C&nbsp;functions available to the host program to communicate
with Lua.
All API functions and related types and constants
are declared in the header file <code>lua.h</code> [<i>in the Tiny C implementation they appear in a modified version of</i> "<i>lua.h</i>"]

<p>[...]

<h2>3 - <a name="3">The Application Program Interface</a></h2>

<p>

This section describes the C&nbsp;API for Lua, that is,
the set of C&nbsp;functions available to the host program to communicate
with Lua.
All API functions and related types and constants
are declared in the header file <a name="pdf-lua.h"><code>lua.h</code></a>.


<p>
Even when we use the term "function",
any facility in the API may be provided as a macro instead.
All such macros use each of their arguments exactly once
(except for the first argument, which is always a Lua state),
and so do not generate any hidden side-effects.


<p>
As in most C&nbsp;libraries,
the Lua API functions do not check their arguments for validity or consistency.
However, you can change this behavior by compiling Lua
with a proper definition for the macro <a name="pdf-luai_apicheck"><code>luai_apicheck</code></a>,
in file <code>luaconf.h</code>.



<h2>3.1 - <a name="3.1">The Stack</a></h2>

<p>
Lua uses a <em>virtual stack</em> to pass values to and from C.
Each element in this stack represents a Lua value
(<b>nil</b>, number, string, etc.).


<p>
Whenever Lua calls C, the called function gets a new stack,
which is independent of previous stacks and of stacks of
C&nbsp;functions that are still active.
This stack initially contains any arguments to the C&nbsp;function
and it is where the C&nbsp;function pushes its results
to be returned to the caller (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
For convenience,
most query operations in the API do not follow a strict stack discipline.
Instead, they can refer to any element in the stack
by using an <em>index</em>:
A positive index represents an <em>absolute</em> stack position
(starting at&nbsp;1);
a negative index represents an <em>offset</em> relative to the top of the stack.
More specifically, if the stack has <em>n</em> elements,
then index&nbsp;1 represents the first element
(that is, the element that was pushed onto the stack first)
and
index&nbsp;<em>n</em> represents the last element;
index&nbsp;-1 also represents the last element
(that is, the element at the top)
and index <em>-n</em> represents the first element.
We say that an index is <em>valid</em>
if it lies between&nbsp;1 and the stack top
(that is, if <code>1 &le; abs(index) &le; top</code>).
 





<h2>3.2 - <a name="3.2">Stack Size</a></h2>

<p>
When you interact with Lua API,
you are responsible for ensuring consistency.
In particular,
<em>you are responsible for controlling stack overflow</em>.
You can use the function <a href="#lua_checkstack"><code>lua_checkstack</code></a>
to grow the stack size.


<p>
Whenever Lua calls C,
it ensures that at least <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> stack positions are available.
<code>LUA_MINSTACK</code> is defined as 20,
so that usually you do not have to worry about stack space
unless your code has loops pushing elements onto the stack.


<p>
Most query functions accept as indices any value inside the
available stack space, that is, indices up to the maximum stack size
you have set through <a href="#lua_checkstack"><code>lua_checkstack</code></a>.
Such indices are called <em>acceptable indices</em>.
More formally, we define an <em>acceptable index</em>
as follows:

<pre>
     (index &lt; 0 &amp;&amp; abs(index) &lt;= top) ||
     (index &gt; 0 &amp;&amp; index &lt;= stackspace)
</pre><p>
Note that 0 is never an acceptable index.





<h2>3.3 - <a name="3.3">Pseudo-Indices</a></h2>

<p>
Unless otherwise noted,
any function that accepts valid indices can also be called with
<em>pseudo-indices</em>,
which represent some Lua values that are accessible to C&nbsp;code
but which are not in the stack.
Pseudo-indices are used to access the thread environment,
the function environment,
the registry,
and the upvalues of a C&nbsp;function (see <a href="#3.4">&sect;3.4</a>).


<p>
The thread environment (where global variables live) is
always at pseudo-index <a name="pdf-LUA_GLOBALSINDEX"><code>LUA_GLOBALSINDEX</code></a>.
The environment of the running C&nbsp;function is always
at pseudo-index <a name="pdf-LUA_ENVIRONINDEX"><code>LUA_ENVIRONINDEX</code></a>.


<p>
To access and change the value of global variables,
you can use regular table operations over an environment table.
For instance, to access the value of a global variable, do

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, varname);
</pre>




<h2>3.4 - <a name="3.4">C Closures</a></h2>

<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
thus creating a <em>C&nbsp;closure</em>;
these values are called <em>upvalues</em> and are
accessible to the function whenever it is called
(see <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>).


<p>
Whenever a C&nbsp;function is called,
its upvalues are located at specific pseudo-indices.
These pseudo-indices are produced by the macro
<a name="lua_upvalueindex"><code>lua_upvalueindex</code></a>.
The first value associated with a function is at position
<code>lua_upvalueindex(1)</code>, and so on.
Any access to <code>lua_upvalueindex(<em>n</em>)</code>,
where <em>n</em> is greater than the number of upvalues of the
current function,
produces an acceptable (but invalid) index.





<h2>3.5 - <a name="3.5">Registry</a></h2>

<p>
Lua provides a <em>registry</em>,
a pre-defined table that can be used by any C&nbsp;code to
store whatever Lua value it needs to store.
This table is always located at pseudo-index
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>.
Any C&nbsp;library can store data into this table,
but it should take care to choose keys different from those used
by other libraries, to avoid collisions.
Typically, you should use as key a string containing your library name
or a light userdata with the address of a C&nbsp;object in your code.


<p>
The integer keys in the registry are used by the reference mechanism,
implemented by the auxiliary library,
and therefore should not be used for other purposes.





<h2>3.6 - <a name="3.6">Error Handling in C</a></h2>

<p>
Internally, Lua uses the C <code>longjmp</code> facility to handle errors.
(You can also choose to use exceptions if you use C++;
see file <code>luaconf.h</code>.)
When Lua faces any error
(such as memory allocation errors, type errors, syntax errors,
and runtime errors)
it <em>raises</em> an error;
that is, it does a long jump.
A <em>protected environment</em> uses <code>setjmp</code>
to set a recover point;
any error jumps to the most recent active recover point.


<p>
Almost any function in the API may raise an error,
for instance due to a memory allocation error.
The following functions run in protected mode
(that is, they create a protected environment to run),
so they never raise an error:
<a href="#lua_newstate"><code>lua_newstate</code></a>, <a href="#lua_close"><code>lua_close</code></a>, <a href="#lua_load"><code>lua_load</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a>, and <a href="#lua_cpcall"><code>lua_cpcall</code></a>.


<p>
Inside a C&nbsp;function you can raise an error by calling <a href="#lua_error"><code>lua_error</code></a>.





<h2>3.7 - <a name="3.7">Functions and Types</a></h2>

<p>
Here we list all functions and types from the C&nbsp;API in
alphabetical order.



<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
The type of the memory-allocation function used by Lua states.
The allocator function must provide a
functionality similar to <code>realloc</code>,
but not exactly the same.
Its arguments are
<code>ud</code>, an opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
<code>osize</code>, the original size of the block;
<code>nsize</code>, the new size of the block.
<code>ptr</code> is <code>NULL</code> if and only if <code>osize</code> is zero.
When <code>nsize</code> is zero, the allocator must return <code>NULL</code>;
if <code>osize</code> is not zero,
it should free the block pointed to by <code>ptr</code>.
When <code>nsize</code> is not zero, the allocator returns <code>NULL</code>
if and only if it cannot fill the request.
When <code>nsize</code> is not zero and <code>osize</code> is zero,
the allocator should behave like <code>malloc</code>.
When <code>nsize</code> and <code>osize</code> are not zero,
the allocator behaves like <code>realloc</code>.
Lua assumes that the allocator never fails when
<code>osize &gt;= nsize</code>.


<p>
Here is a simple implementation for the allocator function.
It is used in the auxiliary library by <a href="#lua_newstate"><code>lua_newstate</code></a>.

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
       (void)ud;     /* not used */
       (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);  /* ANSI requires that free(NULL) has no effect */
         return NULL;
       }
       else
         /* ANSI requires that realloc(NULL, size) == malloc(size) */
         return realloc(ptr, nsize);
     }
</pre>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Sets a new panic function and returns the old one.


<p>
If an error happens outside any protected environment,
Lua calls a <em>panic function</em>
and then calls <code>exit(EXIT_FAILURE)</code>,
thus exiting the host application.
Your panic function may avoid this exit by
never returning (e.g., doing a long jump).


<p>
The panic function can access the error message at the top of the stack.





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Calls a function.


<p>
To call a function you must use the following protocol:
first, the function to be called is pushed onto the stack;
then, the arguments to the function are pushed
in direct order;
that is, the first argument is pushed first.
Finally you call <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> is the number of arguments that you pushed onto the stack.
All arguments and the function value are popped from the stack
when the function is called.
The function results are pushed onto the stack when the function returns.
The number of results is adjusted to <code>nresults</code>,
unless <code>nresults</code> is <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>.
In this case, <em>all</em> results from the function are pushed.
Lua takes care that the returned values fit into the stack space.
The function results are pushed onto the stack in direct order
(the first result is pushed first),
so that after the call the last result is on the top of the stack.


<p>
Any error inside the called function is propagated upwards
(with a <code>longjmp</code>).


<p>
The following example shows how the host program may do the
equivalent to this Lua code:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Here it is in&nbsp;C:

<pre>
     lua_getfield(L, LUA_GLOBALSINDEX, "f");          /* function to be called */
     lua_pushstring(L, "how");                                 /* 1st argument */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");            /* table to be indexed */
     lua_getfield(L, -1, "x");                 /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                           /* remove 't' from the stack */
     lua_pushinteger(L, 14);                                   /* 3rd argument */
     lua_call(L, 3, 1);         /* call function with 3 arguments and 1 result */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* set global variable 'a' */
</pre><p>
Note that the code above is "balanced":
at its end, the stack is back to its original configuration.
This is considered good programming practice.





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Type for C&nbsp;functions.


<p>
In order to communicate properly with Lua,
a C&nbsp;function must use the following protocol,
which defines the way parameters and results are passed:
a C&nbsp;function receives its arguments from Lua in its stack
in direct order (the first argument is pushed first).
So, when the function starts,
<code>lua_gettop(L)</code> returns the number of arguments received by the function.
The first argument (if any) is at index 1
and its last argument is at index <code>lua_gettop(L)</code>.
To return values to Lua, a C&nbsp;function just pushes them onto the stack,
in direct order (the first result is pushed first),
and returns the number of results.
Any other value in the stack below the results will be properly
discarded by Lua.
Like a Lua function, a C&nbsp;function called by Lua can also return
many results.


<p>
As an example, the following function receives a variable number
of numerical arguments and returns their average and sum:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument to function 'average'");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3>
<pre>int lua_checkstack (lua_State *L, int extra);</pre>

<p>
Ensures that there are at least <code>extra</code> free stack slots in the stack.
It returns false if it cannot grow the stack to that size.
This function never shrinks the stack;
if the stack is already larger than the new size,
it is left unchanged.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3>
<pre>void lua_close (lua_State *L);</pre>

<p>
Destroys all objects in the given Lua state
(calling the corresponding garbage-collection metamethods, if any)
and frees all dynamic memory used by this state.
On several platforms, you may not need to call this function,
because all resources are naturally released when the host program ends.
On the other hand, long-running programs,
such as a daemon or a web server,
might need to release states as soon as they are not needed,
to avoid growing too large.





<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Concatenates the <code>n</code> values at the top of the stack,
pops them, and leaves the result at the top.
If <code>n</code>&nbsp;is&nbsp;1, the result is the single string on the stack
(that is, the function does nothing);
if <code>n</code> is 0, the result is the empty string.
Concatenation is done following the usual semantics of Lua
(see <a href="#2.5.4">&sect;2.5.4</a>).





<hr><h3><a name="lua_cpcall"><code>lua_cpcall</code></a></h3>
<pre>int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</pre>

<p>
Calls the C&nbsp;function <code>func</code> in protected mode.
<code>func</code> starts with only one element in its stack,
a light userdata containing <code>ud</code>.
In case of errors,
<a href="#lua_cpcall"><code>lua_cpcall</code></a> returns the same error codes as <a href="#lua_pcall"><code>lua_pcall</code></a>,
plus the error object on the top of the stack;
otherwise, it returns zero, and does not change the stack.
All values returned by <code>func</code> are discarded.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
The new table has space pre-allocated
for <code>narr</code> array elements and <code>nrec</code> non-array elements.
This pre-allocation is useful when you know exactly how many elements
the table will have.
Otherwise you can use the function <a href="#lua_newtable"><code>lua_newtable</code></a>.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3>
<pre>int lua_dump (lua_State *L, lua_Writer writer, void *data);</pre>

<p>
Dumps a function as a binary chunk.
Receives a Lua function on the top of the stack
and produces a binary chunk that,
if loaded again,
results in a function equivalent to the one dumped.
As it produces parts of the chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls function <code>writer</code> (see <a href="#lua_Writer"><code>lua_Writer</code></a>)
with the given <code>data</code>
to write them.


<p>
The value returned is the error code returned by the last
call to the writer;
0 means no errors.


<p>
This function does not pop the Lua function from the stack.





<hr><h3><a name="lua_equal"><code>lua_equal</code></a></h3>
<pre>int lua_equal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in acceptable indices <code>index1</code> and
<code>index2</code> are equal,
following the semantics of the Lua <code>==</code> operator
(that is, may call metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices is non valid.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3>
<pre>int lua_error (lua_State *L);</pre>

<p>
Generates a Lua error.
The error message (which can actually be a Lua value of any type)
must be on the stack top.
This function does a long jump,
and therefore never returns.
(see <a href="#luaL_error"><code>luaL_error</code></a>).





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
Controls the garbage collector.


<p>
This function performs several tasks,
according to the value of the parameter <code>what</code>:

<ul>

<li><b><code>LUA_GCSTOP</code>:</b>
stops the garbage collector.
</li>

<li><b><code>LUA_GCRESTART</code>:</b>
restarts the garbage collector.
</li>

<li><b><code>LUA_GCCOLLECT</code>:</b>
performs a full garbage-collection cycle.
</li>

<li><b><code>LUA_GCCOUNT</code>:</b>
returns the current amount of memory (in Kbytes) in use by Lua.
</li>

<li><b><code>LUA_GCCOUNTB</code>:</b>
returns the remainder of dividing the current amount of bytes of
memory in use by Lua by 1024.
</li>

<li><b><code>LUA_GCSTEP</code>:</b>
performs an incremental step of garbage collection.
The step "size" is controlled by <code>data</code>
(larger values mean more steps) in a non-specified way.
If you want to control the step size
you must experimentally tune the value of <code>data</code>.
The function returns 1 if the step finished a
garbage-collection cycle.
</li>

<li><b><code>LUA_GCSETPAUSE</code>:</b>
sets <code>data</code>/100 as the new value
for the <em>pause</em> of the collector (see <a href="#2.10">&sect;2.10</a>).
The function returns the previous value of the pause.
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>:</b>
sets <code>arg</code>/100 as the new value for the <em>step multiplier</em> of
the collector (see <a href="#2.10">&sect;2.10</a>).
The function returns the previous value of the step multiplier.
</li>

</ul>




<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Returns the memory-allocation function of a given state.
If <code>ud</code> is not <code>NULL</code>, Lua stores in <code>*ud</code> the
opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>.





<hr><h3><a name="lua_getfenv"><code>lua_getfenv</code></a></h3>
<pre>void lua_getfenv (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the environment table of
the value at the given index.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3>
<pre>void lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given valid index <code>index</code>.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3>
<pre>void lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Pushes onto the stack the value of the global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
</pre>




<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the metatable of the value at the given
acceptable index.
If the index is not valid,
or if the value does not have a metatable,
the function returns&nbsp;0 and pushes nothing on the stack.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3>
<pre>void lua_gettable (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given valid index <code>index</code>
and <code>k</code> is the value at the top of the stack.


<p>
This function pops the key from the stack
(putting the resulting value in its place).
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Returns the index of the top element in the stack.
Because indices start at&nbsp;1,
this result is equal to the number of elements in the stack
(and so 0&nbsp;means an empty stack).





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index,
shifting up the elements above this index to open space.
Cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ptrdiff_t lua_Integer;</pre>

<p>
The type used by the Lua API to represent integral values.


<p>
By default it is a <code>ptrdiff_t</code>,
which is usually the largest integral type the machine handles
"comfortably".





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index has type boolean,
and 0 otherwise.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a C&nbsp;function,
and 0 otherwise.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a function
(either C or Lua), and 0 otherwise.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a light userdata,
and 0 otherwise.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is <b>nil</b>,
and 0 otherwise.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a number
or a string convertible to a number,
and 0 otherwise.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a string
or a number (which is always convertible to a string),
and 0 otherwise.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a table,
and 0 otherwise.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a thread,
and 0 otherwise.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given acceptable index is a userdata
(either full or light), and 0 otherwise.





<hr><h3><a name="lua_lessthan"><code>lua_lessthan</code></a></h3>
<pre>int lua_lessthan (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the value at acceptable index <code>index1</code> is smaller
than the value at acceptable index <code>index2</code>,
following the semantics of the Lua <code>&lt;</code> operator
(that is, may call metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices is non valid.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</pre>

<p>
Loads a Lua chunk.
If there are no errors,
<a href="#lua_load"><code>lua_load</code></a> pushes the compiled chunk as a Lua
function on top of the stack.
Otherwise, it pushes an error message.
The return values of <a href="#lua_load"><code>lua_load</code></a> are:

<ul>

<li><b>0:</b> no errors;</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>:</b>
syntax error during pre-compilation;</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b>
memory allocation error.</li>

</ul>

<p>
This function only loads a chunk;
it does not run it.


<p>
<a href="#lua_load"><code>lua_load</code></a> automatically detects whether the chunk is text or binary,
and loads it accordingly (see program <code>luac</code>).


<p>
<a href="#lua_load"><code>lua_load</code></a> uses a user-supplied <code>reader</code> function to read the chunk
(see <a href="#lua_Reader"><code>lua_Reader</code></a>).
The <code>data</code> argument is an opaque value passed to the reader function.


<p>
The <code>chunkname</code> argument gives a name to the chunk,
which is used for error messages and in debug information (see <a href="#3.8">&sect;3.8</a>).





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
Creates a new, independent state.
Returns <code>NULL</code> if cannot create the state
(due to lack of memory).
The argument <code>f</code> is the allocator function;
Lua does all memory allocation for this state through this function.
The second argument, <code>ud</code>, is an opaque pointer that Lua
simply passes to the allocator in every call.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
It is equivalent to <code>lua_createtable(L, 0, 0)</code>.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Creates a new thread, pushes it on the stack,
and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.
The new state returned by this function shares with the original state
all global objects (such as tables),
but has an independent execution stack.


<p>
There is no explicit function to close or to destroy a thread.
Threads are subject to garbage collection,
like any Lua object.





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
This function allocates a new block of memory with the given size,
pushes onto the stack a new full userdata with the block address,
and returns this address.


<p>
Userdata represents C&nbsp;values in Lua.
A <em>full userdata</em> represents a block of memory.
It is an object (like a table):
you must create it, it can have its own metatable,
and you can detect when it is being collected.
A full userdata is only equal to itself (under raw equality).


<p>
When Lua collects a full userdata with a <code>gc</code> metamethod,
Lua calls the metamethod and marks the userdata as finalized.
When this userdata is collected again then
Lua frees its corresponding memory.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Pops a key from the stack,
and pushes a key-value pair from the table at the given index
(the "next" pair after the given key).
If there are no more elements in the table,
then <a href="#lua_next"><code>lua_next</code></a> returns 0 (and pushes nothing).


<p>
A typical traversal looks like this:

<pre>
     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* 'key' is at index -2 and 'value' at index -1 */
       printf("%s - %s\n",
         lua_typename(L, lua_type(L, -2)), lua_typename(L, lua_type(L, -1)));
       lua_pop(L, 1);  /* removes 'value'; keeps 'key' for next iteration */
     }
</pre>

<p>
While traversing a table,
do not call <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,
unless you know that the key is actually a string.
Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> <em>changes</em>
the value at the given index;
this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
The type of numbers in Lua.
By default, it is double, but that can be changed in <code>luaconf.h</code>.


<p>
Through the configuration file you can change
Lua to operate with another type for numbers (e.g., float or long).





<hr><h3><a name="lua_objlen"><code>lua_objlen</code></a></h3>
<pre>size_t lua_objlen (lua_State *L, int index);</pre>

<p>
Returns the "length" of the value at the given acceptable index:
for strings, this is the string length;
for tables, this is the result of the length operator ('<code>#</code>');
for userdata, this is the size of the block of memory allocated
for the userdata;
for other values, it is&nbsp;0.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3>
<pre>lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);</pre>

<p>
Calls a function in protected mode.


<p>
Both <code>nargs</code> and <code>nresults</code> have the same meaning as
in <a href="#lua_call"><code>lua_call</code></a>.
If there are no errors during the call,
<a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.
However, if there is any error,
<a href="#lua_pcall"><code>lua_pcall</code></a> catches it,
pushes a single value on the stack (the error message),
and returns an error code.
Like <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function
and its arguments from the stack.


<p>
If <code>errfunc</code> is 0,
then the error message returned on the stack
is exactly the original error message.
Otherwise, <code>errfunc</code> is the stack index of an
<em>error handler function</em>.
(In the current implementation, this index cannot be a pseudo-index.)
In case of runtime errors,
this function will be called with the error message
and its return value will be the message returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.


<p>
Typically, the error handler function is used to add more debug
information to the error message, such as a stack traceback.
Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,
since by then the stack has unwound.


<p>
The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns 0 in case of success
or one of the following error codes
(defined in <code>lua.h</code>):

<ul>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>:</b>
a runtime error.
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>:</b>
memory allocation error.
For such errors, Lua does not call the error handler function.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>:</b>
error while running the error handler function.
</li>

</ul>




<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Pops <code>n</code> elements from the stack.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Pushes a boolean value with value <code>b</code> onto the stack.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Pushes a new C&nbsp;closure onto the stack.


<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
thus creating a C&nbsp;closure (see <a href="#3.4">&sect;3.4</a>);
these values are then accessible to the function whenever it is called.
To associate values with a C&nbsp;function,
first these values should be pushed onto the stack
(when there are multiple values, the first value is pushed first).
Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
is called to create and push the C&nbsp;function onto the stack,
with the argument <code>n</code> telling how many values should be
associated with the function.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Pushes a C&nbsp;function onto the stack.
This function receives a pointer to a C function
and pushes onto the stack a Lua value of type <code>function</code> that,
when called, invokes the corresponding C&nbsp;function.


<p>
Any function to be registered in Lua must
follow the correct protocol to receive its parameters
and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
The call <code>lua_pushcfunction(L, f)</code> is equivalent to
<code>lua_pushcclosure(L, f, 0)</code>.





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Pushes onto the stack a formatted string
and returns a pointer to this string.
It is similar to the C&nbsp;function <code>sprintf</code>,
but has some important differences:

<ul>

<li>
You do not have to allocate space for the result:
the result is a Lua string and Lua takes care of memory allocation
(and deallocation, through garbage collection).
</li>

<li>
The conversion specifiers are quite restricted.
There are no flags, widths, or precisions.
The conversion specifiers can only be
'<code>%%</code>' (inserts a '<code>%</code>' in the string),
'<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
'<code>%f</code>' (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%p</code>' (inserts a pointer as a hexadecimal numeral),
'<code>%d</code>' (inserts an <code>int</code>), and
'<code>%c</code>' (inserts an <code>int</code> as a character).
</li>

</ul>




<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Pushes a number with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Pushes a light userdata onto the stack.


<p>
Userdata represents C&nbsp;values in Lua.
A <em>light userdata</em> represents a pointer.
It is a value (like a number):
you do not create it, it has no individual metatable,
and it is not collected (as it was never created).
A light userdata is equal to "any"
light userdata with the same C&nbsp;address.





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3>
<pre>void lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Pushes the string pointed to by <code>s</code> with size <code>len</code>
onto the stack.
Lua makes (or reuses) an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string can contain embedded zeros.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Pushes a nil value onto the stack.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Pushes a number with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3>
<pre>void lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Pushes the zero-terminated string pointed to by <code>s</code>
onto the stack.
Lua makes (or reuses) an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string cannot contain embedded zeros;
it is assumed to end at the first zero.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Pushes the thread represented by <code>L</code> onto the stack.
Returns 1 if this thread is the main thread of its state.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Pushes a copy of the element at the given valid index
onto the stack.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, except that it receives a <code>va_list</code>
instead of a variable number of arguments.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in acceptable indices <code>index1</code> and
<code>index2</code> are primitively equal
(that is, without calling metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices are non valid.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3>
<pre>void lua_rawget (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access
(i.e., without metamethods).





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3>
<pre>void lua_rawgeti (lua_State *L, int index, int n);</pre>

<p>
Pushes onto the stack the value <code>t[n]</code>,
where <code>t</code> is the value at the given valid index <code>index</code>.
The access is raw;
that is, it does not invoke metamethods.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment
(i.e., without metamethods).





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3>
<pre>void lua_rawseti (lua_State *L, int index, int n);</pre>

<p>
Does the equivalent of <code>t[n] = v</code>,
where <code>t</code> is the value at the given valid index <code>index</code>
and <code>v</code> is the value at the top of the stack,


<p>
This function pops the value from the stack.
The assignment is raw;
that is, it does not invoke metamethods.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
The reader function used by <a href="#lua_load"><code>lua_load</code></a>.
Every time it needs another piece of the chunk,
<a href="#lua_load"><code>lua_load</code></a> calls the reader,
passing along its <code>data</code> parameter.
The reader must return a pointer to a block of memory
with a new piece of the chunk
and set <code>size</code> to the block size.
The block must exist until the reader function is called again.
To signal the end of the chunk, the reader must return <code>NULL</code>.
The reader function may return pieces of any size greater than zero.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Sets the C function <code>f</code> as the new value of global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_register(L,n,f)  (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Removes the element at the given valid index,
shifting down the elements above this index to fill the gap.
Cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Moves the top element into the given position (and pops it),
without shifting any element
(therefore replacing the value at the given position).





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3>
<pre>int lua_resume (lua_State *L, int narg);</pre>

<p>
Starts and resumes a coroutine in a given thread.


<p>
To start a coroutine, you first create a new thread
(see <a href="#lua_newthread"><code>lua_newthread</code></a>);
then you push onto its stack the main function plus any arguments;
then you call <a href="#lua_resume"><code>lua_resume</code></a>,
with <code>narg</code> being the number of arguments.
This call returns when the coroutine suspends or finishes its execution.
When it returns, the stack contains all values passed to <a href="#lua_yield"><code>lua_yield</code></a>,
or all values returned by the body function.
<a href="#lua_resume"><code>lua_resume</code></a> returns
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,
0 if the coroutine finishes its execution
without errors,
or an error code in case of errors (see <a href="#lua_pcall"><code>lua_pcall</code></a>).
In case of errors,
the stack is not unwound,
so you can use the debug API over it.
The error message is on the top of the stack.
To restart a coroutine, you put on its stack only the values to
be passed as results from <code>yield</code>,
and then call <a href="#lua_resume"><code>lua_resume</code></a>.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Changes the allocator function of a given state to <code>f</code>
with user data <code>ud</code>.





<hr><h3><a name="lua_setfenv"><code>lua_setfenv</code></a></h3>
<pre>int lua_setfenv (lua_State *L, int index);</pre>

<p>
Pops a table from the stack and sets it as
the new environment for the value at the given index.
If the value at the given index is
neither a function nor a thread nor a userdata,
<a href="#lua_setfenv"><code>lua_setfenv</code></a> returns 0.
Otherwise it returns 1.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given valid index <code>index</code>
and <code>v</code> is the value at the top of the stack,


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Pops a value from the stack and
sets it as the new value of global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</pre>




<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3>
<pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
Pops a table from the stack and
sets it as the new metatable for the value at the given
acceptable index.





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given valid index <code>index</code>,
<code>v</code> is the value at the top of the stack,
and <code>k</code> is the value just below the top.


<p>
This function pops both the key and the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.8">&sect;2.8</a>).





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Accepts any acceptable index, or&nbsp;0,
and sets the stack top to this index.
If the new top is larger than the old one,
then the new elements are filled with <b>nil</b>.
If <code>index</code> is&nbsp;0, then all stack elements are removed.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
Opaque structure that keeps the whole state of a Lua interpreter.
The Lua library is fully reentrant:
it has no global variables.
All information about a state is kept in this structure.


<p>
A pointer to this state must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3>
<pre>int lua_status (lua_State *L);</pre>

<p>
Returns the status of the thread <code>L</code>.


<p>
The status can be 0 for a normal thread,
an error code if the thread finished its execution with an error,
or <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given acceptable index to a C&nbsp;boolean
value (0&nbsp;or&nbsp;1).
Like all tests in Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> returns 1 for any Lua value
different from <b>false</b> and <b>nil</b>;
otherwise it returns 0.
It also returns 0 when called with a non-valid index.
(If you want to accept only actual boolean values,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value's type.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converts a value at the given acceptable index to a C&nbsp;function.
That value must be a C&nbsp;function;
otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3>
<pre>lua_Integer lua_tointeger (lua_State *L, int idx);</pre>

<p>
Converts the Lua value at the given acceptable index
to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.
The Lua value must be a number or a string convertible to a number
(see <a href="#2.2.1">&sect;2.2.1</a>);
otherwise, <a href="#lua_tointeger"><code>lua_tointeger</code></a> returns&nbsp;0.


<p>
If the number is not an integer,
it is truncated in some non-specified way.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converts the Lua value at the given acceptable index to a string
(<code>const char*</code>).
If <code>len</code> is not <code>NULL</code>,
it also sets <code>*len</code> with the string length.
The Lua value must be a string or a number;
otherwise, the function returns <code>NULL</code>.
If the value is a number,
then <a href="#lua_tolstring"><code>lua_tolstring</code></a> also
<em>changes the actual value in the stack to a string</em>.
(This change confuses <a href="#lua_next"><code>lua_next</code></a>
when <a href="#lua_tolstring"><code>lua_tolstring</code></a> is applied to keys during a table traversal.)


<p>
<a href="#lua_tolstring"><code>lua_tolstring</code></a> returns a fully aligned pointer
to a string inside the Lua state.
This string always has a zero ('<code>\0</code>')
after its last character (as in&nbsp;C),
but may contain other zeros in its body.
Because Lua has garbage collection,
there is no guarantee that the pointer returned by <a href="#lua_tolstring"><code>lua_tolstring</code></a>
will be valid after the corresponding value is removed from the stack.





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given acceptable index
to a number (see <a href="#lua_Number"><code>lua_Number</code></a>).
The Lua value must be a number or a string convertible to a number
(see <a href="#2.2.1">&sect;2.2.1</a>);
otherwise, <a href="#lua_tonumber"><code>lua_tonumber</code></a> returns&nbsp;0.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converts the value at the given acceptable index to a generic
C&nbsp;pointer (<code>void*</code>).
The value may be a userdata, a table, a thread, or a function;
otherwise, <a href="#lua_topointer"><code>lua_topointer</code></a> returns <code>NULL</code>.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.


<p>
Typically this function is used only for debug information.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converts the value at the given acceptable index to a Lua thread
(represented as <code>lua_State*</code>).
This value must be a thread;
otherwise, the function returns <code>NULL</code>.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
If the value at the given acceptable index is a full userdata,
returns its block address.
If the value is a light userdata,
returns its pointer.
Otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Returns the type of the value in the given acceptable index,
or <code>LUA_TNONE</code> for a non-valid index
(that is, an index to an "empty" stack position).
The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants
defined in <code>lua.h</code>:
<code>LUA_TNIL</code>,
<code>LUA_TNUMBER</code>,
<code>LUA_TBOOLEAN</code>,
<code>LUA_TSTRING</code>,
<code>LUA_TTABLE</code>,
<code>LUA_TFUNCTION</code>,
<code>LUA_TUSERDATA</code>,
<code>LUA_TTHREAD</code>,
and
<code>LUA_TLIGHTUSERDATA</code>.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3>
<pre>const char *lua_typename  (lua_State *L, int tp);</pre>

<p>
Returns the name of the type encoded by the value <code>tp</code>,
which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
The writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.
Every time it produces another piece of chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls the writer,
passing along the buffer to be written (<code>p</code>),
its size (<code>sz</code>),
and the <code>data</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.


<p>
The writer returns an error code:
0 means no errors;
any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from
calling the writer again.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Exchange values between different threads of the <em>same</em> global state.


<p>
This function pops <code>n</code> values from the stack <code>from</code>,
and pushes them onto the stack <code>to</code>.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3>
<pre>int lua_yield  (lua_State *L, int nresults);</pre>

<p>
Yields a coroutine.


<p>
This function should only be called as the
return expression of a C&nbsp;function, as follows:

<pre>
     return lua_yield (L, nresults);
</pre><p>
When a C&nbsp;function calls <a href="#lua_yield"><code>lua_yield</code></a> in that way,
the running coroutine suspends its execution,
and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.
The parameter <code>nresults</code> is the number of values from the stack
that are passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.







<h2>3.8 - <a name="3.8">The Debug Interface</a></h2>

<p>
Lua has no built-in debugging facilities.
Instead, it offers a special interface
by means of functions and <em>hooks</em>.
This interface allows the construction of different
kinds of debuggers, profilers, and other tools
that need "inside information" from the interpreter.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) number of upvalues */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
A structure used to carry different pieces of
information about an active function.
<a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part
of this structure, for later use.
To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,
call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:

<ul>

<li><b><code>source</code>:</b>
If the function was defined in a string,
then <code>source</code> is that string.
If the function was defined in a file,
then <code>source</code> starts with a '<code>@</code>' followed by the file name.
</li>

<li><b><code>short_src</code>:</b>
a "printable" version of <code>source</code>, to be used in error messages.
</li>

<li><b><code>linedefined</code>:</b>
the line number where the definition of the function starts.
</li>

<li><b><code>lastlinedefined</code>:</b>
the line number where the definition of the function ends.
</li>

<li><b><code>what</code>:</b>
the string <code>"Lua"</code> if the function is a Lua function,
<code>"C"</code> if it is a C&nbsp;function,
<code>"main"</code> if it is the main part of a chunk,
and <code>"tail"</code> if it was a function that did a tail call.
In the latter case,
Lua has no other information about the function.
</li>

<li><b><code>currentline</code>:</b>
the current line where the given function is executing.
When no line information is available,
<code>currentline</code> is set to -1.
</li>

<li><b><code>name</code>:</b>
a reasonable name for the given function.
Because functions in Lua are first-class values,
they do not have a fixed name:
some functions may be the value of multiple global variables,
while others may be stored only in a table field.
The <code>lua_getinfo</code> function checks how the function was
called to find a suitable name.
If it cannot find a name,
then <code>name</code> is set to <code>NULL</code>.
</li>

<li><b><code>namewhat</code>:</b>
explains the <code>name</code> field.
The value of <code>namewhat</code> can be
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code>, or <code>""</code> (the empty string),
according to how the function was called.
(Lua uses the empty string when no other option seems to apply.)
</li>

<li><b><code>nups</code>:</b>
the number of upvalues of the function.
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Returns the current hook function.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Returns the current hook count.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Returns the current hook mask.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Returns information about a specific function or function invocation.


<p>
To get information about a function invocation,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>
To get information about a function you push it onto the stack
and start the <code>what</code> string with the character '<code>&gt;</code>'.
(In that case,
<code>lua_getinfo</code> pops the function in the top of the stack.)
For instance, to know in which line a function <code>f</code> was defined,
you can write the following code:

<pre>
     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Each character in the string <code>what</code>
selects some fields of the structure <code>ar</code> to be filled or
a value to be pushed on the stack:

<ul>

<li><b>'<code>n</code>':</b> fills in the field <code>name</code> and <code>namewhat</code>;
</li>

<li><b>'<code>S</code>':</b>
fills in the fields <code>source</code>, <code>linedefined</code>,
<code>lastlinedefined</code>, <code>what</code>, and <code>short_src</code>;
</li>

<li><b>'<code>l</code>':</b> fills in the field <code>currentline</code>;
</li>

<li><b>'<code>u</code>':</b> fills in the field <code>nups</code>;
</li>

<li><b>'<code>f</code>':</b>
pushes onto the stack the function that is
running at the given level;
</li>

<li><b>'<code>L</code>':</b>
pushes onto the stack a table whose indices are the
numbers of the lines that are valid on the function.
(A <em>valid line</em> is a line with some associated code,
that is, a line where you can put a break point.
Non-valid lines include empty lines and comments.)
</li>

</ul>

<p>
This function returns 0 on error
(for instance, an invalid option in <code>what</code>).





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Gets information about a local variable of a given activation record.
The parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).
The index <code>n</code> selects which local variable to inspect
(1 is the first parameter or active local variable, and so on,
until the last active local variable).
<a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable's value onto the stack
and returns its name.


<p>
Variable names starting with '<code>(</code>' (open parentheses)
represent internal variables
(loop control variables, temporaries, and C&nbsp;function locals).


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Get information about the interpreter runtime stack.


<p>
This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with
an identification of the <em>activation record</em>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
whereas level <em>n+1</em> is the function that has called level <em>n</em>.
When there are no errors, <a href="#lua_getstack"><code>lua_getstack</code></a> returns 1;
when called with a level greater than the stack depth,
it returns 0.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Gets information about a closure's upvalue.
(For Lua functions,
upvalues are the external local variables that the function uses,
and that are consequently included in its closure.)
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> gets the index <code>n</code> of an upvalue,
pushes the upvalue's value onto the stack,
and returns its name.
<code>funcindex</code> points to the closure in the stack.
(Upvalues have no particular order,
as they are active through the whole function.
So, they are numbered in an arbitrary order.)


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than the number of upvalues.
For C&nbsp;functions, this function uses the empty string <code>""</code>
as a name for all upvalues.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Type for debugging hook functions.


<p>
Whenever a hook is called, its <code>ar</code> argument has its field
<code>event</code> set to the specific event that triggered the hook.
Lua identifies these events with the following constants:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILRET"><code>LUA_HOOKTAILRET</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Moreover, for line events, the field <code>currentline</code> is also set.
To get the value of any other field in <code>ar</code>,
the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.
For return events, <code>event</code> may be <code>LUA_HOOKRET</code>,
the normal value, or <code>LUA_HOOKTAILRET</code>.
In the latter case, Lua is simulating a return from
a function that did a tail call;
in this case, it is useless to call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls back Lua to execute a function or a chunk,
this execution occurs without any calls to hooks.





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3>
<pre>int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);</pre>

<p>
Sets the debugging hook function.


<p>
<code>func</code> is the hook function.
<code>mask</code> specifies on which events the hook will be called:
it is formed by a bitwise or of the constants
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
The <code>count</code> argument is only meaningful when the mask
includes <code>LUA_MASKCOUNT</code>.
For each event, the hook is called as explained below:

<ul>

<li><b>The call hook:</b> is called when the interpreter calls a function.
The hook is called just after Lua enters the new function,
before the function gets its arguments.
</li>

<li><b>The return hook:</b> is called when the interpreter returns from a function.
The hook is called just before Lua leaves the function.
You have no access to the values to be returned by the function.
</li>

<li><b>The line hook:</b> is called when the interpreter is about to
start the execution of a new line of code,
or when it jumps back in the code (even to the same line).
(This event only happens while Lua is executing a Lua function.)
</li>

<li><b>The count hook:</b> is called after the interpreter executes every
<code>count</code> instructions.
(This event only happens while Lua is executing a Lua function.)
</li>

</ul>

<p>
A hook is disabled by setting <code>mask</code> to zero.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Sets the value of a local variable of a given activation record.
Parameters <code>ar</code> and <code>n</code> are as in <a href="#lua_getlocal"><code>lua_getlocal</code></a>
(see <a href="#lua_getlocal"><code>lua_getlocal</code></a>).
<a href="#lua_setlocal"><code>lua_setlocal</code></a> assigns the value at the top of the stack
to the variable and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Sets the value of a closure's upvalue.
Parameters <code>funcindex</code> and <code>n</code> are as in <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
(see <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>).
It assigns the value at the top of the stack
to the upvalue and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than the number of upvalues.







<h2>4 - <a name="4">The Auxiliary Library</a></h2>

<p>

The <em>auxiliary library</em> provides several convenient functions
to interface C with Lua.
While the basic API provides the primitive functions for all 
interactions between C and Lua,
the auxiliary library provides higher-level functions for some
common tasks.


<p>
All functions from the auxiliary library
are defined in header file <code>lauxlib.h</code> and
have a prefix <code>luaL_</code>.


<p>
All functions in the auxiliary library are built on
top of the basic API,
and so they provide nothing that cannot be done with this API.


<p>
Several functions in the auxiliary library are used to
check C&nbsp;function arguments.
Their names are always <code>luaL_check*</code> or <code>luaL_opt*</code>.
All of these functions raise an error if the check is not satisfied.
Because the error message is formatted for arguments
(e.g., "<code>bad argument #1</code>"),
you should not use these functions for other stack values.



<h2>4.1 - <a name="4.1">Functions and Types</a></h2>

<p>
Here we list all functions and types from the auxiliary library
in alphabetical order.



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Adds the character <code>c</code> to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Adds the string pointed to by <code>s</code> with length <code>l</code> to
the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The string may contain embedded zeros.





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Adds a string of length <code>n</code> previously copied to the
buffer area (see <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>) to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Adds the zero-terminated string pointed to by <code>s</code>
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The string may not contain embedded zeros.





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Adds the value at the top of the stack
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Pops the value.


<p>
This is the only function on string buffers that can (and must)
be called with an extra element on the stack,
which is the value to be added to the buffer.





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int numarg,
                    const char *extramsg);</pre>

<p>
Checks whether <code>cond</code> is true.
If not, raises an error with the following message,
where <code>func</code> is retrieved from the call stack:

<pre>
     bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>




<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3>
<pre>int luaL_argerror (lua_State *L, int numarg, const char *extramsg);</pre>

<p>
Raises an error with the following message,
where <code>func</code> is retrieved from the call stack:

<pre>
     bad argument #&lt;numarg&gt; to &lt;func&gt; (&lt;extramsg&gt;)
</pre>

<p>
This function never returns,
but it is an idiom to use it in C&nbsp;functions
as <code>return luaL_argerror(<em>args</em>)</code>.





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
Type for a <em>string buffer</em>.


<p>
A string buffer allows C&nbsp;code to build Lua strings piecemeal.
Its pattern of use is as follows:

<ul>

<li>First you declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then you initialize it with a call <code>luaL_buffinit(L, &amp;b)</code>.</li>

<li>
Then you add string pieces to the buffer calling any of
the <code>luaL_add*</code> functions.
</li>

<li>
You finish by calling <code>luaL_pushresult(&amp;b)</code>.
This call leaves the final string on the top of the stack.
</li>

</ul>

<p>
During its normal operation,
a string buffer uses a variable number of stack slots.
So, while using a buffer, you cannot assume that you know where
the top of the stack is.
You can use the stack between successive calls to buffer operations
as long as that use is balanced;
that is,
when you call a buffer operation,
the stack is at the same level
it was immediately after the previous buffer operation.
(The only exception to this rule is <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
After calling <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> the stack is back to its
level when the buffer was initialized,
plus the final string on its top.





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Initializes a buffer <code>B</code>.
This function does not allocate any space;
the buffer must be declared as a variable
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Calls a metamethod.


<p>
If the object at index <code>obj</code> has a metatable and this
metatable has a field <code>e</code>,
this function calls this field and passes the object as its only argument.
In this case this function returns 1 and pushes onto the
stack the value returned by the call.
If there is no metatable or no metamethod,
this function returns 0 (without pushing any value on the stack).





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3>
<pre>void luaL_checkany (lua_State *L, int narg);</pre>

<p>
Checks whether the function has an argument
of any type (including <b>nil</b>) at position <code>narg</code>.





<hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3>
<pre>int luaL_checkint (lua_State *L, int narg);</pre>

<p>
Checks whether the function argument <code>narg</code> is a number
and returns this number cast to an <code>int</code>.





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int narg);</pre>

<p>
Checks whether the function argument <code>narg</code> is a number
and returns this number cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3>
<pre>long luaL_checklong (lua_State *L, int narg);</pre>

<p>
Checks whether the function argument <code>narg</code> is a number
and returns this number cast to a <code>long</code>.





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3>
<pre>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</pre>

<p>
Checks whether the function argument <code>narg</code> is a string
and returns this string;
if <code>l</code> is not <code>NULL</code> fills <code>*l</code>
with the string's length.





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3>
<pre>lua_Number luaL_checknumber (lua_State *L, int narg);</pre>

<p>
Checks whether the function argument <code>narg</code> is a number
and returns this number.





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3>
<pre>int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Checks whether the function argument <code>narg</code> is a string and
searches for this string in the array <code>lst</code>
(which must be NULL-terminated).
Returns the index in the array where the string was found.
Raises an error if the argument is not a string or
if the string cannot be found.


<p>
If <code>def</code> is not <code>NULL</code>,
the function uses <code>def</code> as a default value when
there is no argument <code>narg</code> or if this argument is <b>nil</b>.


<p>
This is a useful function for mapping strings to C&nbsp;enums.
(The usual convention in Lua libraries is
to use strings instead of numbers to select options.)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Grows the stack size to <code>top + sz</code> elements,
raising an error if the stack cannot grow to that size.
<code>msg</code> is an additional text to go into the error message.





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3>
<pre>const char *luaL_checkstring (lua_State *L, int narg);</pre>

<p>
Checks whether the function argument <code>narg</code> is a string
and returns this string.





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3>
<pre>void luaL_checktype (lua_State *L, int narg, int t);</pre>

<p>
Checks whether the function argument <code>narg</code> has type <code>t</code>.





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3>
<pre>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</pre>

<p>
Checks whether the function argument <code>narg</code> is a userdata
of the type <code>tname</code> (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Loads and runs the given file.
It is defined as the following macro:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns 0 if there are no errors
or 1 in case of errors.





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Loads and runs the given string.
It is defined as the following macro:

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns 0 if there are no errors
or 1 in case of errors.





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Raises an error.
The error message format is given by <code>fmt</code>
plus any extra arguments,
following the same rules of <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
It also adds at the beginning of the message the file name and
the line number where the error occurred,
if this information is available.


<p>
This function never returns,
but it is an idiom to use it in C&nbsp;functions
as <code>return luaL_error(<em>args</em>)</code>.





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Pushes onto the stack the field <code>e</code> from the metatable
of the object at index <code>obj</code>.
If the object does not have a metatable,
or if the metatable does not have this field,
returns 0 and pushes nothing.





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3>
<pre>void luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Pushes onto the stack the metatable associated with name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Creates a copy of string <code>s</code> by replacing
any occurrence of the string <code>p</code>
with the string <code>r</code>.
Pushes the resulting string on the stack and returns it.





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Loads a buffer as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the
buffer pointed to by <code>buff</code> with size <code>sz</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.
<code>name</code> is the chunk name,
used for debug information and error messages.





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Loads a file as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the file
named <code>filename</code>.
If <code>filename</code> is <code>NULL</code>,
then it loads from the standard input.
The first line in the file is ignored if it starts with a <code>#</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>,
but it has an extra error code <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
if it cannot open/read the file.


<p>
As <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Loads a string as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in
the zero-terminated string <code>s</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.


<p>
Also as <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
If the registry already has the key <code>tname</code>,
returns 0.
Otherwise,
creates a new table to be used as a metatable for userdata,
adds it to the registry with key <code>tname</code>,
and returns 1.


<p>
In both cases pushes onto the stack the final value associated
with <code>tname</code> in the registry.





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Creates a new Lua state, calling <a href="#lua_newstate"><code>lua_newstate</code></a> with an
allocation function based on the standard&nbsp;C <code>realloc</code> function
and setting a panic function (see <a href="#lua_atpanic"><code>lua_atpanic</code></a>) that prints
an error message to the standard error output in case of fatal
errors.


<p>
Returns the new state,
or <code>NULL</code> if there is a memory allocation error.





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Opens all standard Lua libraries into the given state.





<hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3>
<pre>int luaL_optint (lua_State *L, int narg, int d);</pre>

<p>
If the function argument <code>narg</code> is a number,
returns this number cast to an <code>int</code>.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3>
<pre>lua_Integer luaL_optinteger (lua_State *L, int narg, lua_Integer d);</pre>

<p>
If the function argument <code>narg</code> is a number,
returns this number cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3>
<pre>long luaL_optlong (lua_State *L, int narg, long d);</pre>

<p>
If the function argument <code>narg</code> is a number,
returns this number cast to a <code>long</code>.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3>
<pre>const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</pre>

<p>
If the function argument <code>narg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.


<p>
If <code>l</code> is not <code>NULL</code>,
fills the position <code>*l</code> with the results's length.





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3>
<pre>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</pre>

<p>
If the function argument <code>narg</code> is a number,
returns this number.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3>
<pre>const char *luaL_optstring (lua_State *L, int narg, const char *d);</pre>

<p>
If the function argument <code>narg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Returns an address to a space of size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>
where you can copy a string to be added to buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
After copying the string into this space you must call
<a href="#luaL_addsize"><code>luaL_addsize</code></a> with the size of the string to actually add 
it to the buffer.





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
Finishes the use of buffer <code>B</code> leaving the final string on
the top of the stack.





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
Creates and returns a <em>reference</em>,
in the table at index <code>t</code>,
for the object at the top of the stack (and pops the object).


<p>
A reference is a unique integer key.
As long as you do not manually add integer keys into table <code>t</code>,
<a href="#luaL_ref"><code>luaL_ref</code></a> ensures the uniqueness of the key it returns.
You can retrieve an object referred by reference <code>r</code>
by calling <code>lua_rawgeti(L, t, r)</code>.
Function <a href="#luaL_unref"><code>luaL_unref</code></a> frees a reference and its associated object.


<p>
If the object at the top of the stack is <b>nil</b>,
<a href="#luaL_ref"><code>luaL_ref</code></a> returns the constant <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.
The constant <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> is guaranteed to be different
from any reference returned by <a href="#luaL_ref"><code>luaL_ref</code></a>.





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
Type for arrays of functions to be registered by
<a href="#luaL_register"><code>luaL_register</code></a>.
<code>name</code> is the function name and <code>func</code> is a pointer to
the function.
Any array of <a href="#luaL_Reg"><code>luaL_Reg</code></a> must end with an sentinel entry
in which both <code>name</code> and <code>func</code> are <code>NULL</code>.





<hr><h3><a name="luaL_register"><code>luaL_register</code></a></h3>
<pre>void luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</pre>

<p>
Opens a library.


<p>
When called with <code>libname</code> equal to <code>NULL</code>,
it simply registers all functions in the list <code>l</code>
(see <a href="#luaL_Reg"><code>luaL_Reg</code></a>) into the table on the top of the stack.


<p>
When called with a non-null <code>libname</code>,
creates a new table <code>t</code>,
sets it as the value of the global variable <code>libname</code>,
sets it as the value of <code>package.loaded[libname]</code>,
and registers on it all functions in the list <code>l</code>.
If there is a table in <code>package.loaded[libname]</code> or in
variable <code>libname</code>,
reuses this table instead of creating a new one.


<p>
In any case the function leaves the table
on the top of the stack.





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3>
<pre>const char *luaL_typename (lua_State *L, int idx);</pre>

<p>
Returns the name of the type of the value at index <code>idx</code>.





<hr><h3><a name="luaL_typerror"><code>luaL_typerror</code></a></h3>
<pre>int luaL_typerror (lua_State *L, int narg, const char *tname);</pre>

<p>
Generates an error with a message like

<pre>
     &lt;location&gt;: bad argument &lt;narg&gt; to &lt;function&gt; (&lt;tname&gt; expected, got &lt;realt&gt;)
</pre><p>
where <code>&lt;location&gt;</code> is produced by <a href="#luaL_where"><code>luaL_where</code></a>,
<code>&lt;function&gt;</code> is the name of the current function,
and <code>&lt;realt&gt;</code> is the type name of the actual argument.





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
Releases reference <code>ref</code> from the table at index <code>t</code>
(see <a href="#luaL_ref"><code>luaL_ref</code></a>).
The entry is removed from the table,
so that the referred object can be collected.
The reference <code>ref</code> is also freed to be used again.


<p>
If <code>ref</code> is <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> or <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,
<a href="#luaL_unref"><code>luaL_unref</code></a> does nothing.





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
Pushes onto the stack a string identifying the current position
of the control at level <code>lvl</code> in the call stack.
Typically this string has the format <code>&lt;chunkname&gt;:&lt;currentline&gt;:</code>.
Level&nbsp;0 is the running function,
level&nbsp;1 is the function that called the running function,
etc.


<p>
This function is used to build a prefix for error messages.


<h2><a name="tolua">The toLua++ Library</a></h2>

<p>
This section lists all the C functions interfacing the features of the toLua++ library. Here you can read only the templates written in "<i>tolua++.h</i>".

<pre>
struct tolua_Error {int index; int array; const char* type;};
typedef struct tolua_Error tolua_Error;
const char* tolua_typename(lua_State* L, int lo);
void tolua_error(lua_State* L, char* msg, tolua_Error* err);
int tolua_isnoobj(lua_State* L, int lo, tolua_Error* err);
int tolua_isvalue(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_isboolean(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_isnumber(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_isstring(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_istable(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_isusertable(lua_State* L, int lo, const char* type, int def, tolua_Error* err);
int tolua_isuserdata(lua_State* L, int lo, int def, tolua_Error* err);
int tolua_isusertype(lua_State* L, int lo, const char* type, int def, tolua_Error* err);
int tolua_isvaluearray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_isbooleanarray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_isnumberarray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_isstringarray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_istablearray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_isuserdataarray(lua_State* L, int lo, int dim, int def, tolua_Error* err);
int tolua_isusertypearray(lua_State* L, int lo, const char* type, int dim, int def, tolua_Error* err);
void tolua_open(lua_State* L);
void* tolua_copy(lua_State* L, void* value, unsigned int size);
int tolua_register_gc(lua_State* L, int lo);
int tolua_default_collect(lua_State* tolua_S);
void tolua_usertype(lua_State* L, char* type);
void tolua_beginmodule(lua_State* L, char* name);
void tolua_endmodule(lua_State* L);
void tolua_module(lua_State* L, char* name, int hasvar);
void tolua_cclass(lua_State* L, char* lname, char* name, char* base, lua_CFunction col);
void tolua_function(lua_State* L, char* name, lua_CFunction func);
void tolua_constant(lua_State* L, char* name, double value);
void tolua_variable(lua_State* L, char* name, lua_CFunction get, lua_CFunction set);
void tolua_array(lua_State* L,char* name, lua_CFunction get, lua_CFunction set);
void tolua_pushvalue(lua_State* L, int lo);
void tolua_pushboolean(lua_State* L, int value);
void tolua_pushnumber(lua_State* L, double value);
void tolua_pushstring(lua_State* L, const char* value);
void tolua_pushuserdata(lua_State* L, void* value);
void tolua_pushusertype(lua_State* L, void* value, const char* type);
void tolua_pushusertype_and_takeownership(lua_State* L, void* value, const char* type);
void tolua_pushfieldvalue(lua_State* L, int lo, int index, int v);
void tolua_pushfieldboolean(lua_State* L, int lo, int index, int v);
void tolua_pushfieldnumber(lua_State* L, int lo, int index, double v);
void tolua_pushfieldstring(lua_State* L, int lo, int index, const char* v);
void tolua_pushfielduserdata(lua_State* L, int lo, int index, void* v);
void tolua_pushfieldusertype(lua_State* L, int lo, int index, void* v, const char* type);
void tolua_pushfieldusertype_and_takeownership(lua_State* L, int lo, int index, void* v, const char* type);
double tolua_tonumber(lua_State* L, int narg, double def);
const char* tolua_tostring(lua_State* L, int narg, const char* def);
void* tolua_touserdata(lua_State* L, int narg, void* def);
void* tolua_tousertype(lua_State* L, int narg, void* def);
int tolua_tovalue(lua_State* L, int narg, int def);
int tolua_toboolean(lua_State* L, int narg, int def);
double tolua_tofieldnumber(lua_State* L, int lo, int index, double def);
const char* tolua_tofieldstring(lua_State* L, int lo, int index, const char* def);
void* tolua_tofielduserdata(lua_State* L, int lo, int index, void* def);
void* tolua_tofieldusertype(lua_State* L, int lo, int index, void* def);
int tolua_tofieldvalue(lua_State* L, int lo, int index, int def);
int tolua_getfieldboolean(lua_State* L, int lo, int index, int def);
void tolua_dobuffer(lua_State* L, char* B, unsigned int size, const char* name);
int class_gc_event(lua_State* L);
#define tolua_tocppstring tolua_tostring
#define tolua_tofieldcppstring tolua_tofieldstring
int tolua_fast_isa(lua_State *L, int mt_indexa, int mt_indexb, int super_index);
</pre>

<p><a href=#index>Index</a>


<hr><p><a name="engine_interface"><h3>5.2 APOCALYX Engine functions</h3></a>

This section lists all the C functions interfacing the features of the APOCALYX engine. The function are very similar to the corresponding ones of the LUA interface, so read the description of their arguments in the LUA APIs. Here you can read only the templates written in "<i>apocalyx.h</i>".

<pre>
//// 3D engine
// Vector
typedef struct Vector Vector;
Vector* vectorCreate(float x, float y, float z);
int vectorDelete(Vector* v);
Vector* vectorSet(Vector* v, float x, float y, float z);
Vector* vectorGet(Vector* v, float* x, float* y, float* z);
Vector* vectorAdd(Vector* v, Vector* a);
Vector* vectorSubtract(Vector* v, Vector* a);
Vector* vectorScale(Vector* v, float scale);
float vectorDot(Vector* v, Vector* d);
Vector* vectorCross(Vector* v, Vector* c);
float vectorNorm2(Vector* v);
float vectorDist2(Vector* v, Vector* d);
Vector* vectorNormalize(Vector* v);
// Void
typedef struct Void Void;
Void* pointerReinterpretAsVoid(void* ptr);
// Matrix
typedef struct Matrix Matrix;
Matrix* voidCastToMatrix(Void* v);
Matrix* matrixCreate(void);
int matrixDelete(Matrix* m);
Matrix* matrixSet(Matrix* m, Matrix* clone);
float* matrixGet(Matrix* m);
Matrix* matrixMultiply(Matrix* m, Vector* v);
Matrix* matrixRotate(Matrix* m, Matrix* rot);
Matrix* matrixRotateT(Matrix* m, Matrix* rot);
Matrix* matrixExchangeYZX(Matrix* m);
Matrix* matrixInterpolate(Matrix* m, Matrix* target, float factor);
// Transform
typedef struct Transform Transform;
Matrix* transformCastToMatrix(Transform* t);
Transform* matrixCastToTransform(Matrix* m);
Transform* transformCreate(void);
int transformDelete(Transform* r);
Transform* transformReset(Transform* r);
Transform* transformScale(Transform* r, float sx, float sy, float sz);
Transform* transformMove(Transform* r, Vector* v);
Transform* transformMoveForward(Transform* r, float step);
Transform* transformMoveSide(Transform* r, float step);
Transform* transformMoveUp(Transform* r, float step);
Transform* transformMoveStanding(Transform* r, float step);
Transform* transformRoll(Transform* r, float angle);
Transform* transformYaw(Transform* r, float angle);
Transform* transformPitch(Transform* r, float angle);
Transform* transformRotStanding(Transform* r, float angle);
Transform* transformSetPosition(Transform* r, Vector* v);
Transform* transformGetPosition(Transform* r, Vector* result);
Transform* transformSetViewDirection(Transform* r, Vector* v);
Transform* transformGetViewDirection(Transform* r, Vector* result);
Transform* transformSetUpDirection(Transform* r, Vector* v);
Transform* transformGetUpDirection(Transform* r, Vector* result);
Transform* transformSetSideDirection(Transform* r, Vector* v);
Transform* transformGetSideDirection(Transform* r, Vector* result);
Transform* transformRotAround(Transform* r, float angle);
Transform* transformPointTo(Transform* r, Vector* v);
// Image
typedef struct Image Image;
Image* voidCastToImage(Void* v);
Image* imageRGBCreate(int w, int h);
Image* imageRGBACreate(int w, int h);
Image* imageGrayscaleCreate(int w, int h);
int imageDelete(Image* i);
int imageIsGrayscale(Image* i);
int imageHasAlpha(Image* i);
Image* imageSetPixel(Image* i, int x, int y,
  unsigned char r, unsigned char g, unsigned char b, unsigned char a);
Image* imageGetPixel(Image* i, int x, int y,
  unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a);
Image* imageGetDimension(Image* i, float* w, float* h);
Image* imageConvertTo111A(Image* i, float grayShade);
Image* imageConvertToRGB(Image* i);
Image* imageConvertToRGBA(Image* i);
Image* imageConvertToRGBmA(Image* i);
Image* imageConvertToGray(Image* i);
Image* imageConvertToBump(Image* i, float scaleSide, float scaleWidth);
Image* imageAddAlpha(Image* i, Image* alpha, int threshold, int cutoff);
int imageResample(Image* i, int newWidth, int newHeight);
int saveAsPng(Image* i, const char* fileName, int useFilters);
// OverlayObject
typedef struct OverlayObject OverlayObject;
OverlayObject* voidCastToOverlayObject(Void* v);
OverlayObject* overlayObjectSetVisible(OverlayObject* oo, int v);
OverlayObject* overlayObjectSetLayer(OverlayObject* oo, float layer);
// OverlayFader
typedef struct OverlayFader OverlayFader;
OverlayObject* overlayFaderCastToOverlayObject(OverlayFader* o);
OverlayFader* overlayObjectCastToOverlayFader(OverlayObject* o);
OverlayFader* overlayFaderCreate(void);
OverlayFader* overlayFaderSetColor(
  OverlayFader* of, float r, float g, float b, float a
);
// Font
typedef struct Font Font;
Font* voidCastToFont(Void* v);
Font* texturedFontCreate(int height, int width, int spacing, Image* image);
Font* bitmapFontCreate(
	const char* faceName, float h, float w, int isBold, int isItalic
);
int fontDelete(Font* f);
// Font3D
typedef struct Font3D Font3D;
Font3D* voidCastToFont3D(Void* v);
Font3D* font3DCreate(
  const char* faceName, float h, float w, float d, int isBold, int isItalic
);
int font3DDelete(Font3D* f);
float font3DGetHeight(Font3D* f);
// OverlayText
typedef struct OverlayText OverlayText;
OverlayText* voidCastToOverlayText(Void* v);
OverlayText* overlayTextCreate(const char* string);
OverlayText* overlayTextSetVisible(OverlayText* ot, int v);
OverlayText* overlayTextSetAlignment(OverlayText* ot, int align);
OverlayText* overlayTextSetScale(OverlayText* ot, float scale);
OverlayText* overlayTextSetColor(
  OverlayText* ot, float r, float g, float b, float a
);
OverlayText* overlayTextSetLocation(
  OverlayText* ot, float x, float y);
OverlayText* overlayTextGetLocation(
  OverlayText* ot, float* x, float* y);
OverlayText* overlayTextSetRotation(OverlayText* ot, float rot);
float overlayTextGetRotation(OverlayText* ot);
OverlayText* overlayTextSetText(OverlayText* ot, const char* string);
const char* overlayTextGetText(OverlayText* ot);
// OverlayTexts
typedef struct OverlayTexts OverlayTexts;
OverlayObject* overlayTextsCastToOverlayObject(OverlayTexts* o);
OverlayTexts* overlayObjectCastToOverlayTexts(OverlayObject* o);
OverlayTexts* overlayTextsCreate(Font* f);
OverlayTexts* overlayTextsSetLocation(
  OverlayTexts* ot, float x, float y
);
OverlayTexts* overlayTextsGetLocation(
  OverlayTexts* ot, float *x, float *y
);
OverlayTexts* overlayTextsSetRotation(OverlayTexts* ot, float rot);
float overlayTextsGetRotation(OverlayTexts* ot);
const OverlayText* overlayTextsGetTextAt(OverlayTexts* ot, float x, float y);
const OverlayText* overlayTextsGetText(OverlayTexts* ot, int idx);
OverlayTexts* overlayTextsAdd(OverlayTexts* ots, OverlayText* ot);
OverlayTexts* overlayTextsRemove(OverlayTexts* ots, OverlayText* ot);
int overlayTextsGetCount(OverlayTexts* ot);
// Texture
typedef struct Texture Texture;
Texture* voidCastToTexture(Void* v);
Texture* textureCreate(
  Image* image, int isRepeated, int doMipmaps, int is1D
);
int textureDelete(Texture* t);
// BumpedTexture
typedef struct BumpedTexture BumpedTexture;
Texture* bumpedTextureCastToTexture(BumpedTexture* t);
// AnimatedTexture
typedef struct AnimatedTexture AnimatedTexture;
Texture* animatedTextureCastToTexture(AnimatedTexture* t);
AnimatedTexture* textureCastToAnimatedTexture(Texture* t);
AnimatedTexture* animatedTextureCreate(
  int imagesCount, Image** imagesArray, float duration, int isRepeated
);
// OverlaySprite
typedef struct OverlaySprite OverlaySprite;
OverlayObject* overlaySpriteCastToOverlayObject(OverlaySprite* o);
OverlaySprite* overlayObjectCastToOverlaySprite(OverlayObject* o);
OverlaySprite* overlaySpriteCreate(float w, float h, Texture* t, int hasAlpha);
OverlaySprite* overlaySpriteSetColor(
  OverlaySprite* os,  float r, float g, float b, float a
);
OverlaySprite* overlaySpriteSetLocation(OverlaySprite* os, float x, float y);
OverlaySprite* overlaySpriteGetLocation(OverlaySprite* os, float* x, float* y);
OverlaySprite* overlaySpriteSetRotation(OverlaySprite* os, float rot);
float overlaySpriteGetRotation(OverlaySprite* os);
OverlaySprite* overlaySpriteSetDimension(OverlaySprite* os, float w, float h);
OverlaySprite* overlaySpriteGetDimension(OverlaySprite* os, float* w, float* h);
OverlaySprite* overlaySpriteSetTextureCoord(
  OverlaySprite* os, float l, float b, float r, float t
);
// OverlayPoints
typedef struct OverlayPoints OverlayPoints;
OverlayObject* overlayPointsCastToOverlayObject(OverlayPoints* o);
OverlayPoints* overlayObjectCastToOverlayPoints(OverlayObject* o);
OverlayPoints* overlayPointsCreate(
  int coordCount, float* coords, unsigned char* colors
);
int overlayPointsGetCount(OverlayPoints* p);
OverlayPoints* overlayPointsSetCoordsData(OverlayPoints* p,
  int index, float x, float y);
OverlayPoints* overlayPointsGetCoordsData(OverlayPoints* p,
  int index, float* x, float* y);
OverlayPoints* overlayPointsSetColorsData(OverlayPoints* p,
  int index, float r, float g, float b, float a);
OverlayPoints* overlayPointsGetColorsData(OverlayPoints* p,
  int index, float* r, float* g, float* b, float* a);
OverlayPoints* overlayPointsSetSmoothColor(OverlayPoints* p, int b);
OverlayPoints* overlayPointsSetSize(OverlayPoints* p, float f);
OverlayPoints* overlayPointsSetColor(OverlayPoints* os,
  float r, float g, float b, float a);
OverlayPoints* overlayPointsSetLocation(OverlayPoints* os, float x, float y);
OverlayPoints* overlayPointsGetLocation(OverlayPoints* os, float* x, float* y);
OverlayPoints* overlayPointsSetRotation(OverlayPoints* os, float rot);
float overlayPointsGetRotation(OverlayPoints* os);
// OverlayLines
typedef struct OverlayLines OverlayLines;
OverlayPoints* overlayLinesCastToOverlayPoints(OverlayLines* o);
OverlayLines* overlayPointsCastToOverlayLines(OverlayPoints* o);
OverlayLines* overlayLinesCreate(
  int indexesCount, unsigned short* indexes, int coordCount, float* coords,
  unsigned char* colors
);
OverlayLines* overlayLinesSetStipple(OverlayLines* l, unsigned short pattern, int factor);
OverlayLines* overlayLinesSetModeLineLoop(OverlayLines* l);
OverlayLines* overlayLinesSetModeLineStrip(OverlayLines* l);
// OverlayPolys
typedef struct OverlayPolys OverlayPolys;
OverlayLines* overlayPolysCastToOverlayLines(OverlayPolys* o);
OverlayPolys* overlayLinesCastToOverlayPolys(Lines* o);
OverlayPolys* overlayPolysCreate(
  int indexesCount, unsigned short* indexes, int coordCount, float* coords,
  unsigned char* colors
);
OverlayPolys* overlayPolysSetMask(OverlayPolys* p, unsigned char* mask);
OverlayPolys* overlayPolysSetModeTriangs(OverlayPolys* p);
OverlayPolys* overlayPolysSetModeTriangStrip(OverlayPolys* p);
OverlayPolys* overlayPolysSetModeTriangFan(OverlayPolys* p);
OverlayPolys* overlayPolysSetFillPoint(OverlayPolys* p);
OverlayPolys* overlayPolysSetFillLine(OverlayPolys* p);
// Material
typedef struct Material Material;
Material* voidCastToMaterial(Void* v);
Material* materialCreate(void);
int materialDelete(Material* bm);
Material* materialSetAmbient(Material* m, float r, float g, float b, float a);
Material* materialSetDiffuse(Material* m, float r, float g, float b, float a);
Material* materialSetSpecular(Material* bm, float r, float g, float b, float a);
Material* materialSetEmissive(Material* bm, float r, float g, float b, float a);
Material* materialSetShininess(Material* bm, float s);
Material* materialSetTransparency(Material* bm, float t);
Material* materialSetDiffuseTexture(Material* bm, Texture* t);
Material* materialSetEnlighted(Material* bm, int e);
Material* materialSetEnvironment(Material* m, float e);
Material* materialSetGlossTexture(Material* m, Texture* t);
Material* materialSetEnvironmentTexture(Material* m, Texture* t);
// BumpedMaterial
typedef struct BumpedMaterial BumpedMaterial;
Material* bumpedMaterialCastToMaterial(BumpedMaterial* m);
BumpedMaterial* materialCastToBumpedMaterial(Material* m);
BumpedMaterial* bumpedMaterialCreate(void);
BumpedMaterial* bumpedMaterialSetBump(BumpedMaterial* bm, float b);
BumpedMaterial* bumpedMaterialSetBumpedTexture(BumpedMaterial* bm, BumpedTexture* t);
// Program
typedef struct Program Program;
Program* voidCastToProgram(Void* v);
int programDelete(Program* p);
int programIsValid(Program* p);
Program* programApply(Program* p);
Program* programUnapply(Program* p);
Program* programSetLocalParameter(
  Program* p, int idx, float x, float y, float z, float w
);
Program* programSetEnvParameter(
  Program* p, int idx, float x, float y, float z, float w
);
// VertexProgram
typedef struct VertexProgram VertexProgram;
Program* vertexProgramCastToProgram(VertexProgram* p);
VertexProgram* programCastToVertexProgram(Program* p);
VertexProgram* vertexProgramCreate(const char* asciiSource);
// FragmentProgram
typedef struct FragmentProgram FragmentProgram;
Program* fragmentProgramCastToProgram(FragmentProgram* p);
FragmentProgram* programCastToFragmentProgram(Program* p);
FragmentProgram* fragmentProgramCreate(const char* asciiSource);
// ProgramMaterial
typedef struct ProgramMaterial ProgramMaterial;
Material* programMaterialCastToMaterial(ProgramMaterial* o);
ProgramMaterial* materialCastToProgramMaterial(Material* o);
ProgramMaterial* programMaterialCreate(void);
ProgramMaterial* programMaterialSetVertexProgram(
  ProgramMaterial* pm, VertexProgram* vp
);
ProgramMaterial* programMaterialSetFragmentProgram(
  ProgramMaterial* pm, FragmentProgram* fp
);
ProgramMaterial* programMaterialAddTexture(ProgramMaterial* pm, Texture* t);
// Shader
typedef struct Shader Shader;
Shader* voidCastToShader(Void* v);
int shaderDelete(Shader* s);
int shaderIsCompiled(Shader* s);
Shader* shaderGetInfo(Shader* s, int len, char* buffer);
int shaderCompile(Shader* s, const char* source);
// VertexShader
Shader* vertexShaderCreate(const char* source);
// FragmentShader
Shader* fragmentShaderCreate(const char* source);
// ShaderProgram
typedef struct ShaderProgram ShaderProgram;
ShaderProgram* voidCastToShaderProgram(Void* v);
ShaderProgram* shaderProgramCreate(void);
int shaderProgramDelete(ShaderProgram* sp);
ShaderProgram* shaderProgramGetInfo(ShaderProgram* sp, int len, char* buffer);
ShaderProgram* shaderProgramAttach(ShaderProgram* sp, Shader* s);
ShaderProgram* shaderProgramDetach(ShaderProgram* sp, Shader* s);
int shaderProgramLink(ShaderProgram* sp);
int shaderProgramValidate(ShaderProgram* sp);
ShaderProgram* shaderProgramApply(ShaderProgram* sp);
int shaderProgramGetUniformLocation(ShaderProgram* sp, const char* uniformName);
ShaderProgram* shaderProgramSetUniformFloats(
  ShaderProgram* sp, int index, float x, float y, float z, float w
);
ShaderProgram* shaderProgramSetUniformInt(ShaderProgram* sp, int index, int x);
ShaderProgram* shaderProgramSetUniformMatrix2(
  ShaderProgram* sp, int index, int count, float* array
);
ShaderProgram* shaderProgramSetUniformMatrix3(
  ShaderProgram* sp, int index, int count, float* array
);
ShaderProgram* shaderProgramSetUniformMatrix4(
  ShaderProgram* sp, int index, int count, float* array
);
// ShaderMaterial
typedef struct ShaderMaterial ShaderMaterial;
Material* shaderMaterialCastToMaterial(ShaderMaterial* m);
ShaderMaterial* materialCastToShaderMaterial(Material* m);
ShaderMaterial* shaderMaterialCreate(void);
ShaderMaterial* shaderMaterialSetShaderProgram(
  ShaderMaterial* sm, ShaderProgram* sp
);
ShaderMaterial* shaderMaterialAddTexture(ShaderMaterial* sm, Texture* t);
// Camera
typedef struct Camera Camera;
Transform* cameraCastToTransform(Camera* c);
Camera* transformCastToCamera(Reference* o);
Camera* cameraGetHorizontalView(Camera* c, float* x, float* z);
Camera* cameraProject(GLCamera* c,
  double objX, double objY, double objZ,
  double* winX, double* winY, double* winZ
);
Camera* cameraUnproject(GLCamera* c,
  double winX, double winY, double winZ
  double* objX, double* objY, double* objZ
);
// Object
typedef struct Object Object;
Transform* objectCastToTransform(Object* o);
int objectIsClipped(Object* o);
int objectIsVisible(Object* o);
Object* objectSetVisible(Object* o, int v);
Object* objectSetTransparent(Object* o, int t);
int objectIncludes(Object* o, Vector* p);
float objectGetMaxRadius(Object* o);
Object* objectSetMaxRadius(Object* o, float r);
float objectGetDistance(Object* o);
typedef void (*ObjectCallback)(Object* o, Camera* c);
Object* objectCreate(ObjectCallback renderObject);
// Shadowed
typedef struct Shadowed Shadowed;
typedef struct ShadowedDelegate ShadowedDelegate;
int shadowedIsShadowed(Shadowed* s);
Shadowed* shadowedSetShadowed(Shadowed* s, int b);
Shadowed* shadowedSetShadowOffset(Shadowed* s, float offset);
Shadowed* shadowedSetShadowFadeDistance(Shadowed* s, float distance);
Shadowed* shadowedSetShadowIntensity(Shadowed* s, float intensity);
Shadowed* shadowedAddDelegate(Shadowed* s, ShadowedDelegate* delegate);
Shadowed* shadowedRemoveDelegate(Shadowed* s, ShadowedDelegate* delegate);
int shadowedAreShadowsStatic(Shadowed* s);
Shadowed* shadowedSetShadowsStatic(
  Shadowed* s, int isStatic, Vector* dir
);
// Shadow
typedef struct Shadow Shadow;
Shadow* voidCastToShadow(Void* v);
Shadow* shadowCreate(Object* o, float w, float h, Texture* t);
Shadow* shadowSetMode(Shadow* o, int mode);
Shadow* shadowSetColor(Shadow* o, float r, float g, float b);
Shadow* shadowSetMaxRadius(Shadow* o, float r);
float shadowGetMaxRadius(Shadow* o);
// Objects
typedef struct Objects Objects;
Object* objectsCastToObject(Objects* o);
Objects* objectCastToObjects(Object* o);
Objects* objectsCreate(void);
Objects* objectsAdd(Objects* os, Object* o);
int objectsGetCount(Objects* os);
Object* objectsGetFirst(Objects* os);
Object* objectsGetNext(Objects* os);
// Lod
typedef struct Lod Lod;
Object* lodCastToObject(Lod* o);
Lod* lodCreate(void);
Lod* lodAddLevel(Lod* l, float dist, Object* obj);
// Shape
typedef struct Shape Shape;
Shape* voidCastToShape(Void* v);
Shape* shapeCreate(
  int vertCount, float* vertCoo, float* vertNorm,
  float* vertMap, int triCount, unsigned short* triIndexes
);
int shapeDelete(Shape* s);
int shapeGetVerticesCount(Shape* s);
Shape* shapeSetVertexData(
  Shape* s, int idx, float* coo, float* uv, float* normal
);
Shape* shapeGetVertexData(
  Shape* s, int idx, float* coo, float* uv, float* normal
);
float shapeGetMaxRadius(Shape* s);
Shape* shapeComputeMaxRadius(Shape* s);
Shape* shapeComputeNormals(Shape* s);
Shape* shapeSetDynamic(Shape* s, int d);
Shape* shapeSetTwoSided(Shape* s, int ts);
// ShaderShape
typedef struct ShaderShape ShaderShape;
Shape* shaderShapeCastToShape(ShaderShape* s);
ShaderShape* shaderCastToShaderShape(Shape* s);
ShaderShape* shaderShapeCreate(
  int vertCount, float* vertCoo, float* vertNorm,
  float* vertMap, int triCount, unsigned short* triIndexes
);
ShaderShape* shaderShapeSetColors(
  ShaderShape* s, unsigned char* colors, int colorDim
);
ShaderShape* shaderShapeSetColorData(
  ShaderShape* s, int idx, unsigned char* color
);
ShaderShape* shaderShapeGetColorData(
  ShaderShape* s, int idx, unsigned char* color
);
ShaderShape* shaderShapeSetSecondaryColors(
  ShaderShape* s, unsigned char* colors
);
ShaderShape* shaderShapeSetSecondaryColorData(
  ShaderShape* s, int idx, unsigned char* color
);
ShaderShape* shaderShapeGetSecondaryColorData(
  ShaderShape* s, int idx, unsigned char* color
);
ShaderShape* shaderShapeSetFogCoords(ShaderShape* s, float* fogs);
ShaderShape* shaderShapeSetFogCoordData(ShaderShape* s, int idx, float fog);
float shaderShapeGetFogCoordData(ShaderShape* s, int idx);
ShaderShape* shaderShapeSetTexCoords(
  ShaderShape* s, int texCount, float** texCoords, short* texDims
);
ShaderShape* shaderShapeSetTexCoordData(
  ShaderShape* s, int texIdx, int idx, float* texCoord
);
ShaderShape* shaderShapeGetTexCoordData(
  ShaderShape* s, int texIdx, int idx, float* texCoord
);
// Collider
typedef struct Collider Collider;
Collider* voidCastToCollider(Void* v);
Collider* colliderCreate(Mesh* bm, int isStatic);
int colliderDelete(Collider* c);
Collider* colliderSetShape(Collider* c, Shape* s);
Collider* colliderSetTrianglesCount(Collider* c, int tc);
Collider* colliderAddTriangle(
  Collider* c, float x1[3], float x2[3], float x3[3]
);
Collider* colliderFinalize(Collider* c);
Collider* colliderSetMatrix(Collider* c, Matrix* m);
int colliderCollision(
  Collider* c, Collider* other, Matrix* otherMatrix
);
int ColliderRayCollision(Collider*c, float origin[3], float direc[3]);
int ColliderSphereCollision(Collider*c, float center[3], float radius);
Collider* colliderGetCollidingTriangles(
  Collider* c, float tri1[9], float tri2[9]
);
Collider* colliderGetCollisionPoint(Collider* c, float point[3]);
// PathFound
typedef struct PathFound PathFound;
PathFound* voidCastToPathFound(Void* v);
PathFound* pathFoundCreate();
int pathFoundDelete(PathFound* p);
float pathFoundGetCost(PathFound* p);
int pathFoundGetSize(PathFound* p);
int pathFoundGetNode(PathFound* p, int index);
// PathFinder
typedef struct PathFinder PathFinder;
typedef float (*LeastCostEstimateFunc)(int,int);
typedef int (*AdjacentCostFunc)(int,int**,float**);
PathFinder* voidCastToPathFinder(Void* v);
PathFinder* pathFinderCreate();
int pathFinderDelete(PathFinder* p);
PathFinder* pathFinderSetLeastCostEstimate(PathFinder* p,
  LeastCostEstimateFunc lce);
PathFinder* pathFinderSetAdjacentCost(PathFinder* p,
  AdjacentCostFunc ac);
PathFinder* pathFinderReset(PathFinder* p);
int pathFinderSolve(PathFinder* p, int start, int end, PathFound* path);
// Points
typedef struct Points Points;
Object* pointsCastToObject(Points* o);
Points* objectCastToPoints(Object* o);
Points* pointsCreate(
  int coordCount, float* coords, unsigned char* colors
);
int pointsGetCount(Points* p);
Points* pointsSetCoordsData(Points* p, int index, float x, float y, float z);
Points* pointsGetCoordsData(Points* p, int index, float* x, float* y, float* z);
Points* pointsSetColorsData(Points* p, int index, float r, float g, float b, float a);
Points* pointsGetColorsData(Points* p, int index, float* r, float* g, float* b, float* a);
Points* pointsComputeMaxRadius(Points* p);
Points* pointsSetColor(Points* p, float r, float g, float b, float a);
Points* pointsSetSmoothColor(Points* p, int b);
Points* pointsSetSize(Points* p, float f);
// Lines
typedef struct Lines Lines;
Points* linesCastToPoints(Lines* o);
Lines* pointsCastToLines(Points* o);
Lines* linesCreate(
  int indexesCount, unsigned short* indexes, int coordCount, float* coords,
  unsigned char* colors
);
Lines* linesSetStipple(Lines* l, unsigned short pattern, int factor);
Lines* linesSetModeLineLoop(Lines* l);
Lines* linesSetModeLineStrip(Lines* l);
// Polys
typedef struct Polys Polys;
Lines* polysCastToLines(Polys* o);
Polys* linesCastToPolys(Lines* o);
Polys* polysCreate(
  int indexesCount, unsigned short* indexes, int coordCount, float* coords,
  unsigned char* colors
);
Polys* polysSetMask(Polys* p, unsigned char* mask);
Polys* polysSetModeTriangs(Polys* p);
Polys* polysSetModeTriangStrip(Polys* p);
Polys* polysSetModeTriangFan(Polys* p);
Polys* polysSetFillPoint(Polys* p);
Polys* polysSetFillLine(Polys* p);
// Mesh
typedef struct Mesh Mesh;
Object* meshCastToObject(Mesh* m);
Mesh* objectCastToMesh(Object* o);
Mesh* meshCreate(Shape* s, Material* mt);
int meshDelete(Mesh* o);
Shape* meshGetShape(Mesh* m);
Mesh* meshSetMaterial(Mesh* m, Material* mt);
Material* meshGetMaterial(Mesh* m);
Mesh* meshShowHalo(Mesh* m, float d, float hR, float hG, float hB, float hA);
Mesh* meshHideHalo(Mesh* m);
Mesh* meshClone(Mesh* m);
// BumpedMesh
typedef struct BumpedMesh BumpedMesh;
Mesh* bumpedMeshCastToMesh(BumpedMesh* o);
BumpedMesh* meshCastToBumpedMesh(Mesh* o);
BumpedMesh* bumpedMeshCreate(Shape* s, BumpedMaterial* mt);
BumpedMesh* bumpedMeshClone(BumpedMesh* m);
// BasicModel
typedef struct BasicModel BasicModel;
Object* basicModelCastToObject(BasicModel* t);
BasicModel* objectCastToBasicModel(Object* o);
BasicModel* basicModelLoad(
  const char* path, const char* md2Name,
  const char* imgName, const char* alphaImgName
);
BasicModel* basicModelCreate(BasicModel* clone);
int basicModelDelete(BasicModel* o);
BasicModel* basicModelSetMaterial(BasicModel* m, Material* mt);
Material* basicModelGetMaterial(BasicModel* m);
BasicModel* basicModelRescale(BasicModel* m, float scale);
BasicModel* basicModelSetAnimation(BasicModel* m, int anim, int playBack);
BasicModel* basicModelUpdateAnimation(BasicModel* m);
int basicModelGetStoppedAnimation(BasicModel* m);
BasicModel* basicModelSetAnimationTime(BasicModel* m, float time);
float basicModelGetAnimationTime(BasicModel* m);
// Model
typedef struct Model Model;
Object* modelCastToObject(Model* t);
Model* objectCastToModel(Object* o);
Model* modelLoad(
  const char* path, const char* md3Name,
  const char* imgName, const char* alphaImgName
);
Model* modelCreate(Model* clone);
int modelDelete(Model* o);
Model* modelSetMaterial(Model* m, Material* mt);
Material* modelGetMaterial(Model* m);
Model* modelRescale(Model* m, float scale);
Model* modelSetAnimation(Model* m, int anim, int playBack);
Model* modelUpdateAnimation(Model* m);
int modelGetStoppedAnimation(Model* m);
Model* modelSetAnimationTime(Model* m, float time);
float modelGetAnimationTime(Model* m);
Model* modelLink(Model* m, const char* name, Object* o);
float modelGetYawAngle(Model* m);
Model* modelSetYawAngle(Model* m, float a);
Model* modelAddYawAngle(Model* m, float a, float min, float max);
float modelGetPitchAngle(Model* m);
Model* modelSetPitchAngle(Model* m, float a);
Model* modelAddPitchAngle(Model* m, float a, float min, float max);
// AdvancedModel
typedef struct AdvancedModel AdvancedModel;
Object* advancedModelCastToObject(AdvancedModel* t);
AdvancedModel* objectCastToAdvancedModel(Object* o);
AdvancedModel* advancedModelLoad(const char* fileName, int useHW);
int advancedModelDelete(AdvancedModel* o);
AdvancedModel* advancedModelSetAnimationTime(AdvancedModel* m, float time);
float advancedModelGetAnimationTime(AdvancedModel* m);
AdvancedModel* advancedModelClone(AdvancedModel* m);
AdvancedModel* advancedModelSetLod(AdvancedModel* m, float lod);
AdvancedModel* advancedModelSetScaled(AdvancedModel* m, int b);
AdvancedModel* advancedModelSetCulled(AdvancedModel* m, int b);
int advancedModelGetAnimationsCount(AdvancedModel* m);
int advancedModelBlendCycle(
  AdvancedModel* m, int anim, float weight, float delay
);
int advancedModelClearCycle(AdvancedModel* m, int anim, float delay);
int advancedModelExecuteAction(
  AdvancedModel* m, int anim, float delayIn, float delayOut,
  float weight, int lock
);
int advancedModelRemoveAction(AdvancedModel* m, int anim);
AdvancedModel* advancedModelUpdateAnimation(AdvancedModel* m);
AdvancedModel* advancedModelDisableSprings(AdvancedModel* m);
// Bot
typedef struct Bot Bot;
Model* botCastToModel(Bot* b);
Bot* modelCastToBot(Model* m);
Bot* botLoad(const char* path, const char* modelName, int ownsCaches);
Bot* botCreate(Bot* clone);
int botDelete(Bot* o);
Bot* botRescale(Bot* b, float scale);
Model* botGetLower(Bot* b);
Model* botGetUpper(Bot* b);
Model* botGetHead(Bot* b);
Bot* botSetLowerAnimation(Bot* b, int anim, int playBack);
Bot* botSetUpperAnimation(Bot* b, int anim, int playBack);
int botGetLowerAnimation(Bot* b);
int botGetUpperAnimation(Bot* b);
int botGetLinkMatrix(Bot* b, const char* name, Matrix* m);
Bot* botWalk(Bot* b, float step);
// Mate
typedef struct Mate Mate;
Mate* mateSetStatus(Mate* m, int status);
int mateGetStatus(Mate* m);
Mate* mateSetDead(Mate* m, int v);
int mateIsDead(Mate* m);
Mate* mateSetFlashShown(Mate* m, int v);
int mateIsFlashShown(Mate* m);
Mate* mateSetHeadAngles(Mate* m, float yaw, float pitch);
Mate* mateGetHeadAngles(Mate* m, float* yaw, float* pitch);
Mate* mateAddHeadAngles(
  Mate* m, float yaw, float pitch,
  float minYaw, float maxYaw, float minPitch, float maxPitch
);
Mate* mateSetTorsoAngles(Mate* m, float yaw, float pitch);
Mate* mateGetTorsoAngles(Mate* m, float* yaw, float* pitch);
Mate* mateAddTorsoAngles(
  Mate* m, float yaw, float pitch,
  float minYaw, float maxYaw, float minPitch, float maxPitch
);
Mate* mateSetTorsoAnimation(Mate* m, Bot* b, int anim);
Mate* mateSetLastTorsoAnimation(Mate* m, int anim);
int mateGetCurrentTorsoAnimation(Mate* m);
int mateGetLastTorsoAnimation(Mate* m);
int mateGetStoppedTorsoAnimation(Mate* m);
Mate* mateSetLegsAnimation(Mate* m, Bot* b, int anim);
int mateGetCurrentLegsAnimation(Mate* m);
// WeaponData
typedef struct WeaponData WeaponData;
typedef int (*DataCallback)(int* idx, Vector* pos, int* type, int* attrib);
WeaponData* weaponDataCreate(DataCallback c);
int weaponDataDelete(WeaponData* d);
// Scenery
typedef struct Scenery Scenery;
typedef struct Furniture Furniture;
Shadowed* sceneryCastToShadowed(Scenery* s);
Scenery* shadowedCastToScenery(Shadowed* s);
Furniture* voidCastToFurniture(Void* v);
Scenery* sceneryAddFurniture(Scenery* s, Furniture* f);
Scenery* sceneryRemoveFurniture(Scenery* s, Furniture* f);
Scenery* sceneryEmpty(Scenery* s);
// Teams
typedef struct Teams Teams;
Furniture* teamsCastToFurniture(Teams* o);
Teams* furnitureCastToTeams(Furniture* o);
Teams* teamsCreate(
  int teamsCount, int teamMates, Bot* bot, Material** bodyMaterials,
  Material** torsoMaterials, Model* sign, int weaponsCount,
  Model** weaponModels, Model** flashModels, float lod,
  Texture* shadowTexture, float shadowWidth, float shadowHeight
);
int teamsGetTeamsCount(Teams* t);
int teamsGetMatesCount(Teams* t);
int teamsGetWeaponTypesCount(Teams* t);
Bot* teamsGetBot(Teams* t);
Mate* teamsGetMate(Teams* t, int team, int mate);
Teams* teamsSetWeaponData(Teams* t, WeaponData* d);
// PowerupData
typedef struct PowrupData PowerupData;
PowerupData* powerupDataCreate(DataCallback c);
int powerupDataDelete(PowerupData* d);
// Powerups
typedef struct Powerups Powerups;
Furniture* powerupsCastToFurniture(Powerups* o);
Powerups* furnitureCastToPowerups(Furniture* o);
Powerups* powerupsCreate(
  Model* medikit, Model* food, Model* armor, Model* bullets,
  Model* grenades, Model* target, PowerupData* pd,
  Texture* shadowTexture
);
Powerups* powerupsSetPowerupData(Powerups* p, PowerupData* d);
// Sample
typedef struct Sample Sample;
typedef struct Sound Sound;
Sample* voidCastToSample(Void* v);
Sound* voidCastToSound(Void* v);
int sampleDelete(Sample* s);
Sound* sampleCreateSound(Sample* s);
Sample* sampleSetVolume(Sample* s, unsigned char v);
Sample* sampleSetPan(Sample* s, unsigned char v);
Sample* sampleSetFrequency(Sample* s, unsigned int v);
Sample* sampleSetLooping(Sample* s, int v);
// Sample3D
typedef struct Sample3D Sample3D;
typedef struct Sound3D Sound3D;
Sample* sample3DCastToSample(Sample3D* s);
Sample3D* sampleCastToSample3D(Sample* o);
Sample3D* sample3DCreate(int freq, int bits);
Sound3D* sample3DCreateSound3D(Sample3D* s);
Sample3D* sample3DSetMinDistance(Sample3D* s, float v);
Sample3D* sample3DPlayAt(Sample3D* s,
  float x, float y, float z,float vx, float vy, float vz);
// Sound
int soundDelete(Sound* s);
Sound* soundSetVolume(Sound* s, unsigned char v);
Sound* soundSetPan(Sound* s, unsigned char v);
Sound* soundSetFrequency(Sound* s, unsigned int v);
Sound* soundPlay(Sound* s);
Sound* soundStop(Sound* s);
int soundIsPlaying(Sound* s);
// Sound3D
Sound* sound3DCastToSound(Sound3D* s);
Sound3D* soundCastToSound3D(Sound* o);
Sound3D* sound3DSetAttributes(Sound3D* s, float pos[3], float vel[3]);
// Source
typedef struct Source Source;
Source* voidCastToSource(Void* v);
Source* sourceCreate(Sample3D* s, Object* o, int playing);
Source* sourceSetSound3D(Source* s, Sound3D* sound);
Sound3D* sourceGetSound3D(Source* s);
Source* sourceSetObject(Source* s, Object* o);
Object* sourceGetObject(Source* s);
// CaptureDevice
typedef struct CaptureDevice CaptureDevice;
CaptureDevice* voidCastToCaptureDevice(Void* v);
CaptureDevice* captureDeviceCreate(int maxSamples, int frequency, int bits);
int captureDeviceDelete(CaptureDevice* cd);
CaptureDevice* captureDeviceStart(CaptureDevice* cd);
CaptureDevice* captureDeviceStop(CaptureDevice* cd);
int captureDeviceGetMaxSamples(CaptureDevice* cd);
int captureDeviceGetAcquiredSamples(CaptureDevice* cd);
int captureDeviceGetAvailableSamples(CaptureDevice* cd);
CaptureDevice* captureDeviceSetAvailableSamples(CaptureDevice* cd, int val);
float captureDeviceGetSample(CaptureDevice* cd, int index);
CaptureDevice* captureDeviceSetSample(CaptureDevice* cd, int index, float val);
CaptureDevice* captureDeviceCapture(CaptureDevice* cd);
CaptureDevice* captureDeviceWriteToSample3D(CaptureDevice* cd, Sample3D* s);
Sample3D* captureDeviceCreateSample3D(CaptureDevice* cd);
int captureDeviceSaveAsWav(CaptureDevice* cd, const char* fileName);
// Music
typedef struct Music Music;
Music* voidCastToMusic(Void* v);
int musicDelete(Music* m);
Music* musicSetVolume(Music* m, unsigned char v);
Music* musicSetLooping(Music* m, int v);
Music* musicPlay(Music* m);
Music* musicStop(Music* m);
int musicIsPlaying(Music* m);
// MediaControl
typedef struct MediaControl MediaControl;
MediaControl* voidCastToMediaControl(Void* v);
MediaControl* mediaControlCreate(const char* fileName);
int mediaControlDelete(MediaControl* mc);
int mediaControlOpen(MediaControl* mc, const char* fileName);
MediaControl* mediaControlClose(MediaControl* mc);
int mediaControlGetStart(MediaControl* mc);
int mediaControlGetEnd(MediaControl* mc);
int mediaControlGetPosition(MediaControl* mc);
MediaControl* mediaControlSetRepeat(MediaControl* mc, int b);
MediaControl* mediaControlSetVolume(MediaControl* mc, float vol);
MediaControl* mediaControlSetSpeed(MediaControl* mc, float speed);
int mediaControlSetPosition(MediaControl* mc, int pos);
int mediaControlPlay(MediaControl* mc);
int mediaControlPlayFromTo(MediaControl* mc, int from, int to);
int mediaControlStop(MediaControl* mc);
int mediaControlPause(MediaControl* mc);
int mediaControlResume(MediaControl* mc);
// AmmoData
typedef struct AmmoData AmmoData;
AmmoData* ammoDataCreate(DataCallback c);
int ammoDataDelete(AmmoData* d);
// Ammo
typedef struct Ammo Ammo;
Furniture* ammoCastToFurniture(Ammo* o);
Ammo* furnitureCastToAmmo(Furniture* o);
Ammo* ammoCreate(
  int weaponsCount, float* halfSizes, float* halfExplSizes,
  Texture** textures, Texture** explTextures,
  Sample3D** explSamples, int* soundEnabled,
  AmmoData* ad
);
Ammo* ammoSetAmmoData(Ammo* a, AmmoData* d);
Ammo* ammoSetBulletColor(
  Ammo* a, int weaponType, float r, float g, float b
);
Ammo* ammoSetGrenadeColor(
  Ammo* a, int weaponType, float r, float g, float b
);
// Bsp
typedef struct Bsp Bsp;
Scenery* bspCastToScenery(Bsp* b);
Bsp* sceneryCastToBsp(Scenery* o);
Bsp* bspLoad(const char* path, const char* fileName, float gamma);
Bsp* bspSetTransparenciesVisible(Bsp* b, int v);
Bsp* bspSetUntexturedMeshesVisible(Bsp* b, int v);
Bsp* bspSetUntexturedPatchesVisible(Bsp* b, int v);
Bsp* bspSetDefaultTexture(Bsp* b, Texture* t);
int bspSlideCollision(
  Bsp* b, float pos[3], float vel[3], float ext[3]
);
int bspCheckCollision(
  Bsp* b, float pos[3], float vel[3], float ext[3]
);
Bsp* bspGetCollisionNormal(Bsp* b, float normal[3]);
Bsp* bspGetCollisionTexture(Bsp* b, int* textureID, int* textureContent);
int bspCheckVisibility(Bsp* b, int cluster1, int cluster2);
int bspGetCluster(Bsp* b, float x, float y, float z);
const char* bspGetEntitiesString(Bsp* b);
int bspGetStartingPositionsCount(Bsp* b);
Bsp* bspGetStartingPosition(Bsp*b, int idx, float pos[3]);
int bspGetMedikitPositionsCount(Bsp* b);
Bsp* bspGetMedikitPosition(Bsp*b, int idx, float pos[3]);
int bspGetFoodPositionsCount(Bsp* b);
Bsp* bspGetFoodPosition(Bsp*b, int idx, float pos[3]);
int bspGetArmorPositionsCount(Bsp* b);
Bsp* bspGetArmorPosition(Bsp*b, int idx, float pos[3]);
int bspGetBulletsPositionsCount(Bsp* b);
Bsp* bspGetBulletsPosition(Bsp*b, int idx, float pos[3]);
int bspGetGrenadesPositionsCount(Bsp* b);
Bsp* bspGetGrenadesPosition(Bsp*b, int idx, float pos[3]);
int bspGetWeaponPositionsCount(Bsp* b);
Bsp* bspGetWeaponPosition(Bsp*b, int idx, float pos[3]);
// Sprite
typedef struct Sprite Sprite;
Object* spriteCastToObject(Sprite* s);
Sprite* objectCastToSprite(Object* o);
Sprite* spriteCreate(float w, float h, Material* m);
Sprite* spriteSetSize(Sprite* s, float w, float h);
Sprite* spriteGetSize(Sprite* s, float* w, float* h);
Sprite* spriteSetTextureCoord(
  Sprite* s, float l, float b, float r, float t
);
// AnimatedSprite
typedef struct AnimatedSprite AnimatedSprite;
Sprite* animatedSpriteCastToSprite(AnimatedSprite* s);
AnimatedSprite* spriteCastToAnimatedSprite(Sprite* o);
AnimatedSprite* animatedSpriteCreate(
  float w, float h, float duration, int sideFrame, Material* m
);
AnimatedSprite* animatedSpriteSetDuration(AnimatedSprite* s, float duration);
AnimatedSprite* animatedSpriteSetAnimated(AnimatedSprite* s, int isAnim);
// Sprites
typedef struct Sprites Sprites;
Object* spritesCastToObject(Sprites* s);
Sprites* objectCastToSprites(Object* o);
Sprites* spritesCreate(int cap, float w, float h, Texture* tex, int hasAlpha);
Sprites* spritesAddSprite(Sprites* s, float x, float y, float z);
Sprites* spritesSetColor(Sprites* s, float r, float g, float b);
Sprites* spritesSetSize(Sprites* s, float w, float h);
Sprites* spritesSetTexture(Sprites* s, Texture* texture, int hasAlpha);
Sprites* spritesSetPosition(Sprites* s, int idx, float x, float y, float z);
Sprites* spritesGetPosition(Sprites* s, int idx, float* x, float* y, float* z);
// AxisAligned
typedef struct AxisAligned AxisAligned;
Sprite* axisAlignedCastToSprite(AxisAligned* s);
AxisAligned* spriteCastToAxisAligned(Sprite* o);
AxisAligned* axisAlignedCreate(float w, float h, Material* m);
// Billboard
typedef struct Billboard Billboard;
Sprite* billboardCastToSprite(Billboard* s);
Billboard* spriteCastToBillboard(Sprite* o);
Billboard* billboardCreate(float w, float h, Material* m);
// FadingBillboard
typedef struct FadingBillboard FadingBillboard;
Billboard* fadingBillboardCastToBillboard(FadingBillboard* b);
FadingBillboard* billboardCastToFadingBillboard(Billboard* o);
FadingBillboard* fadingBillboardCreate(
  float fadeNear, float fadeFar, float w, float h, Material* m
);
// AnimatedBillboard
typedef struct AnimatedBillboard AnimatedBillboard;
Billboard* animatedBillboardCastToBillboard(animatedBillboard* b);
AnimatedBillboard* billboardCastToAnimatedBillboard(Billboard* o);
AnimatedBillboard* animatedBillboardCreate(
  float w, float h, float duration, int sideFrame, Material* m
);
AnimatedBillboard* animatedBillboardSetDuration(
  AnimatedBillboard* s, float duration
);
AnimatedBillboard* animatedBillboardSetAnimated(
  AnimatedBillboard* s, int isAnim
);
// Trees
typedef struct Trees Trees;
Object* treesCastToObject(Trees* t);
Trees* objectCastToTrees(Object* o);
Trees* treesCreate(int treesCount, int sideCount, Material* m);
Trees* treesAddTree(Trees* t, float pos[3], float w, float h);
// Emitter
typedef struct Emitter Emitter;
Object* emitterCastToObject(Emitter* t);
Emitter* objectCastToEmitter(Object* o);
Emitter* emitterCreate(
  int particlesCount, float maxLife, float maxRadius, int updateSpeed
);
Emitter* emitterReset(Emitter* e);
Emitter* emitterSetShape(Emitter* e, int shape);
Emitter* emitterSetShapeSize(Emitter* e, float size);
Emitter* emitterSetTexture(Emitter* e, Texture* t, int hasAlpha);
Emitter* emitterSetVelocity(Emitter* e, Vector* v, float speedVar);
Emitter* emitterSetColor(Emitter* e,
  float startR, float startG, float startB, float startA,
  float endR, float endG, float endB, float endA
);
Emitter* emitterSetSize(Emitter* e, float start, float end);
Emitter* emitterSetGravity(Emitter* e, Vector* start, Vector* end);
Emitter* emitterSetAngularSpeed(Emitter* e, float start, float end);
Emitter* emitterSetRadius(Emitter* e, float start, float end);
Emitter* emitterSetMaxLife(Emitter* e, float maxLife);
Emitter* emitterSetOneShot(Emitter* e, int oneShot);
Emitter* emitterSetBurstDuration(Emitter* e, float bd);
// AnimatedEmitter
typedef struct AnimatedEmitter AnimatedEmitter;
Emitter* animatedEmitterCastToEmitter(AnimatedEmitter* t);
AnimatedEmitter* emitterCastToAnimatedEmitter(Emitter* o);
AnimatedEmitter* animatedEmitterCreate(
  int particlesCount, float maxLife, float maxRadius, float duration,
  int sideFrames, int updateSpeed
);
AnimatedEmitter* animatedEmitterSetDuration(AnimatedEmitter* e, float duration);
// Text
typedef struct Text Text;
Object* textCastToObject(Text* t);
Text* objectCastToText(Object* o);
Text* textCreate(const char* string, Font3D* f, Material* m);
// Background
typedef struct Background Background;
Transform* backgroundCastToTransform(Background* b);
Background* transformCastToBackground(Transform* b);
int backgroundDelete(Background* b);
Background* backgroundSetColor(Background* b, float r, float g, float b);
Background* skyCreate(Texture* t[6]);
Background* mirroredSkyCreate(Texture* t[5]);
Background* starFieldCreate(float r, int starsCount, Texture* t, float objSize);
// CloudLayer
typedef struct CloudLayer CloudLayer;
CloudLayer* voidCastToCloudLayer(Void* v);
CloudLayer* cloudLayerCreate(Material* mat, float size, float height, int tiles);
int cloudLayerDelete(GLCloudLayer* cl);
CloudLayer* cloudLayerSetColor(CloudLayer* cl, float r, float g, float b, float a);
CloudLayer* cloudLayerSetSpeed(CloudLayer* cl, float speedX, float speedY);
// HalfSky
typedef struct HalfSky HalfSky;
Background* halfSkyCastToBackground(HalfSky* b);
HalfSky* backgroundCastToHalfSky(Background* b);
HalfSky* halfSkyCreate(Texture* t[5]);
HalfSky* halfSkySetGroundColor(HalfSky* s, float r, float g, float b);
// Skydome
typedef struct Skydome Skydome;
Background* skydomeCastToBackground(Skydome* b);
Skydome* backgroundCastToSkydome(Background* b);
Skydome* skydomeCreate(int merid, int paral, float radius);
Skydome* skydomeSetAtmosphere(
  Skydome* s, float r, float g, float b, float height, float density,
  float minDeg, float maxDeg
);
Skydome* skydomeSetHaze(
  Skydome* s, float r, float g, float b, float height, float density,
  float minDeg, float maxDeg
);
Skydome* skydomeSetRedShift(Skydome* s, float minDeg, float maxDeg);
Skydome* skydomeSetSun(
  Skydome* s, float r, float g, float b, float intensity, Vector* dir
);
Skydome* skydomeUpdate(Skydome* s);
Skydome* skydomeGetSunColor(Skydome* s, float* r, float* g, float* b);
Skydome* skydomeGetFogColor(Skydome* s, float* r, float* g, float* b);
Skydome* skydomeGetCloudColor(Skydome* s, float* r, float* g, float* b);
Skydome* skydomeSetMirrored(Skydome* s, int mirrored);
// Light
typedef struct Light Light;
Object* lightCastToObject(Light* o);
Light* objectCastToLight(Object* o);
Light* lightCreate(Texture* t, float size);
Light* lightSetSize(Light* l, float size);
Light* lightSetColor(Light* l, float r, float g, float b);
Light* lightSetAttenuation(Light* l, float c, float l, float q);
Light* lightSetDirection(Light* l, Vector* dir);
Light* lightSetSpot(Light* l, float cut, float exp);
// FireLight
typedef struct FireLight FireLight;
Light* fireLightCastToLight(FireLight* m);
FireLight* lightCastToFireLight(GLLight* o);
FireLight* fireLightCreate(Texture* t, float size);
FireLight* fireLightSetIntensities(FireLight* l,
  float minR, float minG, float minB, float maxR, float maxG, float maxB
);
// Moon
typedef struct Moon Moon;
Light* moonCastToLight(Moon* m);
Moon* lightCastToMoon(Light* o);
Moon* moonCreate(
  Texture* t, float size, Vector* dir, float cameraDist
);
// Sun
typedef struct Sun Sun;
Light* sunCastToLight(Sun* s);
Sun* lightCastToSun(Light* o);
Sun* sunCreate(
  Texture* t, float size, Vector* dir, Texture* flaresTexture,
  float flaresCount, float flaresSize, float cameraDist, int checkOcclusion
);
// Terrain
typedef struct Terrain Terrain;
Shadowed* terrainCastToShadowed(Terrain* t);
Terrain* shadowedCastToTerrain(Shadowed* t);
int terrainIsReflective(Terrain* t);
Terrain* terrainSetReflective(Terrain* t, int b);
int terrainIsTransparent(Terrain* t);
Terrain* terrainSetTransparent(Terrain* t, int b);
// FlatTerrain
typedef struct FlatTerrain FlatTerrain;
Terrain* flatTerrainCastToTerrain(FlatTerrain* t);
FlatTerrain* terrainCastToFlatTerrain(Terrain* t);
FlatTerrain* flatTerrainCreate(Material* m, float size, int tiles);
// Tiled Terrain
typedef struct TiledTerrain TiledTerrain;
Terrain* tiledTerrainCastToTerrain(TiledTerrain* t);
TiledTerrain* terrainCastToTiledTerrain(Terrain* t);
TiledTerrain* tiledTerrainCreate(
  Material* m, int tilesInTextureSide, Image* tileImage,
  float patchSideLength, int tilesInPatchSide, int defaultTile);
TiledTerrain* tiledTerrainSetMaterial(TiledTerrain* tt, Material* m);
Material* tiledTerrainGetMaterial(TiledTerrain* tt);
int tiledTerrainGetTilesWidth(TiledTerrain* tt);
int tiledTerrainGetTilesHeight(TiledTerrain* tt);
unsigned char tiledTerrainGetTileAtGrid(TiledTerrain* tt, float x, float z);
TiledTerrain* tiledTerrainSetTileAtGrid(TiledTerrain* tt,
  float x, float z, unsigned char t);
Image* tiledTerrainGetImageFromTiles(TiledTerrain* tt);
// Ocean
typedef struct Ocean Ocean;
Terrain* oceanCastToTerrain(Ocean* t);
Ocean* terrainCastToOcean(Terrain* t);
Ocean* oceanCreate(
  Material* m, float waveAmpl, float waveDispl, Vector* wind,
  int surfTileSide, int gridSize, int surfTilesCount, int textTileCount
);
// Patches
typedef struct Patches Patches;
Terrain* patchesCastToTerrain(Patches* t);
Patches* terrainCastToPatches(Terrain* t);
Patches* patchesCreate(
  Image* heightMap, Image* colorMap, Material* m, float sideLen,
  float h, int patchesCount, int repeatsCoarse, int repeatsDetail
);
Patches* patchesSetMaterial(Patches* p, Material* m);
Material* patchesGetMaterial(Patches* p);
float patchesGetHeightAt(Patches* p, float x, float z);
unsigned char patchesGetHeightAtGrid(Patches* p, float x, float z);
Patches* patchesSetHeightAtGrid(Patches* p, float x, float z, unsigned char h);
Patches* patchesGetColorAtGrid(Patches* p, float x, float z,
  unsigned char* r, unsigned char* g, unsigned char* b);
Patches* patchesSetColorAtGrid(Patches* p, float x, float z,
   unsigned char r, unsigned char g, unsigned char b);
float patchesGetLastNormal(Patches* p, Vector* n);
Image* patchesGetImageFromHeight(Patches* p);
Image* patchesGetImageFromColors(Patches* p);
// Heightfield
typedef struct HeightField HeightField;
Object* heightFieldCastToObject(HeightField* o);
ShadowedDelegate* heightFieldCastToShadowedDelegate(HeightField* o);
HeightField* objectCastToHeightField(Object* o);
HeightField* heightFieldCreate(
  Image* heightMap, Material* m, float w, float d, float h,
  float waterLevel, int detailTiles
);
float heightFieldGetHeightAtAbsolute(HeightField* h, float x, float z);
float heightFieldGetHeightAtRelative(HeightField* h, float x, float z);
float heightFieldGetLastNormal(HeightField* h, Vector* n);
HeightField* heightFieldSetHintNoRotation(HeightField* h, int noRot);
// Host
typedef struct Host Host;
Host* voidCastToHost(Void* v);
Host* hostCreate(const char* hostName);
int hostDelete(Host* h);
// Socket
typedef struct Socket Socket;
Socket* voidCastToSocket(Void* v);
int socketDelete(Socket* s);
int socketConnect(Socket* s, Host* h, int port);
int socketListen(Socket* s, int port);
Socket* socketAccept(Socket* s, int bufferLen);
int socketDisconnect(Socket* s);
int socketWaitForEvent(Socket* s, int timeOut);
int socketIsConnectEvent(Socket* s);
int socketIsReadEvent(Socket* s);
int socketIsWriteEvent(Socket* s);
int socketIsCloseEvent(Socket* s);
int socketGetFile(Socket* s, const char* name);
int socketReceive(Socket* s);
const char* socketGetBuffer(Socket* s);
int socketGetDataLength(Socket* s);
// SocketStream
Socket* socketStreamCreate(int bufferLen);
// SocketDatagram
Socket* socketDatagramCreate(int bufferLen);
// Data
typedef struct Data Data;
int dataDelete(Data* d);
const char* dataGetBuffer(Data* d);
int dataGetSize(Data* d);
// Buffer
typedef struct Buffer Buffer;
Buffer* bufferCreate(int increment);
Buffer* bufferCreateFromPointer(int size, const char* ptr);
int bufferDelete(Buffer* b);
Buffer* bufferOpen(Buffer* b, const char* mode);
int bufferClose(Buffer* b);
int bufferRead(void* ptr, int size, int n, Buffer* b);
int bufferWrite(const void* ptr, int size, int n, Buffer* b);
int bufferSeek(Buffer* b, int offset, int whence);
int bufferTell(Buffer* b);
// Zip
typedef struct Zip Zip;
Zip* voidCastToZip(Void* v);
Zip* zipCreate(const char* fileName, int zipped);
int zipDelete(Zip* z);
int zipGotoFirstFile(Zip* z);
int zipGotoNextFile(Zip* z);
Zip* zipGetZippedFileName(Zip* z, char* buffer, int len);
Data* zipCreateData(Zip* z, const char* n);
Image* zipCreateImage(Zip* z, const char* n);
Texture* zipCreateTexture(
  Zip* z, const char* n, int repeat, int doMipmaps, int is1D
);
BumpedTexture* zipCreateBumpedTexture(Zip* z, const char* n, int repeat);
Texture* zipCreateCubeMapTexture(Zip* z, const char* images[6], int doMipmaps);
Objects* zipCreateMeshes(Zip* z, const char* n);
Mesh* zipCreateMesh(Zip* z, const char* n);
Objects* zipCreateShaderMeshes(Zip* z, const char* n);
Mesh* zipCreateShaderMesh(Zip* z, const char* n);
Objects* zipCreateBumpedMeshes(Zip* z, const char* n);
BumpedMesh* zipCreateBumpedMesh(Zip* z, const char* n);
BasicModel* zipCreateBasicModel(Zip* z, const char* n, const char* imageName);
Model* zipCreateModel(Zip* z, const char* n, const char* imageName);
AdvancedModel* zipCreateAdvancedModel(Zip* z, const char* n, int useHW);
Bot* zipCreateBot(Zip* z, const char* n, int ownsCache);
Bsp* zipCreateLevel(Zip* z, const char* n, float gamma);
Sample* zipCreateSample(Zip* z, const char* n);
Sample3D* zipCreateSample3D(Zip* z, const char* n);
Music* zipCreateMusic(Zip* z, const char* n);
// NewZip
typedef struct NewZip NewZip;
NewZip* newZipCreate(const char* fileName);
void newZipDelete(NewZip* z);
int newZipOpenFile(NewZip* z);
int newZipWriteInFile(NewZip* z);
// OverlayWorldView
typedef struct OverlayWorldView OverlayWorldView;
OverlayObject* overlayWorldViewCastToOverlayObject(OverlayWorldView* o);
OverlayWorldView* overlayObjectCastToOverlayWorldView(OverlayObject* o);
OverlayWorldView* overlayWorldViewCreate(float w, float h);
Camera* overlayWorldViewGetCamera(OverlayWorldView* os);
OverlayWorldView* overlayWorldViewSetLocation(OverlayWorldView* os, float x, float y);
OverlayWorldView* overlayWorldViewGetLocation(OverlayWorldView* os, float* x, float* y);
OverlayWorldView* overlayWorldViewSetDimension(OverlayWorldView* os, float w, float h);
OverlayWorldView* overlayWorldViewGetDimension(OverlayWorldView* os, float* w, float* h);
OverlayWorldView* overlayWorldViewSetPerspective(
  OverlayWorldView* os, float fov, float minClip, float maxClip
);
OverlayWorldView* overlayWorldViewSetOrtho(OverlayWorldView* os, float clipPlaneFar);
OverlayWorldView* overlayWorldViewIsOrtho(OverlayWorldView* os);
// OverlayViewport
typedef struct OverlayViewport OverlayViewport;
OverlayWorldView* overlayViewportCastToOverlayWorldView(OverlayViewport* o);
OverlayViewport* overlayWorldViewCastToOverlayViewport(OverlayWorldView* o);
OverlayViewport* overlayViewportCreate(float w, float h);
OverlayViewport* overlayViewportSetColor(
  OverlayViewport* os,  float r, float g, float b, float a
);
OverlayViewport* overlayViewportAddObject(OverlayViewport* os, Object* o);
OverlayViewport* overlayViewportRemoveObject(OverlayViewport* os, Object* o);
OverlayViewport* overlayViewportDeleteObjects(OverlayViewport* os);
OverlayViewport* overlayViewportAddShadow(OverlayViewport* os, Shadow* s);
OverlayViewport* overlayViewportRemoveShadow(OverlayViewport* os, Shadow* s);
OverlayViewport* overlayViewportDeleteShadows(OverlayViewport* os);
OverlayViewport* overlayViewportSetBackground(OverlayViewport* os, Background* b);
OverlayViewport* overlayViewportEnableFog(
  OverlayViewport* os, float dist, float r, float g, float b
);
OverlayViewport* overlayViewportEnableLinearFog(
  OverlayViewport* os, float dist, float maxDist, float r, float g, float b
);
OverlayViewport* overlayViewportDisableFog(OverlayViewport* os);
OverlayViewport* overlayViewportSetSun(OverlayViewport* os, Sun* s);
OverlayViewport* overlayViewportSetTerrain(OverlayViewport* os, Terrain* t);
OverlayViewport* overlayViewportSetScenery(OverlayViewport* os, Scenery* s);
OverlayViewport* overlayViewportEmpty(OverlayViewport* os);
OverlayViewport* overlayViewportSetAmbient(OverlayViewport* os, float r, float g, float b);
// World
void worldAddObject(Object* o);
void worldRemoveObject(Object* o);
void worldDeleteObjects(void);
void worldAddShadow(Shadow* s);
void worldRemoveShadow(Shadow* s);
void worldDeleteShadows(void);
void worldAddLight(Light* l);
void worldRemoveLight(Light* l);
void worldDeleteLights(void);
void worldSetBackground(Background* b, int deleteOld);
void worldAddBackground(Background* b);
void worldRemoveBackground(Background* b);
void worldSetCloudLayer(CloudLayer* cl, int deleteOld);
void worldAddCloudLayer(CloudLayer* cl);
void worldRemoveCloudLayer(CloudLayer* cl);
void worldEnableFog(float dist, float colorR, float colorG, float colorB);
void worldEnableLinearFog(float dist, float maxDist, float colorR, float colorG, float colorB);
void worldDisableFog(void);
void worldSetMoon(Moon* m);
void worldSetSun(Sun* s);
void worldSetTerrain(Terrain* t);
void worldSetScenery(Scenery* s);
void worldEmpty(void);
void worldSetPerspective(float fov, float minClip, float maxClip);
void worldSetViewport(float x, float y, float w, float h);
void worldSetAmbient(float r, float g, float b);
void worldSetClear(float r, float g, float b);
Camera* worldGetCamera(void);
int worldGetSphereRayCollision(
  float center[3], float radius, float origin[3] float dir[3], float point[3]
);
int worldGetSphereSphereCollision(
  float center[3], float radius, float center2[3] float radius2[3], float point[3]
);
void worldAddSource(Source* s);
void worldRemoveSource(Source* s);
void worldDeleteSources(void);
void worldSetListener(
  float forw[3], float top[3], float pos[3], float vel[3]
);
void worldSetListenerScale(float distanceFactor);
// Overlay
Font* overlayGetMainOverlayFont(void);
void overlaySetMainOverlayFont(Font* f);
void overlayAddObject(OverlayObject* o);
void overlayRemoveObject(OverlayObject* o);
void overlayEmpty(void);
void overlaySetPointerVisible(int v);
void overlaySetPointerLocation(float x, float y);
void overlayGetPointerLocation(float* x, float* y);
void overlayMovePointer(
  float dx, float dy, float minX, float minY, float maxX float maxY
);
void overlaySetPointer(OverlaySprite* s);
// ParticleSet
typedef struct ParticleSet ParticleSet;
ParticleSet* voidCastToParticleSet(Void* v);
int particleSetGetID(ParticleSet* p);
ParticleSet* ParticleSetSetID(ParticleSet* p, int id);
int particleSetGetColliderHit(ParticleSet* p);
ParticleSet* ParticleSetSetRadius(ParticleSet* p, double r);
int particleSetGetParticlesCount(ParticleSet* p);
int particleSetWasTerrainHit(ParticleSet* p);
int particleSetWasEnvironmentHit(ParticleSet* p);
ParticleSet* particleSetSetPosition(
  ParticleSet* p, int idx, double x, double y, double z
);
ParticleSet* particleSetGetPosition(
  ParticleSet* p, int idx, double* x, double* y, double* z
);
ParticleSet* particleSetSetVelocity(
  ParticleSet* p, int idx, double vx, double vy, double vz
);
ParticleSet* particleSetGetVelocity(
  ParticleSet* p, int idx, double* vx, double* vy, double* vz
);
// Simulator
typedef struct Simulator Simulator;
Simulator* voidCastToSimulator(Void* v);
Simulator* simulatorCreate(void);
int simulatorDelete(Simulator* s);
Simulator* simulatorAddParticleSet(Simulator* s, ParticleSet* p);
Simulator* simulatorEmpty(Simulator* s);
float simulatorGetDealtaT(Simulator* s);
Simulator* simulatorRunStep(Simulator* s, double time);
// Obstruction
typedef struct Obstruction Obstruction;
Obstruction* voidCastToObstruction(Void* v);
Obstruction* obstructionSetPosition(
  Obstruction* o, double x, double y, double z
);
Obstruction* obstructionSetParticleProjected(
  Obstruction* o, int isProjected
);
Obstruction* sphericalObstructionCreate(
  double x, double y, double z, double r
);
Obstruction* cylindricalObstructionCreate(
  double x, double y, double z, double r, double h
);
Obstruction* boxedObstructionCreate(
  double x, double y, double z, double w, double h, double d
);
Obstruction* prismaticObstructionCreate(
  double x, double y, double z,
  double aX, double aY, double aZ,
  double bX, double bY, double bZ,
  double cX, double cY, double cZ
);
Obstruction* heightfieldObstructionCreate(
  Heightfield* hf, double offset
);
Obstruction* patchedObstructionCreate(
  Patches* p, double offset
);
// Environment
typedef struct Environment Environment;
Environment* voidCastToEnvironment(Void* v);
Environment* environmentCreate(
  double windX, double windY, double windZ, double terrainHeight
);
int environmentDelete(Environment* e);
// Body
typedef struct Body Body;
typedef cdecl (*BodyCallback)(Body* b);
Body* voidCastToBody(Void* v);
Body* bodyCreate(
  BodyCallback* c, Simulator* s, Environment* e, Transform* ref
);
int bodyGetID(Body* b);
Body* bodySetID(Body* b, int id);
int bodyGetColliderHit(Body* b);
Body* bodySetRadius(Body* b, double r);
Body* bodySetPosition(
  Body* b, double x, double y, double z
);
Body* bodyGetPosition(Body* b, double* x, double* y, double* z);
Body* bodySetVelocity(
  Body* b, double vx, double vy, double vz
);
Body* bodyGetVelocity(Body* b, double* vx, double* vy, double* vz);
Body* bodySetOrientation(
  Body* b, double theta, double phi, double rho
);
Body* bodyGetOrientation(
  Body* b, double* theta, double* phi, double* rho
);
Body* bodySetAngularVelocity(
  Body* b, double theta, double phi, double rho
);
Body* bodyGetAngularVelocity(
  Body* b, double* theta, double* phi, double* rho
);
Body* bodySetMass(Body* b, double m);
double bodyGetMass(Body* b);
Body* bodySetMomentOfInertia(
  Body* b, double mX, double mY, double mZ
);
Body* bodyGetMomentOfInertia(
  Body* b, double* mX, double* mY, double* mZ
);
Body* bodyAddForce(
  Body* b, double fX, double fY, double fZ
);
Body* bodyGetForce(
  Body* b, double* fX, double* fY, double* fZ
);
Body* bodyAddTorque(
  Body* b, double tX, double tY, double tZ
);
Body* bodyGetTorque(
  Body* b, double* tX, double* tY, double* tZ
);
Body* bodyUpdateReference(Body* b);
// Assembly
typedef struct Assembly Assembly;
typedef cdecl (*AssemblyCallback)(Assembly* a);
ParticleSet* assemblyCastToParticleSet(Assembly* a);
Assembly* particleSetCastToAssembly(ParticleSet* o);
Assembly* assemblyCreate(
  AssemblyCallback* c, Simulator* s, Environment* e,
  int particlesCount, double* particlesPositions,
  int sticksCount, unsigned short* sticksIndexes
);
Assembly* assemblySetRelaxationCycles(Assembly* a, int cycles);
Assembly* assemblyAddForce(
  Assembly* a, int idx, double fX, double fY, double fZ
);
Assembly* assemblyAddNail(
  Assembly* a, int idx, double x, double y, double z
);
int assemblyGetNailsCount(Assembly* a);
Assembly* assemblySetNailPosition(
  Assembly* a, int idx, double x, double y, double z
);
// Machinery
typedef struct Machinery Machinery;
Assembly* machineryCastToAssembly(Machinery* m);
Machinery* assemblyCastToMachinery(Assembly* o);
Machinery* machineryCreate(
  Simulator* s, Environment* e, double mass,
  int particlesCount, double* particlesPositions,
  int sticksCount, unsigned short* sticksIndexes,
  int texCoordsCount, float* texCoords,
  int trianglesCount, unsigned short* trianglesIndexes,
  int ropesCount, unsigned short* ropesIndexes, double* ropesLens2,
  int bumpersCount, unsigned short* bumpersIndexes, double* bumpersLens2,
  int springsCount, unsigned short* springsIndexes, double* springsK,
  int dampersCount, unsigned short* dampersIndexes, double* dampersK,
  int paddingsCount, unsigned short* paddingsIndexes, double* paddingsK
  int nailsCount, unsigned short* nailsIndexes
);
Mesh* machineryGetMesh(Machinery* m);
Machinery* machinerySetAirDragEnabled(Machinery* m, int b);
// Cloth
typedef struct Cloth Cloth;
Assembly* clothCastToAssembly(Cloth* m);
Cloth* assemblyCastToCloth(Assembly* o);
Cloth* clothCreate(
  int uCount, int vCount, float oX, float oY, float oZ,
  float uX, float uY, float uZ, float vX, float vY, float vZ,
  float m, Simulator* s, Environment* e
);
Mesh* clothGetMesh(Cloth* c);
//// lua interface
typedef int (*lua_CFunction)(void);
// App
void appSetTitle(const char* t);
void appSetScene(lua_CFunction i, lua_CFunction u, lua_CFunction f, lua_CFunction k);
void appSetHelp(int stringsCount, const char** strings);
void appSetHelpMode(int mode);
void appSetFramerateVisible(int b);
void appSetConsoleVisible(int b);
void appShowSplashImage(Image* splashImage, float waitForSeconds);
void appShowLoadingScreen(float waitForSeconds);
Image* appGetScreenshot(int x, int y, int w, int h);
void appReleaseKey(int key);
int appIsKeyPressed(int key);
int appIsCTRLPressed(void);
int appIsSHIFTPressed(void);
void appGetDimension(int* w, int* h);
void appGetMouseMove(int* dx, int* dy);
int appGetMouseWheel(void);
int appIsMouseLeftPressed(void);
int appIsMouseMiddlePressed(void);
int appIsMouseRightPressed(void);
int appIsMouseAcquired(void);
void appAcquireMouse(int acquire);
int appHasFocus(void);
void appGainFocus(void);
float appGetTimeStep(void);
float appGetElapsedTime(void);
int appIsPaused(void);
void appRender(void);
int appExit(void);
int appIsVertexProgramSupported(void);
int appIsFragmentProgramSupported(void);
int appAreShadersSupported(void);
int appGetTextureUnitsCount(void);
int appIsStencilAvailable(void);
void appUseFixedPipeline(void);
// FileSystem
int fileSystemFileExists(const char* fileName);
// Compiler
typedef struct Compiler Compiler;
Compiler* compilerCreate(int areWarningsEnabled);
int compilerDelete(Compiler* c);
Compiler* compilerDefSymbol(Compiler* c, const char* sym, const char* val);
Compiler* compilerUndefSymbol(Compiler* c, const char* sym);
int compilerAddLibrary(Compiler* c, const char* libraryName);
int compilerRemoveLibrary(Compiler* c, const char* libraryName);
int compilerCompileString(Compiler* c, const char* string);
int compilerCompileFile(Compiler* c, const char* fileName);
int compilerSaveObjFile(Compiler* c, const char* fileName);
int compilerLoadObjFile(Compiler* c, const char* fileName);
int compilerLoadObjBuffer(Compiler* c, const char* buffer);
int compilerLink(Compiler* c);
lua_CFunction compilerGetFunction(Compiler* c, const char* funcName);
</pre>

<p><a href=#index>Index</a>
<hr><p><a name="sdl_interface"><h3>5.3 Simple DirectMedia Layer (SDL) functions</h3></a>

This section lists all the C functions interfacing some of the features of the SDL library, in fact the TinyC version of the APIs has a partial built-in access to the functions of the "<i>Simple DirectMedia Layer 1.2.11</i>" that control joysticks and CD-Rom drives. In this documentation there is not enough space to list the main features, so you'd better to visit the official SDL site <a href="http://www.libsdl.org">http://www.libsdl.org</a> for a full description of all its characteristics. Here you can read only the templates written in "<i>sdl_cdrom.h</i>" and "<i>sdl_joystick.h</i>".

<p><B>sdl_joystick.h</B>
<pre>
#ifndef SDL_JOYSTICK_H
#define SDL_JOYSTICK_H
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;
int SDL_NumJoysticks(void);
const char * SDL_JoystickName(int device_index);
SDL_Joystick * SDL_JoystickOpen(int device_index);
int SDL_JoystickOpened(int device_index);
int SDL_JoystickIndex(SDL_Joystick *joystick);
int SDL_JoystickNumAxes(SDL_Joystick *joystick);
int SDL_JoystickNumBalls(SDL_Joystick *joystick);
int SDL_JoystickNumHats(SDL_Joystick *joystick);
int SDL_JoystickNumButtons(SDL_Joystick *joystick);
void SDL_JoystickUpdate(void);
int SDL_JoystickEventState(int state);
short SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
#define SDL_HAT_CENTERED 0x00
#define SDL_HAT_UP 0x01
#define SDL_HAT_RIGHT 0x02
#define SDL_HAT_DOWN 0x04
#define SDL_HAT_LEFT 0x08
#define SDL_HAT_RIGHTUP (SDL_HAT_RIGHT|SDL_HAT_UP)
#define SDL_HAT_RIGHTDOWN (SDL_HAT_RIGHT|SDL_HAT_DOWN)
#define SDL_HAT_LEFTUP (SDL_HAT_LEFT|SDL_HAT_UP)
#define SDL_HAT_LEFTDOWN (SDL_HAT_LEFT|SDL_HAT_DOWN)
unsigned char SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);
unsigned char SDL_JoystickGetButton(SDL_Joystick *joystick, int button);
void SDL_JoystickClose(SDL_Joystick *joystick);
#endif // SDL_JOYSTICK_H
</pre>

<p><B>sdl_cdrom.h</B>
<pre>
#ifndef SDL_CDROM_H
#define SDL_CDROM_H
#define SDL_MAX_TRACKS 99
#define SDL_AUDIO_TRACK 0x00
#define SDL_DATA_TRACK 0x04
typedef enum {
  CD_TRAYEMPTY,
  CD_STOPPED,
  CD_PLAYING,
  CD_PAUSED,
  CD_ERROR = -1
} CDstatus;
#define CD_INDRIVE(status)	((int)(status) > 0)
typedef struct SDL_CDtrack {
  unsigned char id;
  unsigned char type;
  unsigned short unused;
  unsigned int length;
  unsigned int offset;
} SDL_CDtrack;
typedef struct SDL_CD {
  int id;
  CDstatus status;
  int numtracks;
  int cur_track;
  int cur_frame;
  SDL_CDtrack track[SDL_MAX_TRACKS+1];
} SDL_CD;
int SDL_CDNumDrives(void);
const char *SDL_CDName(int drive);
SDL_CD* SDL_CDOpen(int drive);
CDstatus SDL_CDStatus(SDL_CD *cdrom);
int SDL_CDPlayTracks(SDL_CD *cdrom,
  int start_track, int start_frame, int ntracks, int nframes);
int SDL_CDPlay(SDL_CD *cdrom, int start, int length);
int SDL_CDPause(SDL_CD *cdrom);
int SDL_CDResume(SDL_CD *cdrom);
int SDL_CDStop(SDL_CD *cdrom);
int SDL_CDEject(SDL_CD *cdrom);
void SDL_CDClose(SDL_CD *cdrom);
#endif // SDL_CDROM_H
</pre>

<p><a href=#index>Index</a>
<hr><p><a name="ode_interface"><h3>5.4 Open Dynamics Engine (ODE) functions</h3></a>

This section lists all the C functions interfacing the features of the ODE physics engine, in fact the TinyC version of the APIs has full built-in access to the functions of the "<i>Open Dynamics Engine 0.5</i>". In this documentation there is not enough space to list the main features, so you'd better to visit the official ODE site <a href="http://www.ode.net">http://www.ode.org</a> for a full description of all its characteristics. Here you can read only the templates written in "<i>ode.h</i>".

<pre>
//// ODE
/* real */
typedef double dReal;
/* these types are mainly just used in headers */
typedef dReal dVector3[4];
typedef dReal dVector4[4];
typedef dReal dMatrix3[4*3];
typedef dReal dMatrix4[4*4];
typedef dReal dMatrix6[8*6];
typedef dReal dQuaternion[4];
/* internal object types */
struct dxWorld;
struct dxSpace;
struct dxBody;
struct dxGeom;
struct dxJoint;
struct dxJointNode;
struct dxJointGroup;
typedef struct dxWorld *dWorldID;
typedef struct dxSpace *dSpaceID;
typedef struct dxBody *dBodyID;
typedef struct dxGeom *dGeomID;
typedef struct dxJoint *dJointID;
typedef struct dxJointGroup *dJointGroupID;
/* joint type numbers */
enum {
  dJointTypeNone = 0,
  dJointTypeBall,
  dJointTypeHinge,
  dJointTypeSlider,
  dJointTypeContact,
  dJointTypeUniversal,
  dJointTypeHinge2,
  dJointTypeFixed,
  dJointTypeNull,
  dJointTypeAMotor
};
/* angular motor mode numbers */
enum{
  dAMotorUser = 0,
  dAMotorEuler = 1
};
/* joint force feedback information */
typedef struct dJointFeedback {
  dVector3 f1;
  dVector3 t1;
  dVector3 f2;
  dVector3 t2;
} dJointFeedback;
/* mass */
struct dMass {
  dReal mass;
  dVector4 c;
  dMatrix3 I;
};
typedef struct dMass dMass;
void dMassSetZero (dMass *);
void dMassSetParameters (dMass *, dReal themass,
			 dReal cgx, dReal cgy, dReal cgz,
			 dReal I11, dReal I22, dReal I33,
			 dReal I12, dReal I13, dReal I23);
void dMassSetSphere (dMass *, dReal density, dReal radius);
void dMassSetSphereTotal (dMass *, dReal total_mass, dReal radius);
void dMassSetCappedCylinder (dMass *, dReal density, int direction,
			     dReal radius, dReal length);
void dMassSetCappedCylinderTotal (dMass *, dReal total_mass, int direction,
				  dReal radius, dReal length);
void dMassSetCylinder (dMass *, dReal density, int direction,
		       dReal radius, dReal length);
void dMassSetCylinderTotal (dMass *, dReal total_mass, int direction,
			    dReal radius, dReal length);
void dMassSetBox (dMass *, dReal density,
		  dReal lx, dReal ly, dReal lz);
void dMassSetBoxTotal (dMass *, dReal total_mass,
		       dReal lx, dReal ly, dReal lz);
void dMassAdjust (dMass *, dReal newmass);
void dMassTranslate (dMass *, dReal x, dReal y, dReal z);
void dMassRotate (dMass *, const dMatrix3 R);
void dMassAdd (dMass *a, const dMass *b);
/* Contact */
enum {
  dContactMu2		= 0x001,
  dContactFDir1		= 0x002,
  dContactBounce	= 0x004,
  dContactSoftERP	= 0x008,
  dContactSoftCFM	= 0x010,
  dContactMotion1	= 0x020,
  dContactMotion2	= 0x040,
  dContactSlip1		= 0x080,
  dContactSlip2		= 0x100,
  dContactApprox0	= 0x0000,
  dContactApprox1_1	= 0x1000,
  dContactApprox1_2	= 0x2000,
  dContactApprox1	= 0x3000
};
typedef struct dSurfaceParameters {
  int mode;
  dReal mu;
  dReal mu2;
  dReal bounce;
  dReal bounce_vel;
  dReal soft_erp;
  dReal soft_cfm;
  dReal motion1,motion2;
  dReal slip1,slip2;
} dSurfaceParameters;
/* contact info set by collision functions */
typedef struct dContactGeom {
  dVector3 pos;
  dVector3 normal;
  dReal depth;
  dGeomID g1,g2;
} dContactGeom;
/* contact info used by contact joint */
typedef struct dContact {
  dSurfaceParameters surface;
  dContactGeom geom;
  dVector3 fdir1;
} dContact;
/* world */
dWorldID dWorldCreate();
void dWorldDestroy (dWorldID);
void dWorldSetGravity (dWorldID, dReal x, dReal y, dReal z);
void dWorldGetGravity (dWorldID, dVector3 gravity);
void dWorldSetERP (dWorldID, dReal erp);
dReal dWorldGetERP (dWorldID);
void dWorldSetCFM (dWorldID, dReal cfm);
dReal dWorldGetCFM (dWorldID);
void dWorldStep (dWorldID, dReal stepsize);
void dWorldImpulseToForce (dWorldID, dReal stepsize,
			   dReal ix, dReal iy, dReal iz, dVector3 force);
/* World QuickStep functions */
void dWorldQuickStep (dWorldID w, dReal stepsize);
void dWorldSetQuickStepNumIterations (dWorldID, int num);
int dWorldGetQuickStepNumIterations (dWorldID);
void dWorldSetQuickStepW (dWorldID, dReal param);
dReal dWorldGetQuickStepW (dWorldID);
/* World contact parameter functions */
void dWorldSetContactMaxCorrectingVel (dWorldID, dReal vel);
dReal dWorldGetContactMaxCorrectingVel (dWorldID);
void dWorldSetContactSurfaceLayer (dWorldID, dReal depth);
dReal dWorldGetContactSurfaceLayer (dWorldID);
/* StepFast1 functions */
void dWorldStepFast1(dWorldID, dReal stepsize, int maxiterations);
void dWorldSetAutoEnableDepthSF1(dWorldID, int autoEnableDepth);
int dWorldGetAutoEnableDepthSF1(dWorldID);
/* Auto-disable functions */
dReal dWorldGetAutoDisableLinearThreshold (dWorldID);
void  dWorldSetAutoDisableLinearThreshold (dWorldID, dReal linear_threshold);
dReal dWorldGetAutoDisableAngularThreshold (dWorldID);
void  dWorldSetAutoDisableAngularThreshold (dWorldID, dReal angular_threshold);
int   dWorldGetAutoDisableSteps (dWorldID);
void  dWorldSetAutoDisableSteps (dWorldID, int steps);
dReal dWorldGetAutoDisableTime (dWorldID);
void  dWorldSetAutoDisableTime (dWorldID, dReal time);
int   dWorldGetAutoDisableFlag (dWorldID);
void  dWorldSetAutoDisableFlag (dWorldID, int do_auto_disable);
dReal dBodyGetAutoDisableLinearThreshold (dBodyID);
void  dBodySetAutoDisableLinearThreshold (dBodyID, dReal linear_threshold);
dReal dBodyGetAutoDisableAngularThreshold (dBodyID);
void  dBodySetAutoDisableAngularThreshold (dBodyID, dReal angular_threshold);
int   dBodyGetAutoDisableSteps (dBodyID);
void  dBodySetAutoDisableSteps (dBodyID, int steps);
dReal dBodyGetAutoDisableTime (dBodyID);
void  dBodySetAutoDisableTime (dBodyID, dReal time);
int   dBodyGetAutoDisableFlag (dBodyID);
void  dBodySetAutoDisableFlag (dBodyID, int do_auto_disable);
void  dBodySetAutoDisableDefaults (dBodyID);
/* bodies */
dBodyID dBodyCreate (dWorldID);
void dBodyDestroy (dBodyID);
void  dBodySetData (dBodyID, void *data);
void *dBodyGetData (dBodyID);
void dBodySetPosition   (dBodyID, dReal x, dReal y, dReal z);
void dBodySetRotation   (dBodyID, const dMatrix3 R);
void dBodySetQuaternion (dBodyID, const dQuaternion q);
void dBodySetLinearVel  (dBodyID, dReal x, dReal y, dReal z);
void dBodySetAngularVel (dBodyID, dReal x, dReal y, dReal z);
const dReal * dBodyGetPosition   (dBodyID);
const dReal * dBodyGetRotation   (dBodyID);
const dReal * dBodyGetQuaternion (dBodyID);
const dReal * dBodyGetLinearVel  (dBodyID);
const dReal * dBodyGetAngularVel (dBodyID);
void dBodySetMass (dBodyID, const dMass *mass);
void dBodyGetMass (dBodyID, dMass *mass);
void dBodyAddForce            (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddTorque           (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelForce         (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddRelTorque        (dBodyID, dReal fx, dReal fy, dReal fz);
void dBodyAddForceAtPos       (dBodyID, dReal fx, dReal fy, dReal fz,
			                dReal px, dReal py, dReal pz);
void dBodyAddForceAtRelPos    (dBodyID, dReal fx, dReal fy, dReal fz,
			                dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtPos    (dBodyID, dReal fx, dReal fy, dReal fz,
			                dReal px, dReal py, dReal pz);
void dBodyAddRelForceAtRelPos (dBodyID, dReal fx, dReal fy, dReal fz,
			                dReal px, dReal py, dReal pz);
const dReal * dBodyGetForce   (dBodyID);
const dReal * dBodyGetTorque  (dBodyID);
void dBodySetForce  (dBodyID b, dReal x, dReal y, dReal z);
void dBodySetTorque (dBodyID b, dReal x, dReal y, dReal z);
void dBodyGetRelPointPos    (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodyGetRelPointVel    (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodyGetPointVel       (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodyGetPosRelPoint    (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodyVectorToWorld     (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodyVectorFromWorld   (dBodyID, dReal px, dReal py, dReal pz,
			     dVector3 result);
void dBodySetFiniteRotationMode (dBodyID, int mode);
void dBodySetFiniteRotationAxis (dBodyID, dReal x, dReal y, dReal z);
int dBodyGetFiniteRotationMode (dBodyID);
void dBodyGetFiniteRotationAxis (dBodyID, dVector3 result);
int dBodyGetNumJoints (dBodyID b);
dJointID dBodyGetJoint (dBodyID, int index);
void dBodyEnable (dBodyID);
void dBodyDisable (dBodyID);
int dBodyIsEnabled (dBodyID);
void dBodySetGravityMode (dBodyID b, int mode);
int dBodyGetGravityMode (dBodyID b);
/* joints */
dJointID dJointCreateBall (dWorldID, dJointGroupID);
dJointID dJointCreateHinge (dWorldID, dJointGroupID);
dJointID dJointCreateSlider (dWorldID, dJointGroupID);
dJointID dJointCreateContact (dWorldID, dJointGroupID, const dContact *);
dJointID dJointCreateHinge2 (dWorldID, dJointGroupID);
dJointID dJointCreateUniversal (dWorldID, dJointGroupID);
dJointID dJointCreateFixed (dWorldID, dJointGroupID);
dJointID dJointCreateNull (dWorldID, dJointGroupID);
dJointID dJointCreateAMotor (dWorldID, dJointGroupID);
void dJointDestroy (dJointID);
dJointGroupID dJointGroupCreate (int max_size);
void dJointGroupDestroy (dJointGroupID);
void dJointGroupEmpty (dJointGroupID);
void dJointAttach (dJointID, dBodyID body1, dBodyID body2);
void dJointSetData (dJointID, void *data);
void *dJointGetData (dJointID);
int dJointGetType (dJointID);
dBodyID dJointGetBody (dJointID, int index);
void dJointSetFeedback (dJointID, dJointFeedback *);
dJointFeedback *dJointGetFeedback (dJointID);
void dJointSetBallAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHingeAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHingeAxis (dJointID, dReal x, dReal y, dReal z);
void dJointSetHingeParam (dJointID, int parameter, dReal value);
void dJointAddHingeTorque(dJointID joint, dReal torque);
void dJointSetSliderAxis (dJointID, dReal x, dReal y, dReal z);
void dJointSetSliderParam (dJointID, int parameter, dReal value);
void dJointAddSliderForce(dJointID joint, dReal force);
void dJointSetHinge2Anchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis1 (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Axis2 (dJointID, dReal x, dReal y, dReal z);
void dJointSetHinge2Param (dJointID, int parameter, dReal value);
void dJointAddHinge2Torques(dJointID joint, dReal torque1, dReal torque2);
void dJointSetUniversalAnchor (dJointID, dReal x, dReal y, dReal z);
void dJointSetUniversalAxis1 (dJointID, dReal x, dReal y, dReal z);
void dJointSetUniversalAxis2 (dJointID, dReal x, dReal y, dReal z);
void dJointSetUniversalParam (dJointID, int parameter, dReal value);
void dJointAddUniversalTorques(dJointID joint, dReal torque1, dReal torque2);
void dJointSetFixed (dJointID);
void dJointSetAMotorNumAxes (dJointID, int num);
void dJointSetAMotorAxis (dJointID, int anum, int rel,
			  dReal x, dReal y, dReal z);
void dJointSetAMotorAngle (dJointID, int anum, dReal angle);
void dJointSetAMotorParam (dJointID, int parameter, dReal value);
void dJointSetAMotorMode (dJointID, int mode);
void dJointAddAMotorTorques (dJointID, dReal torque1, dReal torque2, dReal torque3);
void dJointGetBallAnchor (dJointID, dVector3 result);
void dJointGetBallAnchor2 (dJointID, dVector3 result);
void dJointGetHingeAnchor (dJointID, dVector3 result);
void dJointGetHingeAnchor2 (dJointID, dVector3 result);
void dJointGetHingeAxis (dJointID, dVector3 result);
dReal dJointGetHingeParam (dJointID, int parameter);
dReal dJointGetHingeAngle (dJointID);
dReal dJointGetHingeAngleRate (dJointID);
dReal dJointGetSliderPosition (dJointID);
dReal dJointGetSliderPositionRate (dJointID);
void dJointGetSliderAxis (dJointID, dVector3 result);
dReal dJointGetSliderParam (dJointID, int parameter);
void dJointGetHinge2Anchor (dJointID, dVector3 result);
void dJointGetHinge2Anchor2 (dJointID, dVector3 result);
void dJointGetHinge2Axis1 (dJointID, dVector3 result);
void dJointGetHinge2Axis2 (dJointID, dVector3 result);
dReal dJointGetHinge2Param (dJointID, int parameter);
dReal dJointGetHinge2Angle1 (dJointID);
dReal dJointGetHinge2Angle1Rate (dJointID);
dReal dJointGetHinge2Angle2Rate (dJointID);
void dJointGetUniversalAnchor (dJointID, dVector3 result);
void dJointGetUniversalAnchor2 (dJointID, dVector3 result);
void dJointGetUniversalAxis1 (dJointID, dVector3 result);
void dJointGetUniversalAxis2 (dJointID, dVector3 result);
dReal dJointGetUniversalParam (dJointID, int parameter);
dReal dJointGetUniversalAngle1 (dJointID);
dReal dJointGetUniversalAngle2 (dJointID);
dReal dJointGetUniversalAngle1Rate (dJointID);
dReal dJointGetUniversalAngle2Rate (dJointID);
int dJointGetAMotorNumAxes (dJointID);
void dJointGetAMotorAxis (dJointID, int anum, dVector3 result);
int dJointGetAMotorAxisRel (dJointID, int anum);
dReal dJointGetAMotorAngle (dJointID, int anum);
dReal dJointGetAMotorAngleRate (dJointID, int anum);
dReal dJointGetAMotorParam (dJointID, int parameter);
int dJointGetAMotorMode (dJointID);
int dAreConnected (dBodyID, dBodyID);
int dAreConnectedExcluding (dBodyID, dBodyID, int joint_type);
typedef void dJointBreakCallback (dJointID joint);
enum {
  dJOINT_BROKEN = 1, dJOINT_DELETE_ON_BREAK = 2,
  dJOINT_BREAK_AT_B1_FORCE = 4, dJOINT_BREAK_AT_B1_TORQUE = 8,
  dJOINT_BREAK_AT_B2_FORCE = 16, dJOINT_BREAK_AT_B2_TORQUE = 32
};
void dJointSetBreakable (dJointID, int b);
void dJointSetBreakCallback (dJointID, dJointBreakCallback *callbackFunc);
void dJointSetBreakMode (dJointID, int mode);
int dJointGetBreakMode (dJointID);
void dJointSetBreakForce (dJointID, int body, dReal x, dReal y, dReal z);
void dJointSetBreakTorque (dJointID, int body, dReal x, dReal y, dReal z);
int dJointIsBreakable (dJointID);
void dJointGetBreakForce (dJointID, int body, dReal *force);
void dJointGetBreakTorque (dJointID, int body, dReal *torque);
/* collision_space */
typedef void dNearCallback (void *data, dGeomID o1, dGeomID o2);
dSpaceID dSimpleSpaceCreate (dSpaceID space);
dSpaceID dHashSpaceCreate (dSpaceID space);
dSpaceID dQuadTreeSpaceCreate (dSpaceID space, dVector3 Center, dVector3 Extents, int Depth);
void dSpaceDestroy (dSpaceID);
void dHashSpaceSetLevels (dSpaceID space, int minlevel, int maxlevel);
void dHashSpaceGetLevels (dSpaceID space, int *minlevel, int *maxlevel);
void dSpaceSetCleanup (dSpaceID space, int mode);
int dSpaceGetCleanup (dSpaceID space);
void dSpaceAdd (dSpaceID, dGeomID);
void dSpaceRemove (dSpaceID, dGeomID);
int dSpaceQuery (dSpaceID, dGeomID);
void dSpaceClean (dSpaceID);
int dSpaceGetNumGeoms (dSpaceID);
dGeomID dSpaceGetGeom (dSpaceID, int i);
/* collision: general functions */
void dGeomDestroy (dGeomID);
void dGeomSetData (dGeomID, void *);
void *dGeomGetData (dGeomID);
void dGeomSetBody (dGeomID, dBodyID);
dBodyID dGeomGetBody (dGeomID);
void dGeomSetPosition (dGeomID, dReal x, dReal y, dReal z);
void dGeomSetRotation (dGeomID, const dMatrix3 R);
void dGeomSetQuaternion (dGeomID, const dQuaternion);
const dReal * dGeomGetPosition (dGeomID);
const dReal * dGeomGetRotation (dGeomID);
void dGeomGetQuaternion (dGeomID, dQuaternion result);
void dGeomGetAABB (dGeomID, dReal aabb[6]);
int dGeomIsSpace (dGeomID);
dSpaceID dGeomGetSpace (dGeomID);
int dGeomGetClass (dGeomID);
void dGeomSetCategoryBits (dGeomID, unsigned long bits);
void dGeomSetCollideBits (dGeomID, unsigned long bits);
unsigned long dGeomGetCategoryBits (dGeomID);
unsigned long dGeomGetCollideBits (dGeomID);
void dGeomEnable (dGeomID);
void dGeomDisable (dGeomID);
int dGeomIsEnabled (dGeomID);
/* collision detection */
int dCollide (dGeomID o1, dGeomID o2, int flags, dContactGeom *contact,
	      int skip);
void dSpaceCollide (dSpaceID space, void *data, dNearCallback *callback);
void dSpaceCollide2 (dGeomID o1, dGeomID o2, void *data,
		     dNearCallback *callback);
enum {
  dSphereClass = 0,
  dBoxClass,
  dCCylinderClass,
  dCylinderClass,
  dPlaneClass,
  dRayClass,
  dGeomTransformClass,
  dTriMeshClass,
  dFirstSpaceClass,
  dSimpleSpaceClass = dFirstSpaceClass,
  dHashSpaceClass,
  dQuadTreeSpaceClass,
  dLastSpaceClass = dQuadTreeSpaceClass,
  dFirstUserClass,
  dLastUserClass = dFirstUserClass + 4 - 1,
  dGeomNumClasses
};
dGeomID dCreateSphere (dSpaceID space, dReal radius);
void dGeomSphereSetRadius (dGeomID sphere, dReal radius);
dReal dGeomSphereGetRadius (dGeomID sphere);
dReal dGeomSpherePointDepth (dGeomID sphere, dReal x, dReal y, dReal z);
dGeomID dCreateBox (dSpaceID space, dReal lx, dReal ly, dReal lz);
void dGeomBoxSetLengths (dGeomID box, dReal lx, dReal ly, dReal lz);
void dGeomBoxGetLengths (dGeomID box, dVector3 result);
dReal dGeomBoxPointDepth (dGeomID box, dReal x, dReal y, dReal z);
dGeomID dCreatePlane (dSpaceID space, dReal a, dReal b, dReal c, dReal d);
void dGeomPlaneSetParams (dGeomID plane, dReal a, dReal b, dReal c, dReal d);
void dGeomPlaneGetParams (dGeomID plane, dVector4 result);
dReal dGeomPlanePointDepth (dGeomID plane, dReal x, dReal y, dReal z);
dGeomID dCreateCylinder (dSpaceID space, dReal radius, dReal length);
void dGeomCylinderSetParams (dGeomID ccylinder, dReal radius, dReal length);
void dGeomCylinderGetParams (dGeomID ccylinder, dReal *radius, dReal *length);
dGeomID dCreateCCylinder (dSpaceID space, dReal radius, dReal length);
void dGeomCCylinderSetParams (dGeomID ccylinder, dReal radius, dReal length);
void dGeomCCylinderGetParams (dGeomID ccylinder, dReal *radius, dReal *length);
dReal dGeomCCylinderPointDepth (dGeomID ccylinder, dReal x, dReal y, dReal z);
dGeomID dCreateRay (dSpaceID space, dReal length);
void dGeomRaySetLength (dGeomID ray, dReal length);
dReal dGeomRayGetLength (dGeomID ray);
void dGeomRaySet (dGeomID ray, dReal px, dReal py, dReal pz,
		  dReal dx, dReal dy, dReal dz);
void dGeomRayGet (dGeomID ray, dVector3 start, dVector3 dir);
void dGeomRaySetParams (dGeomID g, int FirstContact, int BackfaceCull);
void dGeomRayGetParams (dGeomID g, int *FirstContact, int *BackfaceCull);
void dGeomRaySetClosestHit (dGeomID g, int closestHit);
int dGeomRayGetClosestHit (dGeomID g);
dGeomID dCreateGeomTransform (dSpaceID space);
void dGeomTransformSetGeom (dGeomID g, dGeomID obj);
dGeomID dGeomTransformGetGeom (dGeomID g);
void dGeomTransformSetCleanup (dGeomID g, int mode);
int dGeomTransformGetCleanup (dGeomID g);
void dGeomTransformSetInfo (dGeomID g, int mode);
int dGeomTransformGetInfo (dGeomID g);
/* collision: triangle meshes */
struct dxTriMeshData;
typedef struct dxTriMeshData* dTriMeshDataID;
dTriMeshDataID dGeomTriMeshDataCreate();
void dGeomTriMeshDataDestroy(dTriMeshDataID g);
enum { TRIMESH_FACE_NORMALS, TRIMESH_LAST_TRANSFORMATION };
void dGeomTriMeshDataSet(dTriMeshDataID g, int data_id, void* data);
void dGeomTriMeshDataBuildSingle(dTriMeshDataID g,
                                 const void* Vertices, int VertexStride, int VertexCount, 
                                 const void* Indices, int IndexCount, int TriStride);
void dGeomTriMeshDataBuildSingle1(dTriMeshDataID g,
                                  const void* Vertices, int VertexStride, int VertexCount, 
                                  const void* Indices, int IndexCount, int TriStride,
                                  const void* Normals);
void dGeomTriMeshDataBuildDouble(dTriMeshDataID g, 
                                 const void* Vertices,  int VertexStride, int VertexCount, 
                                 const void* Indices, int IndexCount, int TriStride);
void dGeomTriMeshDataBuildDouble1(dTriMeshDataID g, 
                                  const void* Vertices,  int VertexStride, int VertexCount, 
                                  const void* Indices, int IndexCount, int TriStride,
                                  const void* Normals);
void dGeomTriMeshDataBuildSimple(dTriMeshDataID g,
                                 const dReal* Vertices, int VertexCount,
                                 const int* Indices, int IndexCount);
void dGeomTriMeshDataBuildSimple1(dTriMeshDataID g,
                                  const dReal* Vertices, int VertexCount,
                                  const int* Indices, int IndexCount,
                                  const int* Normals);
typedef int dTriCallback(dGeomID TriMesh, dGeomID RefObject, int TriangleIndex);
void dGeomTriMeshSetCallback(dGeomID g, dTriCallback* Callback);
dTriCallback* dGeomTriMeshGetCallback(dGeomID g);
typedef void dTriArrayCallback(dGeomID TriMesh, dGeomID RefObject, const int* TriIndices, int TriCount);
void dGeomTriMeshSetArrayCallback(dGeomID g, dTriArrayCallback* ArrayCallback);
dTriArrayCallback* dGeomTriMeshGetArrayCallback(dGeomID g);
typedef int dTriRayCallback(dGeomID TriMesh, dGeomID Ray, int TriangleIndex, dReal u, dReal v);
void dGeomTriMeshSetRayCallback(dGeomID g, dTriRayCallback* Callback);
dTriRayCallback* dGeomTriMeshGetRayCallback(dGeomID g);
dGeomID dCreateTriMesh(dSpaceID space, dTriMeshDataID Data, dTriCallback* Callback, dTriArrayCallback* ArrayCallback, dTriRayCallback* RayCallback);
void dGeomTriMeshSetData(dGeomID g, dTriMeshDataID Data);
void dGeomTriMeshEnableTC(dGeomID g, int geomClass, int enable);
int dGeomTriMeshIsTCEnabled(dGeomID g, int geomClass);
void dGeomTriMeshClearTCCache(dGeomID g);
dTriMeshDataID dGeomTriMeshGetTriMeshDataID(dGeomID g);
void dGeomTriMeshGetTriangle(dGeomID g, int Index, dVector3* v0, dVector3* v1, dVector3* v2);
void dGeomTriMeshGetPoint(dGeomID g, int Index, dReal u, dReal v, dVector3 Out);
/* collision: utility functions */
void dClosestLineSegmentPoints (const dVector3 a1, const dVector3 a2,
				const dVector3 b1, const dVector3 b2,
				dVector3 cp1, dVector3 cp2);
int dBoxTouchesBox (const dVector3 _p1, const dMatrix3 R1,
		    const dVector3 side1, const dVector3 _p2,
		    const dMatrix3 R2, const dVector3 side2);
void dInfiniteAABB (dGeomID geom, dReal aabb[6]);
void dCloseODE();
/* collision: custom classes */
typedef void dGetAABBFn (dGeomID, dReal aabb[6]);
typedef int dColliderFn (dGeomID o1, dGeomID o2,
			 int flags, dContactGeom *contact, int skip);
typedef dColliderFn * dGetColliderFnFn (int num);
typedef void dGeomDtorFn (dGeomID o);
typedef int dAABBTestFn (dGeomID o1, dGeomID o2, dReal aabb[6]);
typedef struct dGeomClass {
  int bytes;
  dGetColliderFnFn *collider;
  dGetAABBFn *aabb;
  dAABBTestFn *aabb_test;
  dGeomDtorFn *dtor;
} dGeomClass;
int dCreateGeomClass (const dGeomClass *classptr);
void * dGeomGetClassData (dGeomID);
dGeomID dCreateGeom (int classnum);
</pre>

<p><a href=#index>Index</a>


<hr><p><a name="csl_interface"><h3>5.5 CSL functions</h3></a>

This section lists all the C functions interfacing the features of the
CSL interpreter. Read <a href="APOCALYX-manual-csl.htm#parti">Part VIII</a>
for more details about this scripting language.
Here you can read the templates written in "<i>csl.h</i>", then follows a detailed description of the functions and, finally, an explanation on writing libraries for CSL scripts.

<pre>
//// CSL interface
typedef void* CslHandle;
enum {
  CslDisInclude = 1, CslDisLoadScript = 2, CslDisLoadLibrary = 4,
  CslDisList = 8, CslDisLogFile = 16, CslDisIf = 32, CslDisError = 64,
  CslDisMessage = 128, CslDisAll = 255};
long cslOpen(CslHandle *aHandle, long aFlags);
long cslClose(CslHandle aHandle);
long cslSet(CslHandle aHandle,
  const char *aVarName, const char *aValue, long aSize);
long cslGet(CslHandle aHandle,
  const char *aVarName, char *aBuffer, long *aSize);
long cslVarSizeof(CslHandle aHandle,
  const char *aVarName, long *aSize);
long cslVarResize(CslHandle aHandle, const char *aVarName);
long cslLoadScriptMem(CslHandle aHandle,
  const char *aFileName, const char *aStr);
long cslLoadScriptFile(CslHandle aHandle, const char *aFileName);
long cslLoadLibrary(CslHandle aHandle, const char *aDllName);
long cslCall(CslHandle aHandle,
  const char *aFileName, const char *aFuncName,
  long aArgCount, char *aArgs[]);
long cslCallEx(CslHandle aHandle,
  const char *aFileName, const char *aFuncName,
  long aArgCount, char *aArgs[], long aSize[]);
long cslGetResult(CslHandle aHandle, char *aBuffer, long *aSize);
typedef void (* FuncAPI)(CslHandle aHandle);
long cslAddFunc(CslHandle aHandle,
  const char *aFileName, const char *aFuncHeader,
  void (* aFunc)(FuncAPI));
long cslAddVar(CslHandle aHandle,
  const char *aVarName, const char *aInitVal, long aIsConst);
long cslSetResult(CslHandle aHandle, const char *aBuffer, long aSize);
long cslSetError(CslHandle aHandle, const char *aBuffer, long aSize);
long cslStartDateTime(CslHandle aHandle,
  long *aYear, long *aMonth, long *aDay,
  long *aHour, long *aMinute, long *aSecond);
enum {
  CslTraceNone = 0, CslTraceCode = 1, CslTraceFuncs = 2,
  CslTraceBlks = 4, CslTraceMsgs = 8, CslTraceInfo = 14,
  CslTraceAll = 15};
long cslTraceMode(CslHandle aHandle, long *aMode);
long cslSetTraceMode(CslHandle aHandle, long aMode);
long cslTrace(CslHandle aHandle, const char *aMessage);
long cslGetError(CslHandle aHandle,
  long aIndex, char *aBuffer, long *aSize);
</pre>

<h4>List of API functions</h4>
<font size="-2">Excerpt from "<i>C Scripting Language Reference Manual</i>" (4.4.0), Copyright  &copy; 2001-2002 IBK-Landquart-Switzerland.</font>

<p>
This section lists all API functions in alphabetic order.
<br>[<i>In APOCALYX all the <b>ZCls</b> prefixes must become <b>cls</b></i>]
</p><p>
Each API function returns a long value indicating how many error
texts have been emitted. This count can be used to fetch all
error texts with <i>ZCslGetError</i>. If the function was completed with
no errors, 0 is returned.
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslAddFunc</B>(                        /* add a function */
   ZCslHandle aHandle,                      /* CSL handle */
   const char *aFileName,                   /* file/module name for function */
   const char *aFuncHeader,                 /* function header */
   void (ZFuncptrAPI aFunc)(ZCslHandle aHandle) /* function address */
);
</pre></FONT><p>
Adds a C/C++ function to CSL.
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslAddVar</B>(             /* add a local var/const */
   ZCslHandle aHandle,          /* CSL handle */
   const char *aVarName,        /* name and layout of var/const */
   const char *aInitVal,        /* initial value */
   long aIsConst                /* 0=var, 1=const */
);
</pre></FONT><p>
Adds a local var or const within a C/C++ function implementation.
</p><p>
<i>aInitVal</i> may be <i>NULL</i> if var/const ought to be initialized to
an empty string.
</p>
<p><table bordercolor="#000000" border="1" cellspacing="0" cellpadding="6" width="100%">
<tr bgcolor="#FFFFDD"><td><font size="-1">
<b>NOTE:</b>
Can <i>NOT</i> be used to add globals. To add a global var or const
you may compile a script with it's declaration.
</font></td></tr></table></p>

<FONT SIZE="+0"><pre>
long <B>ZCslCall</B>(                        /* call function */
   ZCslHandle aHandle,                      /* CSL handle */
   const char *aFileName,                   /* file/module caller belongs to */
   const char *aFuncName,                   /* function name */
   long aArgCount,                          /* # of arguments following */
   char *aParam[]                           /* parameter list. NULL if no args */
);
</pre></FONT><p>
Calls any CSL, C or C++ function known to CSL. Parameters are passed
as a list of ASCIZ strings.
</p><p>
Example:
</p><pre>
static char *args[] = { &quot;The quick brow fox&quot;, &quot;5&quot;, &quot;10&quot; };
long errs, size;
char buf[40];
&nbsp;
/* call strSubString */
errs = ZCslCall(csl, &quot;MyProg.exe&quot;, &quot;strSubString&quot;, sizeof(args)/sizeof(char*), args);
if (errs) .... /* error handling */
&nbsp;
/* retrieve result */
size = sizeof(buf);
errs = ZCslGetResult(csl, buf, &amp;size);
if (errs) .... /* error handling */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslCallEx</B>(            /* call function (extended) */
   ZCslHandle aHandle,         /* CSL handle */
   const char *aFileName,      /* file/module caller belongs to */
   const char *aFuncName,      /* function name */
   long aArgCount,             /* # of arguments following */
   char *aParam[],             /* parameter list. NULL if no args */
   long aSize[]                /* parameter size list. NULL if no args */
);
</pre></FONT><p>
Calls any CSL, C or C++ function known to CSL.
Parameters are supplied as pairs of char* and long. The long value is the size
of the corresponding argument. If it is -1 the parameter is considered a zero
terminated string. With this API it is possible to pass parameters containing
NUL chars.
</p><p>
Example:
</p><pre>
static char *args[] = { &quot;The quick brow fox&quot;, &quot;5&quot;, &quot;\33[c\0\1&quot; };
static long sze[] = { -1, -1, 5 };
long errs, size;
char buf[40];
&nbsp;
/* call strSubString */
errs = ZCslCallEx(csl, &quot;MyProg.exe&quot;, &quot;strSubString&quot;, sizeof(args)/sizeof(char*), args, sze);
if (errs) .... /* error handling */
&nbsp;
/* retrieve result */
size = sizeof(buf);
errs = ZCslGetResult(csl, buf, &amp;size);
if (errs) .... /* error handling */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslClose</B>(             /* Destroy CSL Context &amp; release mem */
   ZCslHandle aHandle          /* CSL handle */
);
</pre></FONT><p>
Closes a CSL handle. All DLL's are unloaded and allocated memory is released.
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslGet</B>(               /* get var or const value */
   ZCslHandle aHandle,         /* CSL handle */
   const char *aVarName,       /* variable name */
   char *aBuffer,              /* buffer for value (NULL = query size) */
   long *aSize                 /* buffer size */
);
</pre></FONT><p>
Get value of any CSL variable or constant.
</p><p>
On entry <i>*aSize</i> must be set to the actual size of the buffer.
No more than this amount will be filled including zero termination. The rest
of the variable content will in case be truncated. On exit <i>*aSize</i> is
always set to the buffer size required for holding the full value.
</p><p>
Pass <i>aBuffer</i> as NULL to only query the required buffer size.
</p><p>
If <i>aSize</i> is NULL, the API assumes your buffer is in any case large
enough and will not limit the size at all (I strongly don't recommend this!).
</p><p>
Example:
</p><pre>
long size, errs;
char *buf;
&nbsp;
/* get size of value first for buffer allocation: */
errs = ZCslGet(csl, &quot;adr[5][2]&quot;, NULL, &amp;size);
if (errs) .... /* error handling */
&nbsp;
/* now allocate buffer and retrieve value */
buf = (char*)malloc(size);
errs = ZCslGet(csl, &quot;adr[5][2]&quot;, buf, &amp;size);
if (errs) .... /* error handling */
&nbsp;
...
&nbsp;
/* when value no longer needed, don't forget to release buffer */
free(buf);
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslGetError</B>(        /* get error text */
   ZCslHandle aHandle,       /* CSL handle */
   long aIndex,              /* index of text (0 based) */
   char *aBuffer,            /* buffer for error text (NULL = query size) */
   long *aSize               /* buffer size information */
);
</pre></FONT><p>
Retrieve error text. <i>aIndex</i> must be in the range from 0 to the # of errors
returned by the previous API call.
</p><p>
On entry <i>*aSize</i> must be set to the actual size of the buffer.
No more than this amount will be filled including zero termination. The rest
of the variable content will in case be truncated. On exit <i>*aSize</i> is
always set to the buffer size required for holding the full value.
</p><p>
Pass <i>aBuffer</i> as NULL to only query the required buffer size.
</p><p>
If <i>aSize</i> is NULL, the API assumes your buffer is in any case large
enough and will not limit the size at all (I strongly don't recommend this!).
</p><p>
Example:
</p><pre>
void handleCslError(ZCslHandle csl, long errs)
{
   long i, size, errs2;
   char *buf;
&nbsp;
   for (i = 0; i &lt; errs; i++) {
      /* get size of text first for buffer allocation: */
      errs2 = ZCslGetError(csl, i, NULL, &amp;size);
      if (errs2) handleCslError(csl, errs2);
&nbsp;
      /* now allocate buffer and retrieve text */
      buf = (char*)malloc(size);
      errs2 = ZCslGetError(csl, i, buf, &amp;size);
      if (errs2) handleCslError(csl, errs2);
&nbsp;
      /* display message */
      fprintf(stderr, &quot;%s\r\n&quot;, buf);
&nbsp;
      /* when value no longer needed, don't forget to release buffer */
      free(buf);
   } /* for */
   if (errs) exit(1);
} /* handleCslError */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslGetResult</B>(        /* get function result */
   ZCslHandle aHandle,        /* CSL handle */
   char *aBuffer,             /* buffer for value (NULL = query size) */
   long *aSize                /* buffer size */
);
</pre></FONT><p>
Retrieve return value of a CSL function call.
</p><p>
On entry <i>*aSize</i> must be set to the actual size of the buffer.
No more than this amount will be filled including zero termination. The rest
of the variable content will in case be truncated. On exit <i>*aSize</i> is
always set to the buffer size required for holding the full value.
</p><p>
Pass <i>aBuffer</i> as NULL to only query the required buffer size.
</p><p>
If <i>aSize</i> is NULL, the API assumes your buffer is in any case large
enough and will not limit the size at all (I strongly don't recommend this!).
</p><p>
Example:
</p><pre>
static char *args[] = { &quot;The quick brow fox&quot;, &quot;5&quot;, &quot;10&quot; };
char *buf;
long errs, size;
&nbsp;
/* call strSubString */
errs = ZCslCall(csl, &quot;MyProg.exe&quot;, &quot;strSubString&quot;, sizeof(args)/sizeof(char*), args);
if (errs) .... /* error handling */
&nbsp;
/* get size of return value first for buffer allocation: */
errs = ZCslGetResult(csl, NULL, &amp;size);
if (errs) .... /* error handling */
&nbsp;
/* now allocate buffer and retrieve value */
buf = (char*)malloc(size);
errs = ZCslGetResult(csl, buf, &amp;size);
if (errs) .... /* error handling */
&nbsp;
...
&nbsp;
/* when value no longer needed, don't forget to release buffer */
free(buf);
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslLoadLibrary</B>(       /* load a CSL dll */
   ZCslHandle aHandle,         /* CSL handle */
   const char *aDllName        /* dll filename */
);
</pre></FONT><p>
Loads a dynamic linked library and calls <i>ZCslInitLib</i>.
If the file name is given without extension, .dll or .so.X is assumed.
</p><p>
<table bordercolor="#000000" border="1" cellspacing="0" cellpadding="6" width="100%">
<tr bgcolor="#FFFFDD"><td><font size="-1">
<b>NOTE:</b>
CSL will not load the same library several times; attempt to do so will
be silently ignored.
</font></td></tr></table>
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslLoadScriptFile</B>(      /* load script from file */
   ZCslHandle aHandle,           /* CSL handle */
   const char *aFileName         /* file name to load script */
);
</pre></FONT><p>
Compiles/loads a script from a file. If the file name is given
without extension, <i>.csl</i> is appended. The file is searched
in the directories listed in environment variable <i>CSLPATH</i>.
If <i>CSLPATH</i> does not exist, the file is searched in the current
working directory.
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslLoadScriptMem</B>(        /* load script from memory */
   ZCslHandle aHandle,            /* CSL handle */
   const char *aFileName,         /* file/module name for script */
   const char *aStr               /* csl source code */
);
</pre></FONT><p>
Compiles/loads a script from memory.
</p>

<p><table bordercolor="#000000" border="1" cellspacing="0" cellpadding="6" width="100%">
<tr bgcolor="#FFFFDD"><td><font size="-1">
<b>NOTE:</b>
CSL will not load the same file/module several times; attempt to do so will
be silently ignored.
</font></td></tr></table></p>

<FONT SIZE="+0"><pre>
long <B>ZCslOpen</B>(           /* Create CSL context &amp; alloc mem */
   ZCslHandle *aHandle,     /* address of handle var */
   long aFlags              /* initialization flags */
);
</pre></FONT><p>
<i>aFlags</i> is a combination of the following values (bitwise or them together):
</p><p>
<table border="0" cellpadding="3" cellspacing="0">
 <tr bgcolor="#0044AA" valign="top">
  <td><font color="#FFFFFF"><b>Flag</b></font></td>
  <td bgcolor="#0034AA"><font color="#FFFFFF"><b>Description</b></font></td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslDisInclude</td>
  <td bgcolor="#B0D0FF">Disable #include</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslDisLoadLibrary</td>
  <td bgcolor="#D0E0FF">Disable #loadLibrary </td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslDisLoadScript</td>
  <td bgcolor="#B0D0FF">Disable #loadScript</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslDisList</td>
  <td bgcolor="#D0E0FF">Disable #list</td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslDisLogFile</td>
  <td bgcolor="#B0D0FF">Disable #logFile</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslDisIf</td>
  <td bgcolor="#D0E0FF">Disable #if / #else / #endif</td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslDisError</td>
  <td bgcolor="#B0D0FF">Disable #error</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslDisMessage</td>
  <td bgcolor="#D0E0FF">Disable #message</td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslDisAll</td>
  <td bgcolor="#B0D0FF">Disable all compiler directives</td>
 </tr>
</table>
</p><p>
Set <i>aFlags</i> to 0 to enable all directives.
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslSet</B>(                         /* set var or const value */
   ZCslHandle aHandle,                      /* CSL handle */
   const char *aVarName,                    /* variable name */
   const char *aValue,                      /* new value (NULL = &quot;&quot;) */
   long aSize                               /* value size, -1 = ASCIZ */
);
</pre></FONT><p>
Set value of any CSL global or local variable.
</p><p>
Example:
</p><pre>
long errs;
errs = ZCslSet(csl, &quot;adr[5][2]&quot;, &quot;Fred Flintstone&quot;, -1);
if (errs) .... /* error handling */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslSetError</B>(       /* set/add error text */
   ZCslHandle aHandle,      /* CSL handle */
   const char *aBuffer,     /* buffer for result */
   long aSize               /* buffer size, -1 = ASCIZ */
);
</pre></FONT><p>
Set/add an error text. This function is used in C/C++ function implementations
to raise an error. <i>ZCslSetError</i> may be called multiple to add several
texts.
</p><p>
<i>ZCslSetError</i> will always return 0 so there is no need for error checking.
</p><p>
Example:
</p><pre>
ZExportAPI(void) mthSqrt(ZCslHandle aCsl)
{
   char buf[40];
   long bufsiz;
   double val;
&nbsp;
   /* get val */
   bufsiz = sizeof(buf);
   if ( ZCslGet(aCsl, &quot;val&quot;, buf, &amp;bufsiz) ) return;
   val = atof(buf);
&nbsp;
   if (val &lt; 0.0) {
      ZCslSetError(aCsl, &quot;val must not be negative!&quot;, -1);
      return;
   } /* if */
&nbsp;
   /* return result */
   sprintf(buf, &quot;%f&quot;, sqrt(val));
   ZCslSetResult(aCsl, buf, -1);
} /* mthSqrt */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslSetResult</B>(        /* set return result */
   ZCslHandle aHandle,        /* CSL handle */
   const char *aBuffer,       /* buffer for result */
   long aSize                 /* buffer size, -1 = ASCIZ */
);
</pre></FONT><p>
Set return value in a C/C++ function implementation.
</p><p>
<i>ZCslSetResult</i> will always return 0 so there is no need for error checking.
</p><p>
Example:
</p><pre>
ZExportAPI(void) mthSqrt(ZCslHandle aCsl)
{
   char buf[40];
   long bufsiz;
   double val;
&nbsp;
   /* get val */
   bufsiz = sizeof(buf);
   if ( ZCslGet(aCsl, &quot;val&quot;, buf, &amp;bufsiz) ) return;
   val = atof(buf);
&nbsp;
   if (val &lt; 0.0) {
      ZCslSetError(aCsl, &quot;val must not be negative!&quot;, -1);
      return;
   } /* if */
&nbsp;
   /* return result */
   sprintf(buf, &quot;%f&quot;, sqrt(val));
   ZCslSetResult(aCsl, buf, -1);
} /* mthSqrt */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslSetTraceMode</B>(      /* set trace mode */
   ZCslHandle aHandle,         /* CSL handle */
   long aMode                  /* trace mode to set */
);
</pre></FONT><p>
Set <a href="langB.htm">trace</a> mode. Predefined mode constants are:
</p><p>
<table border="0" cellpadding="3" cellspacing="0">
 <tr bgcolor="#0044AA" valign="top">
  <td><font color="#FFFFFF"><b>Mode</b></font></td>
  <td bgcolor="#0034AA"><font color="#FFFFFF"><b>Description</b></font></td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslTraceNone</td>
  <td bgcolor="#B0D0FF">Trace output is turned off (default)</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslTraceCode</td>
  <td bgcolor="#D0E0FF">
   Trace P-code instructions together with the 2 top stack elements.
  </td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslTraceFuncs</td>
  <td bgcolor="#B0D0FF">
   Trace function entry and exit. Trace output will be indented within the function.
  </td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslTraceBlks</td>
  <td bgcolor="#D0E0FF"></i>
   Trace entry and exit of named blocks. Trace output will be indented within the
   block. Use <a href="directA.htm">#block</a> to name blocks.
  </td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslTraceMsgs</td>
  <td bgcolor="#B0D0FF">
   Trace expressions of <a href="langB.htm">trace</a> statement or API
   <a href="capi4P.htm">ZCslTrace</a> and <a href="api4D.htm">ZCsl::trace</a>
   member.
  </td>
 </tr>
</table>
</p><p>
The mode constants above may be combined by or-ing them. Combined constants are
predefined as:
</p><p>
<table border="0" cellpadding="3" cellspacing="0">
 <tr bgcolor="#0044AA" valign="top">
  <td><font color="#FFFFFF"><b>Mode</b></font></td>
  <td bgcolor="#0034AA"><font color="#FFFFFF"><b>Description</b></font></td>
 </tr>
 <tr bgcolor="#C0E0FF" valign="top">
  <td>ZCslTraceInfo</td>
  <td bgcolor="#B0D0FF">ZCslTraceFuncs | ZCslTraceBlks | ZCslTraceMsgs</td>
 </tr>
 <tr bgcolor="#E0F0FF" valign="top">
  <td>ZCslTraceAll</td>
  <td bgcolor="#D0E0FF">
   ZCslTraceCode | ZCslTraceFuncs | ZCslTraceBlks | ZCslTraceMsgs
  </td>
 </tr>
</table>
</p>

<FONT SIZE="+0"><pre>
long <B>ZCslTrace</B>(            /* trace a message */
   ZCslHandle aHandle,      /* CSL handle */
   const char *aMessage     /* message to display when tracing */
);
</pre></FONT><p>
Provide trace information. The message will only be displayed when
tracing messages is enabled.
</p><p>
Example:
</p><pre>
long errs;
errs = ZCslTrace(csl, &quot;my message&quot;);
if (errs) .... /* error handling */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslTraceMode</B>(        /* query trace state */
   ZCslHandle aHandle,      /* CSL handle */
   long *aMode              /* returned mode value */
);
</pre></FONT><p>
Get current trace mode. (See <a href="capi45.htm">ZCslSetTraceMode</a> for mode values)
</p><p>
Example:
</p><pre>
long errs, trace;
errs = ZCslTraceMode(csl, &amp;trace);
if (errs) .... /* error handling */
if (trace != ZCslTraceNone)
  puts(&quot;trace is on\r\n&quot;);
else
  puts(&quot;trace is off\r\n&quot;);
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslVarResize</B>(         /* resize variable */
   ZCslHandle aHandle,         /* CSL handle */
   const char *aVarName        /* name and new layout of variable */
);
</pre></FONT><p>
Resize a local array (like <i>resize</i> operator)
</p><p>
Example:
</p><pre>
/* resize list to hold 20 entries */
long errs = ZCslVarRezize(csl, &quot;list[20]&quot;);
if (errs) .... /* error handling */
</pre>

<FONT SIZE="+0"><pre>
long <B>ZCslVarSizeof</B>(           /* get size of variable */
   ZCslHandle aHandle,           /* CSL handle */
   const char *aVarName,         /* name of variable */
   long *aSize                   /* buffer for size */
);
</pre></FONT><p>
Get size of any local variable or constant (like <i>sizeof</i> operator)
</p><p>
Example:
</p><pre>
/* how big is list? */
long errs, size;
errs = ZCslVarSizeof(csl, &quot;list&quot;, &amp;size);
if (errs) .... /* error handling */
</pre>


<h4>Writing Libraries</h4>

<p>
Writing a CSL library is easy and gives you the opportunity to provide
a professional script interface to your application.
</p><p>
You should make yourself familiar with the concept of DLL's or shared libraries
in your compiler documentation. For your convenience you can consult the files
<i>build.bat</i> / <i>build.cmd</i> / <i>build</i> in the <i>Samples\API</i>
subdirectories to see what compiler and linker switches are required.
</p><p>
Your library must export 2 entries: <i>ZCslInitLib</i> and <i>ZCslCleanupLib</i>.
</p><p>
<i>ZCslInitLib</i> is called when the DLL gets loaded. You use the API to
define global var's and const's and load functions at startup. <i>ZCslCleanupLib</i>
will be called when the DLL is unloaded so you can perform any tidy up before
the CSL handle is closed.
</p><p>
You will find this sample library <i>MyLib.c</i> in the
<i>Samples\API\Source</i> directory. Use the sample as a starting point
for your own DLL's:
</p><pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ZCslApi.h&gt;
&nbsp;
/*
 * c h e c k N u m b e r
 *
 * Check if string represents a number
 */
static int checkNumber(char *s)
{
   int any;
   any = 0;
   if (*s=='-' || *s=='+') s++;
   while ('0'&lt;=*s && *s&lt;='9') { s++; any = 1; }
   if (*s=='.') s++;
   while ('0'&lt;=*s && *s&lt;='9') s++;
   return any && *s == 0;
} /* checkNumber */
&nbsp;
/*
 * a v e r a g e
 *
 * Sample CSL function calculating the average of up 5 numbers
 */
ZExportAPI(void) average(ZCslHandle aCsl)
{
   double sum;
   long bufsiz;
   int argCount, i;
   char buf[40], name[4];
&nbsp;
   /* get actual # of arguments */
   bufsiz = sizeof(buf);
   ZCslGet(aCsl, &quot;argCount&quot;, buf, &bufsiz);
   argCount = atoi(buf);
&nbsp;
   /* calculate sum of all arguments */
   sum = 0.0;
   for (i = 0; i &lt; argCount; i++) {
      /* create name of parameter */
      sprintf(name, &quot;p%d&quot;, i+1);
&nbsp;
      /* get argument */
      bufsiz = sizeof(buf);
      if ( ZCslGet(aCsl, name, buf, &bufsiz) ) return; /* (1) */
&nbsp;
      /* check for number */
      if (!checkNumber(buf)) {
         sprintf(buf, &quot;argument %d is no number!&quot;, i);
         ZCslSetError(aCsl, buf, -1); /* (2) */
      } /* if */
&nbsp;
      sum += atof(buf);
   } /* for */
&nbsp;
   /* return result */
   sprintf(buf, &quot;%f&quot;, sum / argCount);
   ZCslSetResult(aCsl, buf, -1); /* (2) */
} /* average */
&nbsp;
/*
 * i n i t i a l i z e
 *
 * initialize csl library at load time
 */
ZCslInitLib(csl)
{
   static char* module = &quot;MyLib&quot;;    /* module name */
   long errs;
&nbsp;
   /* define a global constant by loading a script */
   errs = ZCslLoadScriptMem(
      csl,                               /* csl handle */
      module,                            /* module name */
      &quot;const myVersion = 1.0;\n&quot;        /* script source */
   );
   if (errs) return; /* (1) */
&nbsp;
   /* load a function */
   ZCslAddFunc(
      csl,                               /* handle */
      module,                            /* module name */
      &quot;average(const p1, &quot;               /* declaration */
              &quot;const p2, &quot;
             &quot;[const p3, &quot;
              &quot;const p4, &quot;
              &quot;const p5])&quot;,
      average);                          /* function address */
   /* no errs check since returning anyway */
} /* initialize */
&nbsp;
/*
 * c l e a n u p
 *
 * clean up csl library before unloading
 */
ZCslCleanupLib(csl)
{
   /* nothing to clean up in our sample */
} /* cleanup */
</pre>


<p><a href=#index>Index</a>

<hr><p><a name="angel_interface"><h3>5.6 AngelScript functions</h3></a>

This section lists all the C functions interfacing the features of the
AngelScript interpreter. Read <a href="APOCALYX-manual-angel.htm#parti">Part X</a>
for more details about this scripting language.
Here you can read only the templates written in "<i>angel.h</i>".

<pre>
//// angel interface
typedef struct ScriptEngine ScriptEngine;
ScriptEngine * asCreateScriptEngine(int version);
const char * asGetLibraryVersion(void);
typedef struct ScriptContext ScriptContext;
ScriptContext * asGetActiveContext(void);
int asThreadCleanup(void);
int asEngine_AddRef(ScriptEngine *e);
int asEngine_Release(ScriptEngine *e);
typedef void (*OUTPUT_FUNC)(const char *text, void *param);
void asEngine_SetCommonMessageStream(ScriptEngine *e, OUTPUT_FUNC outFunc, void *outParam);
typedef void *(*ALLOC_FUNC)(unsigned long);
typedef void (*FREE_FUNC)(void *);
int asEngine_SetCommonObjectMemoryFunctions(ScriptEngine *e, ALLOC_FUNC allocFunc, FREE_FUNC freeFunc);
int asEngine_RegisterObjectType(ScriptEngine *e, const char *name, int byteSize, unsigned long flags);
int asEngine_RegisterObjectProperty(ScriptEngine *e, const char *obj, const char *declaration, int byteOffset);
typedef void (*FUNCTION_FUNC)();
int asEngine_RegisterObjectMethod(ScriptEngine *e, const char *obj, const char *declaration, FUNCTION_FUNC funcPointer, unsigned long callConv);
int asEngine_RegisterObjectBehaviour(ScriptEngine *e, const char *datatype, int behaviour, const char *declaration, FUNCTION_FUNC funcPointer, unsigned long callConv);
int asEngine_RegisterGlobalProperty(ScriptEngine *e, const char *declaration, void *pointer);
int asEngine_RegisterGlobalFunction(ScriptEngine *e, const char *declaration, FUNCTION_FUNC funcPointer, unsigned long callConv);
int asEngine_RegisterGlobalBehaviour(ScriptEngine *e, unsigned long behaviour, const char *declaration, FUNCTION_FUNC funcPointer, unsigned long callConv);
int asEngine_RegisterStringFactory(ScriptEngine *e, const char *datatype, FUNCTION_FUNC factoryFunc, unsigned long callConv);
int asEngine_BeginConfigGroup(ScriptEngine *e, const char *groupName);
int asEngine_EndConfigGroup(ScriptEngine *e);
int asEngine_RemoveConfigGroup(ScriptEngine *e, const char *groupName);
int asEngine_SetConfigGroupModuleAccess(ScriptEngine *e, const char *groupName, const char *module, int hasAccess);
int asEngine_AddScriptSection(ScriptEngine *e, const char *module, const char *name, const char *code, int codeLength, int lineOffset, int makeCopy);
int asEngine_Build(ScriptEngine *e, const char *module);
int asEngine_Discard(ScriptEngine *e, const char *module);
int asEngine_GetModuleIndex(ScriptEngine *e, const char *module);
const char * asEngine_GetModuleNameFromIndex(ScriptEngine *e, int index, int *length);
int asEngine_GetFunctionCount(ScriptEngine *e, const char *module);
int asEngine_GetFunctionIDByIndex(ScriptEngine *e, const char *module, int index);
int asEngine_GetFunctionIDByName(ScriptEngine *e, const char *module, const char *name);
int asEngine_GetFunctionIDByDecl(ScriptEngine *e, const char *module, const char *decl);
const char * asEngine_GetFunctionDeclaration(ScriptEngine *e, int funcID, int *length);
const char * asEngine_GetFunctionName(ScriptEngine *e, int funcID, int *length);
const char * asEngine_GetFunctionSection(ScriptEngine *e, int funcID, int *length);
int asEngine_GetGlobalVarCount(ScriptEngine *e, const char *module);
int asEngine_GetGlobalVarIDByIndex(ScriptEngine *e, const char *module, int index);
int asEngine_GetGlobalVarIDByName(ScriptEngine *e, const char *module, const char *name);
int asEngine_GetGlobalVarIDByDecl(ScriptEngine *e, const char *module, const char *decl);
const char * asEngine_GetGlobalVarDeclaration(ScriptEngine *e, int gvarID, int *length);
const char * asEngine_GetGlobalVarName(ScriptEngine *e, int gvarID, int *length);
void * asEngine_GetGlobalVarPointer(ScriptEngine *e, int gvarID);
int asEngine_GetImportedFunctionCount(ScriptEngine *e, const char *module);
int asEngine_GetImportedFunctionIndexByDecl(ScriptEngine *e, const char *module, const char *decl);
const char * asEngine_GetImportedFunctionDeclaration(ScriptEngine *e, const char *module, int importIndex, int *length);
const char * asEngine_GetImportedFunctionSourceModule(ScriptEngine *e, const char *module, int importIndex, int *length);
int asEngine_BindImportedFunction(ScriptEngine *e, const char *module, int importIndex, int funcID);
int asEngine_UnbindImportedFunction(ScriptEngine *e, const char *module, int importIndex);
int asEngine_BindAllImportedFunctions(ScriptEngine *e, const char *module);
int asEngine_UnbindAllImportedFunctions(ScriptEngine *e, const char *module);
int asEngine_GetTypeIdByDecl(ScriptEngine *e, const char *module, const char *decl);
const char * asEngine_GetTypeDeclaration(ScriptEngine *e, int typeId, int *length);
int asEngine_SetDefaultContextStackSize(ScriptEngine *e, unsigned int initial, unsigned int maximum);
ScriptContext *asEngine_CreateContext(ScriptEngine *e);
void * asEngine_CreateScriptObject(ScriptEngine *e, int typeId);
int asEngine_ExecuteString(ScriptEngine *e, const char *module, const char *script, ScriptContext **ctx, unsigned long flags);
int asEngine_GarbageCollect(ScriptEngine *e, int doFullCycle);
int asEngine_GetObjectsInGarbageCollectorCount(ScriptEngine *e);
typedef void (*BINARYREAD_FUNC)(void *ptr, unsigned long size, void *param);
typedef void (*BINARYWRITE_FUNC)(const void *ptr, unsigned long size, void *param);
int asEngine_SaveByteCode(ScriptEngine *e, const char *module, BINARYWRITE_FUNC outFunc, void *outParam);
int asEngine_LoadByteCode(ScriptEngine *e, const char *module, BINARYREAD_FUNC inFunc, void *inParam);
int asContext_AddRef(ScriptContext *c);
int asContext_Release(ScriptContext *c);
ScriptEngine *asContext_GetEngine(ScriptContext *c);
int asContext_GetState(ScriptContext *c);
int asContext_Prepare(ScriptContext *c, int funcID);
void asContext_SetRandomSeed(ScriptContext *c, unsigned int seed);
unsigned int asContext_GetRandomSeed(ScriptContext *c);
int asContext_AddInstructionCounter(ScriptContext *c, int count);
unsigned int asContext_GetAllocatedHeap(ScriptContext *c);
void asContext_SetMaxAllocableHeap(ScriptContext *c, unsigned int maxHeap);
int asContext_SetArgDWord(ScriptContext *c, unsigned int arg, unsigned long value);
int asContext_SetArgQWord(ScriptContext *c, unsigned int arg, long long value);
int asContext_SetArgFloat(ScriptContext *c, unsigned int arg, float value);
int asContext_SetArgDouble(ScriptContext *c, unsigned int arg, double value);
int asContext_SetArgObject(ScriptContext *c, unsigned int arg, void *obj);
unsigned long asContext_GetReturnDWord(ScriptContext *c);
long long asContext_GetReturnQWord(ScriptContext *c);
float asContext_GetReturnFloat(ScriptContext *c);
double asContext_GetReturnDouble(ScriptContext *c);
void * asContext_GetReturnObject(ScriptContext *c);
int asContext_Execute(ScriptContext *c);
int asContext_Abort(ScriptContext *c);
int asContext_Suspend(ScriptContext *c);
int asContext_GetCurrentLineNumber(ScriptContext *c, int *column);
int asContext_GetCurrentFunction(ScriptContext *c);
int asContext_SetException(ScriptContext *c, const char *string);
int asContext_GetExceptionLineNumber(ScriptContext *c, int *column);
int asContext_GetExceptionFunction(ScriptContext *c);
const char * asContext_GetExceptionString(ScriptContext *c, int *length);
int asContext_GetCallstackSize(ScriptContext *c);
int asContext_GetCallstackFunction(ScriptContext *c, int index);
int asContext_GetCallstackLineNumber(ScriptContext *c, int index, int *column );
typedef struct ScriptGeneric ScriptGeneric;
ScriptEngine *asGeneric_GetEngine(ScriptGeneric *g);
void * asGeneric_GetObject(ScriptGeneric *g);
unsigned long asGeneric_GetArgDWord(ScriptGeneric *g, unsigned int arg);
long long asGeneric_GetArgQWord(ScriptGeneric *g, unsigned int arg);
float asGeneric_GetArgFloat(ScriptGeneric *g, unsigned int arg);
double asGeneric_GetArgDouble(ScriptGeneric *g, unsigned int arg);
void * asGeneric_GetArgObject(ScriptGeneric *g, unsigned int arg);
int asGeneric_SetReturnDWord(ScriptGeneric *g, unsigned long val);
int asGeneric_SetReturnQWord(ScriptGeneric *g, long long val);
int asGeneric_SetReturnFloat(ScriptGeneric *g, float val);
int asGeneric_SetReturnDouble(ScriptGeneric *g, double val);
int asGeneric_SetReturnObject(ScriptGeneric *g, void *obj);
typedef struct ScriptAny ScriptAny;
int asAny_AddRef(ScriptAny *a);
int asAny_Release(ScriptAny *a);
void asAny_Store(ScriptAny *a, void *ref, int typeId);
int asAny_Retrieve(ScriptAny *a, void *ref, int typeId);
int asAny_GetTypeId(ScriptAny *a);
int asAny_CopyFrom(ScriptAny *a, ScriptAny *other);
typedef struct ScriptStruct ScriptStruct;
int asStruct_AddRef(ScriptStruct *s);
int asStruct_Release(ScriptStruct *s);
int asStruct_GetStructTypeId(ScriptStruct *s);
int asStruct_GetPropertyCount(ScriptStruct *s);
int asStruct_GetPropertyTypeId(ScriptStruct *s, unsigned int prop);
const char *asStruct_GetPropertyName(ScriptStruct *s, unsigned int prop);
void * asStruct_GetPropertyPointer(ScriptStruct *s, unsigned int prop);
int asStruct_CopyFrom(ScriptStruct *s, ScriptStruct *other);
typedef struct ScriptArray ScriptArray;
int asArray_AddRef(ScriptArray *a);
int asArray_Release(ScriptArray *a);
int asArray_GetArrayTypeId(ScriptArray *a);
int asArray_GetElementTypeId(ScriptArray *a);
unsigned long asArray_GetElementCount(ScriptArray *a);
void * asArray_GetElementPointer(ScriptArray *a, unsigned int index);
void asArray_Resize(ScriptArray *a, unsigned int size);
int asArray_CopyFrom(ScriptArray *a, ScriptArray *other);
</pre>

<p><a href=#index>Index</a>

<hr><p><a name="small_interface"><h3>5.7 SMALL functions</h3></a>

This section lists all the C functions interfacing the features of the
SMALL interpreter. Read <a href="APOCALYX-manual-small.htm#parti">Part XII</a>
for more details about this scripting language.
Here you can read only the templates written in "<i>small.h</i>".

<pre>
//// SMALL interface
// create
typedef struct Small Small;
Small* smallCreate();
int smallDelete(Small* i);
// load
typedef struct Data Data;
int smallLoadData(Small* i, Data* d, int memoryLimit);
int smallLoadFile(Small* i, char* fileName, int memoryLimit);
void smallUnload(Small* i);
int smallIsLoaded(SLInterpreter* i);
// register
typedef struct AMX AMX;
//typedef int __stdcall (*AMX_NATIVE)(AMX* amx, int* params);
typedef struct {char* name; void* func;} AMX_NATIVE_INFO;
int smallRegisterNatives(Small* i, AMX_NATIVE_INFO natives[]);
// execute
int smallInitMain(SLInterpreter* i);
int smallExecMain(SLInterpreter* i, int cycles);
int smallFindPublic(SLInterpreter* i, char* name, int* index);
int smallExecFunc(SLInterpreter* i, int index, int cycles);
int smallGetReturnValue(SLInterpreter* i);
int smallIsRunning(SLInterpreter* i);
// set
void smallSetRandomSeed(SLInterpreter* i, unsigned int rs);
// timer
int smallGetTimerLeft();
void smallDecreaseTimer(int dec);
// conversion
int smallFloatToCell(float f);
float smallCellToFloat(int i);
</pre>

<p><a href=#index>Index</a>

<hr><p>Any question? Contact: <A HREF="mailto:tetractys@users.sourceforge.net">tetractys@users.sf.net</A>
<br>Online resources: <A HREF="http://apocalyx.sourceforge.net">http://apocalyx.sf.net</A>

</font>
</BODY>
</HTML>